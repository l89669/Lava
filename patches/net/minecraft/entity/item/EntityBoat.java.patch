--- ../src-base/minecraft/net/minecraft/entity/item/EntityBoat.java
+++ ../src-work/minecraft/net/minecraft/entity/item/EntityBoat.java
@@ -1,8 +1,6 @@
 package net.minecraft.entity.item;
 
 import com.google.common.collect.Lists;
-import java.util.List;
-import javax.annotation.Nullable;
 import net.minecraft.block.BlockLiquid;
 import net.minecraft.block.BlockPlanks;
 import net.minecraft.block.material.Material;
@@ -23,12 +21,7 @@
 import net.minecraft.network.datasync.DataSerializers;
 import net.minecraft.network.datasync.EntityDataManager;
 import net.minecraft.network.play.client.CPacketSteerBoat;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.EntityDamageSourceIndirect;
-import net.minecraft.util.EntitySelectors;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.EnumHand;
-import net.minecraft.util.SoundEvent;
+import net.minecraft.util.*;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
@@ -36,14 +29,22 @@
 import net.minecraft.world.World;
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
+import org.bukkit.Location;
+import org.bukkit.entity.Vehicle;
+import org.bukkit.event.vehicle.VehicleDamageEvent;
+import org.bukkit.event.vehicle.VehicleDestroyEvent;
+import org.bukkit.event.vehicle.VehicleEntityCollisionEvent;
+import org.bukkit.event.vehicle.VehicleMoveEvent;
 
-public class EntityBoat extends Entity
-{
+import javax.annotation.Nullable;
+import java.util.List;
+
+public class EntityBoat extends Entity {
     private static final DataParameter<Integer> TIME_SINCE_HIT = EntityDataManager.<Integer>createKey(EntityBoat.class, DataSerializers.VARINT);
     private static final DataParameter<Integer> FORWARD_DIRECTION = EntityDataManager.<Integer>createKey(EntityBoat.class, DataSerializers.VARINT);
     private static final DataParameter<Float> DAMAGE_TAKEN = EntityDataManager.<Float>createKey(EntityBoat.class, DataSerializers.FLOAT);
     private static final DataParameter<Integer> BOAT_TYPE = EntityDataManager.<Integer>createKey(EntityBoat.class, DataSerializers.VARINT);
-    private static final DataParameter<Boolean>[] DATA_ID_PADDLE = new DataParameter[] {EntityDataManager.createKey(EntityBoat.class, DataSerializers.BOOLEAN), EntityDataManager.createKey(EntityBoat.class, DataSerializers.BOOLEAN)};
+    private static final DataParameter<Boolean>[] DATA_ID_PADDLE = new DataParameter[]{EntityDataManager.createKey(EntityBoat.class, DataSerializers.BOOLEAN), EntityDataManager.createKey(EntityBoat.class, DataSerializers.BOOLEAN)};
     private final float[] paddlePositions;
     private float momentum;
     private float outOfControlTicks;
@@ -64,16 +65,20 @@
     private EntityBoat.Status previousStatus;
     private double lastYd;
 
-    public EntityBoat(World worldIn)
-    {
+    // Some of these haven't worked since a few updates, and since 1.9 they are less and less applicable.
+    public double maxSpeed = 0.4D;
+    public double occupiedDeceleration = 0.2D;
+    public double unoccupiedDeceleration = -1;
+    public boolean landBoats = false;
+
+    public EntityBoat(World worldIn) {
         super(worldIn);
         this.paddlePositions = new float[2];
         this.preventEntitySpawning = true;
         this.setSize(1.375F, 0.5625F);
     }
 
-    public EntityBoat(World worldIn, double x, double y, double z)
-    {
+    public EntityBoat(World worldIn, double x, double y, double z) {
         this(worldIn);
         this.setPosition(x, y, z);
         this.motionX = 0.0D;
@@ -84,70 +89,71 @@
         this.prevPosZ = z;
     }
 
-    protected boolean canTriggerWalking()
-    {
+    protected boolean canTriggerWalking() {
         return false;
     }
 
-    protected void entityInit()
-    {
+    protected void entityInit() {
         this.dataManager.register(TIME_SINCE_HIT, Integer.valueOf(0));
         this.dataManager.register(FORWARD_DIRECTION, Integer.valueOf(1));
         this.dataManager.register(DAMAGE_TAKEN, Float.valueOf(0.0F));
         this.dataManager.register(BOAT_TYPE, Integer.valueOf(EntityBoat.Type.OAK.ordinal()));
 
-        for (DataParameter<Boolean> dataparameter : DATA_ID_PADDLE)
-        {
+        for (DataParameter<Boolean> dataparameter : DATA_ID_PADDLE) {
             this.dataManager.register(dataparameter, Boolean.valueOf(false));
         }
     }
 
     @Nullable
-    public AxisAlignedBB getCollisionBox(Entity entityIn)
-    {
+    public AxisAlignedBB getCollisionBox(Entity entityIn) {
         return entityIn.canBePushed() ? entityIn.getEntityBoundingBox() : null;
     }
 
     @Nullable
-    public AxisAlignedBB getCollisionBoundingBox()
-    {
+    public AxisAlignedBB getCollisionBoundingBox() {
         return this.getEntityBoundingBox();
     }
 
-    public boolean canBePushed()
-    {
+    public boolean canBePushed() {
         return true;
     }
 
-    public double getMountedYOffset()
-    {
+    public double getMountedYOffset() {
         return -0.1D;
     }
 
-    public boolean attackEntityFrom(DamageSource source, float amount)
-    {
-        if (this.isEntityInvulnerable(source))
-        {
+    public boolean attackEntityFrom(DamageSource source, float amount) {
+        if (this.isEntityInvulnerable(source)) {
             return false;
-        }
-        else if (!this.world.isRemote && !this.isDead)
-        {
-            if (source instanceof EntityDamageSourceIndirect && source.getTrueSource() != null && this.isPassenger(source.getTrueSource()))
-            {
+        } else if (!this.world.isRemote && !this.isDead) {
+            if (source instanceof EntityDamageSourceIndirect && source.getTrueSource() != null && this.isPassenger(source.getTrueSource())) {
                 return false;
-            }
-            else
-            {
+            } else {
+                Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+                org.bukkit.entity.Entity attacker = (source.getTrueSource() == null) ? null : source.getTrueSource().getBukkitEntity();
+
+                VehicleDamageEvent event = new VehicleDamageEvent(vehicle, attacker, (double) amount);
+                this.world.getServer().getPluginManager().callEvent(event);
+
+                if (event.isCancelled()) {
+                    return true;
+                }
+                // amount = event.getDamage(); // TODO Why don't we do this?
                 this.setForwardDirection(-this.getForwardDirection());
                 this.setTimeSinceHit(10);
                 this.setDamageTaken(this.getDamageTaken() + amount * 10.0F);
                 this.markVelocityChanged();
-                boolean flag = source.getTrueSource() instanceof EntityPlayer && ((EntityPlayer)source.getTrueSource()).capabilities.isCreativeMode;
+                boolean flag = source.getTrueSource() instanceof EntityPlayer && ((EntityPlayer) source.getTrueSource()).capabilities.isCreativeMode;
 
-                if (flag || this.getDamageTaken() > 40.0F)
-                {
-                    if (!flag && this.world.getGameRules().getBoolean("doEntityDrops"))
-                    {
+                if (flag || this.getDamageTaken() > 40.0F) {
+                    VehicleDestroyEvent destroyEvent = new VehicleDestroyEvent(vehicle, attacker);
+                    this.world.getServer().getPluginManager().callEvent(destroyEvent);
+
+                    if (destroyEvent.isCancelled()) {
+                        this.setDamageTaken(40F); // Maximize damage so this doesn't get triggered again right away
+                        return true;
+                    }
+                    if (!flag && this.world.getGameRules().getBoolean("doEntityDrops")) {
                         this.dropItemWithOffset(this.getItemBoat(), 1, 0.0F);
                     }
 
@@ -156,32 +162,35 @@
 
                 return true;
             }
-        }
-        else
-        {
+        } else {
             return true;
         }
     }
 
-    public void applyEntityCollision(Entity entityIn)
-    {
-        if (entityIn instanceof EntityBoat)
-        {
-            if (entityIn.getEntityBoundingBox().minY < this.getEntityBoundingBox().maxY)
-            {
+    public void applyEntityCollision(Entity entityIn) {
+        if (entityIn instanceof EntityBoat) {
+            if (entityIn.getEntityBoundingBox().minY < this.getEntityBoundingBox().maxY) {
+                VehicleEntityCollisionEvent event = new VehicleEntityCollisionEvent((Vehicle) this.getBukkitEntity(), entityIn.getBukkitEntity());
+                this.world.getServer().getPluginManager().callEvent(event);
+
+                if (event.isCancelled()) {
+                    return;
+                }
                 super.applyEntityCollision(entityIn);
             }
-        }
-        else if (entityIn.getEntityBoundingBox().minY <= this.getEntityBoundingBox().minY)
-        {
+        } else if (entityIn.getEntityBoundingBox().minY <= this.getEntityBoundingBox().minY) {
+            VehicleEntityCollisionEvent event = new VehicleEntityCollisionEvent((Vehicle) this.getBukkitEntity(), entityIn.getBukkitEntity());
+            this.world.getServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                return;
+            }
             super.applyEntityCollision(entityIn);
         }
     }
 
-    public Item getItemBoat()
-    {
-        switch (this.getBoatType())
-        {
+    public Item getItemBoat() {
+        switch (this.getBoatType()) {
             case OAK:
             default:
                 return Items.BOAT;
@@ -199,60 +208,51 @@
     }
 
     @SideOnly(Side.CLIENT)
-    public void performHurtAnimation()
-    {
+    public void performHurtAnimation() {
         this.setForwardDirection(-this.getForwardDirection());
         this.setTimeSinceHit(10);
         this.setDamageTaken(this.getDamageTaken() * 11.0F);
     }
 
-    public boolean canBeCollidedWith()
-    {
+    public boolean canBeCollidedWith() {
         return !this.isDead;
     }
 
     @SideOnly(Side.CLIENT)
-    public void setPositionAndRotationDirect(double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport)
-    {
+    public void setPositionAndRotationDirect(double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport) {
         this.lerpX = x;
         this.lerpY = y;
         this.lerpZ = z;
-        this.lerpYaw = (double)yaw;
-        this.lerpPitch = (double)pitch;
+        this.lerpYaw = (double) yaw;
+        this.lerpPitch = (double) pitch;
         this.lerpSteps = 10;
     }
 
-    public EnumFacing getAdjustedHorizontalFacing()
-    {
+    public EnumFacing getAdjustedHorizontalFacing() {
         return this.getHorizontalFacing().rotateY();
     }
 
-    public void onUpdate()
-    {
+    private Location lastLocation;
+
+    public void onUpdate() {
         this.previousStatus = this.status;
         this.status = this.getBoatStatus();
 
-        if (this.status != EntityBoat.Status.UNDER_WATER && this.status != EntityBoat.Status.UNDER_FLOWING_WATER)
-        {
+        if (this.status != Status.UNDER_WATER && this.status != Status.UNDER_FLOWING_WATER) {
             this.outOfControlTicks = 0.0F;
-        }
-        else
-        {
+        } else {
             ++this.outOfControlTicks;
         }
 
-        if (!this.world.isRemote && this.outOfControlTicks >= 60.0F)
-        {
+        if (!this.world.isRemote && this.outOfControlTicks >= 60.0F) {
             this.removePassengers();
         }
 
-        if (this.getTimeSinceHit() > 0)
-        {
+        if (this.getTimeSinceHit() > 0) {
             this.setTimeSinceHit(this.getTimeSinceHit() - 1);
         }
 
-        if (this.getDamageTaken() > 0.0F)
-        {
+        if (this.getDamageTaken() > 0.0F) {
             this.setDamageTaken(this.getDamageTaken() - 1.0F);
         }
 
@@ -262,51 +262,54 @@
         super.onUpdate();
         this.tickLerp();
 
-        if (this.canPassengerSteer())
-        {
-            if (this.getPassengers().isEmpty() || !(this.getPassengers().get(0) instanceof EntityPlayer))
-            {
+        if (this.canPassengerSteer()) {
+            if (this.getPassengers().isEmpty() || !(this.getPassengers().get(0) instanceof EntityPlayer)) {
                 this.setPaddleState(false, false);
             }
 
             this.updateMotion();
 
-            if (this.world.isRemote)
-            {
+            if (this.world.isRemote) {
                 this.controlBoat();
                 this.world.sendPacketToServer(new CPacketSteerBoat(this.getPaddleState(0), this.getPaddleState(1)));
             }
 
             this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
-        }
-        else
-        {
+        } else {
             this.motionX = 0.0D;
             this.motionY = 0.0D;
             this.motionZ = 0.0D;
         }
 
-        for (int i = 0; i <= 1; ++i)
-        {
-            if (this.getPaddleState(i))
-            {
-                if (!this.isSilent() && (double)(this.paddlePositions[i] % ((float)Math.PI * 2F)) <= (Math.PI / 4D) && ((double)this.paddlePositions[i] + 0.39269909262657166D) % (Math.PI * 2D) >= (Math.PI / 4D))
-                {
+        org.bukkit.Server server = this.world.getServer();
+        org.bukkit.World bworld = this.world.getWorld();
+
+        Location to = new Location(bworld, this.posX, this.posY, this.posZ, this.rotationYaw, this.rotationPitch);
+        Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+
+        server.getPluginManager().callEvent(new org.bukkit.event.vehicle.VehicleUpdateEvent(vehicle));
+
+        if (lastLocation != null && !lastLocation.equals(to)) {
+            VehicleMoveEvent event = new VehicleMoveEvent(vehicle, lastLocation, to);
+            server.getPluginManager().callEvent(event);
+        }
+        lastLocation = vehicle.getLocation();
+
+        for (int i = 0; i <= 1; ++i) {
+            if (this.getPaddleState(i)) {
+                if (!this.isSilent() && (double) (this.paddlePositions[i] % ((float) Math.PI * 2F)) <= (Math.PI / 4D) && ((double) this.paddlePositions[i] + 0.39269909262657166D) % (Math.PI * 2D) >= (Math.PI / 4D)) {
                     SoundEvent soundevent = this.getPaddleSound();
 
-                    if (soundevent != null)
-                    {
+                    if (soundevent != null) {
                         Vec3d vec3d = this.getLook(1.0F);
                         double d0 = i == 1 ? -vec3d.z : vec3d.z;
                         double d1 = i == 1 ? vec3d.x : -vec3d.x;
-                        this.world.playSound((EntityPlayer)null, this.posX + d0, this.posY, this.posZ + d1, soundevent, this.getSoundCategory(), 1.0F, 0.8F + 0.4F * this.rand.nextFloat());
+                        this.world.playSound((EntityPlayer) null, this.posX + d0, this.posY, this.posZ + d1, soundevent, this.getSoundCategory(), 1.0F, 0.8F + 0.4F * this.rand.nextFloat());
                     }
                 }
 
-                this.paddlePositions[i] = (float)((double)this.paddlePositions[i] + 0.39269909262657166D);
-            }
-            else
-            {
+                this.paddlePositions[i] = (float) ((double) this.paddlePositions[i] + 0.39269909262657166D);
+            } else {
                 this.paddlePositions[i] = 0.0F;
             }
         }
@@ -314,22 +317,16 @@
         this.doBlockCollisions();
         List<Entity> list = this.world.getEntitiesInAABBexcluding(this, this.getEntityBoundingBox().grow(0.20000000298023224D, -0.009999999776482582D, 0.20000000298023224D), EntitySelectors.getTeamCollisionPredicate(this));
 
-        if (!list.isEmpty())
-        {
+        if (!list.isEmpty()) {
             boolean flag = !this.world.isRemote && !(this.getControllingPassenger() instanceof EntityPlayer);
 
-            for (int j = 0; j < list.size(); ++j)
-            {
+            for (int j = 0; j < list.size(); ++j) {
                 Entity entity = list.get(j);
 
-                if (!entity.isPassenger(this))
-                {
-                    if (flag && this.getPassengers().size() < 2 && !entity.isRiding() && entity.width < this.width && entity instanceof EntityLivingBase && !(entity instanceof EntityWaterMob) && !(entity instanceof EntityPlayer))
-                    {
+                if (!entity.isPassenger(this)) {
+                    if (flag && this.getPassengers().size() < 2 && !entity.isRiding() && entity.width < this.width && entity instanceof EntityLivingBase && !(entity instanceof EntityWaterMob) && !(entity instanceof EntityPlayer)) {
                         entity.startRiding(this);
-                    }
-                    else
-                    {
+                    } else {
                         this.applyEntityCollision(entity);
                     }
                 }
@@ -338,10 +335,8 @@
     }
 
     @Nullable
-    protected SoundEvent getPaddleSound()
-    {
-        switch (this.getBoatStatus())
-        {
+    protected SoundEvent getPaddleSound() {
+        switch (this.getBoatStatus()) {
             case IN_WATER:
             case UNDER_WATER:
             case UNDER_FLOWING_WATER:
@@ -354,65 +349,51 @@
         }
     }
 
-    private void tickLerp()
-    {
-        if (this.lerpSteps > 0 && !this.canPassengerSteer())
-        {
-            double d0 = this.posX + (this.lerpX - this.posX) / (double)this.lerpSteps;
-            double d1 = this.posY + (this.lerpY - this.posY) / (double)this.lerpSteps;
-            double d2 = this.posZ + (this.lerpZ - this.posZ) / (double)this.lerpSteps;
-            double d3 = MathHelper.wrapDegrees(this.lerpYaw - (double)this.rotationYaw);
-            this.rotationYaw = (float)((double)this.rotationYaw + d3 / (double)this.lerpSteps);
-            this.rotationPitch = (float)((double)this.rotationPitch + (this.lerpPitch - (double)this.rotationPitch) / (double)this.lerpSteps);
+    private void tickLerp() {
+        if (this.lerpSteps > 0 && !this.canPassengerSteer()) {
+            double d0 = this.posX + (this.lerpX - this.posX) / (double) this.lerpSteps;
+            double d1 = this.posY + (this.lerpY - this.posY) / (double) this.lerpSteps;
+            double d2 = this.posZ + (this.lerpZ - this.posZ) / (double) this.lerpSteps;
+            double d3 = MathHelper.wrapDegrees(this.lerpYaw - (double) this.rotationYaw);
+            this.rotationYaw = (float) ((double) this.rotationYaw + d3 / (double) this.lerpSteps);
+            this.rotationPitch = (float) ((double) this.rotationPitch + (this.lerpPitch - (double) this.rotationPitch) / (double) this.lerpSteps);
             --this.lerpSteps;
             this.setPosition(d0, d1, d2);
             this.setRotation(this.rotationYaw, this.rotationPitch);
         }
     }
 
-    public void setPaddleState(boolean left, boolean right)
-    {
+    public void setPaddleState(boolean left, boolean right) {
         this.dataManager.set(DATA_ID_PADDLE[0], Boolean.valueOf(left));
         this.dataManager.set(DATA_ID_PADDLE[1], Boolean.valueOf(right));
     }
 
     @SideOnly(Side.CLIENT)
-    public float getRowingTime(int side, float limbSwing)
-    {
-        return this.getPaddleState(side) ? (float)MathHelper.clampedLerp((double)this.paddlePositions[side] - 0.39269909262657166D, (double)this.paddlePositions[side], (double)limbSwing) : 0.0F;
+    public float getRowingTime(int side, float limbSwing) {
+        return this.getPaddleState(side) ? (float) MathHelper.clampedLerp((double) this.paddlePositions[side] - 0.39269909262657166D, (double) this.paddlePositions[side], (double) limbSwing) : 0.0F;
     }
 
-    private EntityBoat.Status getBoatStatus()
-    {
+    private EntityBoat.Status getBoatStatus() {
         EntityBoat.Status entityboat$status = this.getUnderwaterStatus();
 
-        if (entityboat$status != null)
-        {
+        if (entityboat$status != null) {
             this.waterLevel = this.getEntityBoundingBox().maxY;
             return entityboat$status;
-        }
-        else if (this.checkInWater())
-        {
+        } else if (this.checkInWater()) {
             return EntityBoat.Status.IN_WATER;
-        }
-        else
-        {
+        } else {
             float f = this.getBoatGlide();
 
-            if (f > 0.0F)
-            {
+            if (f > 0.0F) {
                 this.boatGlide = f;
                 return EntityBoat.Status.ON_LAND;
-            }
-            else
-            {
+            } else {
                 return EntityBoat.Status.IN_AIR;
             }
         }
     }
 
-    public float getWaterLevelAbove()
-    {
+    public float getWaterLevelAbove() {
         AxisAlignedBB axisalignedbb = this.getEntityBoundingBox();
         int i = MathHelper.floor(axisalignedbb.minX);
         int j = MathHelper.ceil(axisalignedbb.maxX);
@@ -422,30 +403,24 @@
         int j1 = MathHelper.ceil(axisalignedbb.maxZ);
         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
-        try
-        {
+        try {
             label108:
 
-            for (int k1 = k; k1 < l; ++k1)
-            {
+            for (int k1 = k; k1 < l; ++k1) {
                 float f = 0.0F;
                 int l1 = i;
 
-                while (true)
-                {
-                    if (l1 >= j)
-                    {
-                        if (f < 1.0F)
-                        {
-                            float f2 = (float)blockpos$pooledmutableblockpos.getY() + f;
+                while (true) {
+                    if (l1 >= j) {
+                        if (f < 1.0F) {
+                            float f2 = (float) blockpos$pooledmutableblockpos.getY() + f;
                             return f2;
                         }
 
                         break;
                     }
 
-                    for (int i2 = i1; i2 < j1; ++i2)
-                    {
+                    for (int i2 = i1; i2 < j1; ++i2) {
                         blockpos$pooledmutableblockpos.setPos(l1, k1, i2);
                         IBlockState iblockstate = this.world.getBlockState(blockpos$pooledmutableblockpos);
 
@@ -455,13 +430,11 @@
                             f = Math.max(f, iblockstate.getBlock().getBlockLiquidHeight(world, blockpos$pooledmutableblockpos, iblockstate, Material.WATER) + blockpos$pooledmutableblockpos.getY());
                         }
 
-                        if (iblockstate.getMaterial() == Material.WATER)
-                        {
+                        if (iblockstate.getMaterial() == Material.WATER) {
                             f = Math.max(f, BlockLiquid.getBlockLiquidHeight(iblockstate, this.world, blockpos$pooledmutableblockpos));
                         }
 
-                        if (f >= 1.0F)
-                        {
+                        if (f >= 1.0F) {
                             continue label108;
                         }
                     }
@@ -470,17 +443,14 @@
                 }
             }
 
-            float f1 = (float)(l + 1);
+            float f1 = (float) (l + 1);
             return f1;
-        }
-        finally
-        {
+        } finally {
             blockpos$pooledmutableblockpos.release();
         }
     }
 
-    public float getBoatGlide()
-    {
+    public float getBoatGlide() {
         AxisAlignedBB axisalignedbb = this.getEntityBoundingBox();
         AxisAlignedBB axisalignedbb1 = new AxisAlignedBB(axisalignedbb.minX, axisalignedbb.minY - 0.001D, axisalignedbb.minZ, axisalignedbb.maxX, axisalignedbb.minY, axisalignedbb.maxZ);
         int i = MathHelper.floor(axisalignedbb1.minX) - 1;
@@ -494,26 +464,19 @@
         int k1 = 0;
         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
-        try
-        {
-            for (int l1 = i; l1 < j; ++l1)
-            {
-                for (int i2 = i1; i2 < j1; ++i2)
-                {
+        try {
+            for (int l1 = i; l1 < j; ++l1) {
+                for (int i2 = i1; i2 < j1; ++i2) {
                     int j2 = (l1 != i && l1 != j - 1 ? 0 : 1) + (i2 != i1 && i2 != j1 - 1 ? 0 : 1);
 
-                    if (j2 != 2)
-                    {
-                        for (int k2 = k; k2 < l; ++k2)
-                        {
-                            if (j2 <= 0 || k2 != k && k2 != l - 1)
-                            {
+                    if (j2 != 2) {
+                        for (int k2 = k; k2 < l; ++k2) {
+                            if (j2 <= 0 || k2 != k && k2 != l - 1) {
                                 blockpos$pooledmutableblockpos.setPos(l1, k2, i2);
                                 IBlockState iblockstate = this.world.getBlockState(blockpos$pooledmutableblockpos);
                                 iblockstate.addCollisionBoxToList(this.world, blockpos$pooledmutableblockpos, axisalignedbb1, list, this, false);
 
-                                if (!list.isEmpty())
-                                {
+                                if (!list.isEmpty()) {
                                     f += iblockstate.getBlock().getSlipperiness(iblockstate, this.world, blockpos$pooledmutableblockpos, this);
                                     ++k1;
                                 }
@@ -524,17 +487,14 @@
                     }
                 }
             }
-        }
-        finally
-        {
+        } finally {
             blockpos$pooledmutableblockpos.release();
         }
 
-        return f / (float)k1;
+        return f / (float) k1;
     }
 
-    private boolean checkInWater()
-    {
+    private boolean checkInWater() {
         AxisAlignedBB axisalignedbb = this.getEntityBoundingBox();
         int i = MathHelper.floor(axisalignedbb.minX);
         int j = MathHelper.ceil(axisalignedbb.maxX);
@@ -546,38 +506,31 @@
         this.waterLevel = Double.MIN_VALUE;
         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
-        try
-        {
-            for (int k1 = i; k1 < j; ++k1)
-            {
-                for (int l1 = k; l1 < l; ++l1)
-                {
-                    for (int i2 = i1; i2 < j1; ++i2)
-                    {
+        try {
+            for (int k1 = i; k1 < j; ++k1) {
+                for (int l1 = k; l1 < l; ++l1) {
+                    for (int i2 = i1; i2 < j1; ++i2) {
                         blockpos$pooledmutableblockpos.setPos(k1, l1, i2);
                         IBlockState iblockstate = this.world.getBlockState(blockpos$pooledmutableblockpos);
 
                         Boolean result = iblockstate.getBlock().isAABBInsideMaterial(world, blockpos$pooledmutableblockpos, axisalignedbb, Material.WATER);
                         if (result != null) {
                             if (!result) continue;
-                            
+
                             float f = iblockstate.getBlock().getBlockLiquidHeight(world, blockpos$pooledmutableblockpos, iblockstate, Material.WATER) + blockpos$pooledmutableblockpos.getY();
-                            this.waterLevel = Math.max((double)f, this.waterLevel);
-                            flag |= axisalignedbb.minY < (double)f;
+                            this.waterLevel = Math.max((double) f, this.waterLevel);
+                            flag |= axisalignedbb.minY < (double) f;
                         }
 
-                        if (iblockstate.getMaterial() == Material.WATER)
-                        {
+                        if (iblockstate.getMaterial() == Material.WATER) {
                             float f = BlockLiquid.getLiquidHeight(iblockstate, this.world, blockpos$pooledmutableblockpos);
-                            this.waterLevel = Math.max((double)f, this.waterLevel);
-                            flag |= axisalignedbb.minY < (double)f;
+                            this.waterLevel = Math.max((double) f, this.waterLevel);
+                            flag |= axisalignedbb.minY < (double) f;
                         }
                     }
                 }
             }
-        }
-        finally
-        {
+        } finally {
             blockpos$pooledmutableblockpos.release();
         }
 
@@ -585,8 +538,7 @@
     }
 
     @Nullable
-    private EntityBoat.Status getUnderwaterStatus()
-    {
+    private EntityBoat.Status getUnderwaterStatus() {
         AxisAlignedBB axisalignedbb = this.getEntityBoundingBox();
         double d0 = axisalignedbb.maxY + 0.001D;
         int i = MathHelper.floor(axisalignedbb.minX);
@@ -598,33 +550,26 @@
         boolean flag = false;
         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
-        try
-        {
-            for (int k1 = i; k1 < j; ++k1)
-            {
-                for (int l1 = k; l1 < l; ++l1)
-                {
-                    for (int i2 = i1; i2 < j1; ++i2)
-                    {
+        try {
+            for (int k1 = i; k1 < j; ++k1) {
+                for (int l1 = k; l1 < l; ++l1) {
+                    for (int i2 = i1; i2 < j1; ++i2) {
                         blockpos$pooledmutableblockpos.setPos(k1, l1, i2);
                         IBlockState iblockstate = this.world.getBlockState(blockpos$pooledmutableblockpos);
 
                         Boolean result = iblockstate.getBlock().isAABBInsideMaterial(world, blockpos$pooledmutableblockpos, axisalignedbb, Material.WATER);
                         if (result != null) {
                             if (!result) continue;
-                            
-                            if(iblockstate.getBlock().getBlockLiquidHeight(world, blockpos$pooledmutableblockpos, iblockstate, Material.WATER) > 0)
-                            {   
+
+                            if (iblockstate.getBlock().getBlockLiquidHeight(world, blockpos$pooledmutableblockpos, iblockstate, Material.WATER) > 0) {
                                 blockpos$pooledmutableblockpos.release();
                                 return EntityBoat.Status.UNDER_FLOWING_WATER;
                             } else
                                 continue;
                         }
 
-                        if (iblockstate.getMaterial() == Material.WATER && d0 < (double)BlockLiquid.getLiquidHeight(iblockstate, this.world, blockpos$pooledmutableblockpos))
-                        {
-                            if (((Integer)iblockstate.getValue(BlockLiquid.LEVEL)).intValue() != 0)
-                            {
+                        if (iblockstate.getMaterial() == Material.WATER && d0 < (double) BlockLiquid.getLiquidHeight(iblockstate, this.world, blockpos$pooledmutableblockpos)) {
+                            if (((Integer) iblockstate.getValue(BlockLiquid.LEVEL)).intValue() != 0) {
                                 EntityBoat.Status entityboat$status = EntityBoat.Status.UNDER_FLOWING_WATER;
                                 return entityboat$status;
                             }
@@ -634,68 +579,51 @@
                     }
                 }
             }
-        }
-        finally
-        {
+        } finally {
             blockpos$pooledmutableblockpos.release();
         }
 
         return flag ? EntityBoat.Status.UNDER_WATER : null;
     }
 
-    private void updateMotion()
-    {
+    private void updateMotion() {
         double d0 = -0.03999999910593033D;
         double d1 = this.hasNoGravity() ? 0.0D : -0.03999999910593033D;
         double d2 = 0.0D;
         this.momentum = 0.05F;
 
-        if (this.previousStatus == EntityBoat.Status.IN_AIR && this.status != EntityBoat.Status.IN_AIR && this.status != EntityBoat.Status.ON_LAND)
-        {
-            this.waterLevel = this.getEntityBoundingBox().minY + (double)this.height;
-            this.setPosition(this.posX, (double)(this.getWaterLevelAbove() - this.height) + 0.101D, this.posZ);
+        if (this.previousStatus == EntityBoat.Status.IN_AIR && this.status != EntityBoat.Status.IN_AIR && this.status != EntityBoat.Status.ON_LAND) {
+            this.waterLevel = this.getEntityBoundingBox().minY + (double) this.height;
+            this.setPosition(this.posX, (double) (this.getWaterLevelAbove() - this.height) + 0.101D, this.posZ);
             this.motionY = 0.0D;
             this.lastYd = 0.0D;
             this.status = EntityBoat.Status.IN_WATER;
-        }
-        else
-        {
-            if (this.status == EntityBoat.Status.IN_WATER)
-            {
-                d2 = (this.waterLevel - this.getEntityBoundingBox().minY) / (double)this.height;
+        } else {
+            if (this.status == EntityBoat.Status.IN_WATER) {
+                d2 = (this.waterLevel - this.getEntityBoundingBox().minY) / (double) this.height;
                 this.momentum = 0.9F;
-            }
-            else if (this.status == EntityBoat.Status.UNDER_FLOWING_WATER)
-            {
+            } else if (this.status == EntityBoat.Status.UNDER_FLOWING_WATER) {
                 d1 = -7.0E-4D;
                 this.momentum = 0.9F;
-            }
-            else if (this.status == EntityBoat.Status.UNDER_WATER)
-            {
+            } else if (this.status == EntityBoat.Status.UNDER_WATER) {
                 d2 = 0.009999999776482582D;
                 this.momentum = 0.45F;
-            }
-            else if (this.status == EntityBoat.Status.IN_AIR)
-            {
+            } else if (this.status == EntityBoat.Status.IN_AIR) {
                 this.momentum = 0.9F;
-            }
-            else if (this.status == EntityBoat.Status.ON_LAND)
-            {
+            } else if (this.status == EntityBoat.Status.ON_LAND) {
                 this.momentum = this.boatGlide;
 
-                if (this.getControllingPassenger() instanceof EntityPlayer)
-                {
+                if (this.getControllingPassenger() instanceof EntityPlayer) {
                     this.boatGlide /= 2.0F;
                 }
             }
 
-            this.motionX *= (double)this.momentum;
-            this.motionZ *= (double)this.momentum;
+            this.motionX *= (double) this.momentum;
+            this.motionZ *= (double) this.momentum;
             this.deltaRotation *= this.momentum;
             this.motionY += d1;
 
-            if (d2 > 0.0D)
-            {
+            if (d2 > 0.0D) {
                 double d3 = 0.65D;
                 this.motionY += d2 * 0.06153846016296973D;
                 double d4 = 0.75D;
@@ -704,88 +632,72 @@
         }
     }
 
-    private void controlBoat()
-    {
-        if (this.isBeingRidden())
-        {
+    private void controlBoat() {
+        if (this.isBeingRidden()) {
             float f = 0.0F;
 
-            if (this.leftInputDown)
-            {
+            if (this.leftInputDown) {
                 this.deltaRotation += -1.0F;
             }
 
-            if (this.rightInputDown)
-            {
+            if (this.rightInputDown) {
                 ++this.deltaRotation;
             }
 
-            if (this.rightInputDown != this.leftInputDown && !this.forwardInputDown && !this.backInputDown)
-            {
+            if (this.rightInputDown != this.leftInputDown && !this.forwardInputDown && !this.backInputDown) {
                 f += 0.005F;
             }
 
             this.rotationYaw += this.deltaRotation;
 
-            if (this.forwardInputDown)
-            {
+            if (this.forwardInputDown) {
                 f += 0.04F;
             }
 
-            if (this.backInputDown)
-            {
+            if (this.backInputDown) {
                 f -= 0.005F;
             }
 
-            this.motionX += (double)(MathHelper.sin(-this.rotationYaw * 0.017453292F) * f);
-            this.motionZ += (double)(MathHelper.cos(this.rotationYaw * 0.017453292F) * f);
+            this.motionX += (double) (MathHelper.sin(-this.rotationYaw * 0.017453292F) * f);
+            this.motionZ += (double) (MathHelper.cos(this.rotationYaw * 0.017453292F) * f);
             this.setPaddleState(this.rightInputDown && !this.leftInputDown || this.forwardInputDown, this.leftInputDown && !this.rightInputDown || this.forwardInputDown);
         }
     }
 
-    public void updatePassenger(Entity passenger)
-    {
-        if (this.isPassenger(passenger))
-        {
+    public void updatePassenger(Entity passenger) {
+        if (this.isPassenger(passenger)) {
             float f = 0.0F;
-            float f1 = (float)((this.isDead ? 0.009999999776482582D : this.getMountedYOffset()) + passenger.getYOffset());
+            float f1 = (float) ((this.isDead ? 0.009999999776482582D : this.getMountedYOffset()) + passenger.getYOffset());
 
-            if (this.getPassengers().size() > 1)
-            {
+            if (this.getPassengers().size() > 1) {
                 int i = this.getPassengers().indexOf(passenger);
 
-                if (i == 0)
-                {
+                if (i == 0) {
                     f = 0.2F;
-                }
-                else
-                {
+                } else {
                     f = -0.6F;
                 }
 
-                if (passenger instanceof EntityAnimal)
-                {
-                    f = (float)((double)f + 0.2D);
+                if (passenger instanceof EntityAnimal) {
+                    f = (float) ((double) f + 0.2D);
                 }
             }
 
-            Vec3d vec3d = (new Vec3d((double)f, 0.0D, 0.0D)).rotateYaw(-this.rotationYaw * 0.017453292F - ((float)Math.PI / 2F));
-            passenger.setPosition(this.posX + vec3d.x, this.posY + (double)f1, this.posZ + vec3d.z);
+            Vec3d vec3d = (new Vec3d((double) f, 0.0D, 0.0D)).rotateYaw(-this.rotationYaw * 0.017453292F - ((float) Math.PI / 2F));
+            passenger.setPosition(this.posX + vec3d.x, this.posY + (double) f1, this.posZ + vec3d.z);
             passenger.rotationYaw += this.deltaRotation;
             passenger.setRotationYawHead(passenger.getRotationYawHead() + this.deltaRotation);
             this.applyYawToEntity(passenger);
 
-            if (passenger instanceof EntityAnimal && this.getPassengers().size() > 1)
-            {
+            if (passenger instanceof EntityAnimal && this.getPassengers().size() > 1) {
                 int j = passenger.getEntityId() % 2 == 0 ? 90 : 270;
-                passenger.setRenderYawOffset(((EntityAnimal)passenger).renderYawOffset + (float)j);
-                passenger.setRotationYawHead(passenger.getRotationYawHead() + (float)j);
+                passenger.setRenderYawOffset(((EntityAnimal) passenger).renderYawOffset + (float) j);
+                passenger.setRotationYawHead(passenger.getRotationYawHead() + (float) j);
             }
         }
     }
 
-    protected void applyYawToEntity(Entity entityToUpdate)
-    {
+    protected void applyYawToEntity(Entity entityToUpdate) {
         entityToUpdate.setRenderYawOffset(this.rotationYaw);
         float f = MathHelper.wrapDegrees(entityToUpdate.rotationYaw - this.rotationYaw);
         float f1 = MathHelper.clamp(f, -105.0F, 105.0F);
@@ -795,34 +707,25 @@
     }
 
     @SideOnly(Side.CLIENT)
-    public void applyOrientationToEntity(Entity entityToUpdate)
-    {
+    public void applyOrientationToEntity(Entity entityToUpdate) {
         this.applyYawToEntity(entityToUpdate);
     }
 
-    protected void writeEntityToNBT(NBTTagCompound compound)
-    {
+    protected void writeEntityToNBT(NBTTagCompound compound) {
         compound.setString("Type", this.getBoatType().getName());
     }
 
-    protected void readEntityFromNBT(NBTTagCompound compound)
-    {
-        if (compound.hasKey("Type", 8))
-        {
+    protected void readEntityFromNBT(NBTTagCompound compound) {
+        if (compound.hasKey("Type", 8)) {
             this.setBoatType(EntityBoat.Type.getTypeFromString(compound.getString("Type")));
         }
     }
 
-    public boolean processInitialInteract(EntityPlayer player, EnumHand hand)
-    {
-        if (player.isSneaking())
-        {
+    public boolean processInitialInteract(EntityPlayer player, EnumHand hand) {
+        if (player.isSneaking()) {
             return false;
-        }
-        else
-        {
-            if (!this.world.isRemote && this.outOfControlTicks < 60.0F)
-            {
+        } else {
+            if (!this.world.isRemote && this.outOfControlTicks < 60.0F) {
                 player.startRiding(this);
             }
 
@@ -830,120 +733,100 @@
         }
     }
 
-    protected void updateFallState(double y, boolean onGroundIn, IBlockState state, BlockPos pos)
-    {
+    protected void updateFallState(double y, boolean onGroundIn, IBlockState state, BlockPos pos) {
         this.lastYd = this.motionY;
 
-        if (!this.isRiding())
-        {
-            if (onGroundIn)
-            {
-                if (this.fallDistance > 3.0F)
-                {
-                    if (this.status != EntityBoat.Status.ON_LAND)
-                    {
+        if (!this.isRiding()) {
+            if (onGroundIn) {
+                if (this.fallDistance > 3.0F) {
+                    if (this.status != EntityBoat.Status.ON_LAND) {
                         this.fallDistance = 0.0F;
                         return;
                     }
 
                     this.fall(this.fallDistance, 1.0F);
 
-                    if (!this.world.isRemote && !this.isDead)
-                    {
-                        this.setDead();
+                    if (!this.world.isRemote && !this.isDead) {
+                        Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+                        VehicleDestroyEvent destroyEvent = new VehicleDestroyEvent(vehicle, null);
+                        this.world.getServer().getPluginManager().callEvent(destroyEvent);
+                        if (!destroyEvent.isCancelled()) {
+                            this.setDead();
+                            if (this.world.getGameRules().getBoolean("doEntityDrops")) {
+                                for (int i = 0; i < 3; ++i) {
+                                    this.entityDropItem(new ItemStack(Item.getItemFromBlock(Blocks.PLANKS), 1, this.getBoatType().getMetadata()), 0.0F);
+                                }
 
-                        if (this.world.getGameRules().getBoolean("doEntityDrops"))
-                        {
-                            for (int i = 0; i < 3; ++i)
-                            {
-                                this.entityDropItem(new ItemStack(Item.getItemFromBlock(Blocks.PLANKS), 1, this.getBoatType().getMetadata()), 0.0F);
+                                for (int j = 0; j < 2; ++j) {
+                                    this.dropItemWithOffset(Items.STICK, 1, 0.0F);
+                                }
                             }
-
-                            for (int j = 0; j < 2; ++j)
-                            {
-                                this.dropItemWithOffset(Items.STICK, 1, 0.0F);
-                            }
                         }
                     }
                 }
 
                 this.fallDistance = 0.0F;
+            } else if (this.world.getBlockState((new BlockPos(this)).down()).getMaterial() != Material.WATER && y < 0.0D) {
+                this.fallDistance = (float) ((double) this.fallDistance - y);
             }
-            else if (this.world.getBlockState((new BlockPos(this)).down()).getMaterial() != Material.WATER && y < 0.0D)
-            {
-                this.fallDistance = (float)((double)this.fallDistance - y);
-            }
         }
     }
 
-    public boolean getPaddleState(int side)
-    {
-        return ((Boolean)this.dataManager.get(DATA_ID_PADDLE[side])).booleanValue() && this.getControllingPassenger() != null;
+    public boolean getPaddleState(int side) {
+        return ((Boolean) this.dataManager.get(DATA_ID_PADDLE[side])).booleanValue() && this.getControllingPassenger() != null;
     }
 
-    public void setDamageTaken(float damageTaken)
-    {
+    public void setDamageTaken(float damageTaken) {
         this.dataManager.set(DAMAGE_TAKEN, Float.valueOf(damageTaken));
     }
 
-    public float getDamageTaken()
-    {
-        return ((Float)this.dataManager.get(DAMAGE_TAKEN)).floatValue();
+    public float getDamageTaken() {
+        return ((Float) this.dataManager.get(DAMAGE_TAKEN)).floatValue();
     }
 
-    public void setTimeSinceHit(int timeSinceHit)
-    {
+    public void setTimeSinceHit(int timeSinceHit) {
         this.dataManager.set(TIME_SINCE_HIT, Integer.valueOf(timeSinceHit));
     }
 
-    public int getTimeSinceHit()
-    {
-        return ((Integer)this.dataManager.get(TIME_SINCE_HIT)).intValue();
+    public int getTimeSinceHit() {
+        return ((Integer) this.dataManager.get(TIME_SINCE_HIT)).intValue();
     }
 
-    public void setForwardDirection(int forwardDirection)
-    {
+    public void setForwardDirection(int forwardDirection) {
         this.dataManager.set(FORWARD_DIRECTION, Integer.valueOf(forwardDirection));
     }
 
-    public int getForwardDirection()
-    {
-        return ((Integer)this.dataManager.get(FORWARD_DIRECTION)).intValue();
+    public int getForwardDirection() {
+        return ((Integer) this.dataManager.get(FORWARD_DIRECTION)).intValue();
     }
 
-    public void setBoatType(EntityBoat.Type boatType)
-    {
+    public void setBoatType(EntityBoat.Type boatType) {
         this.dataManager.set(BOAT_TYPE, Integer.valueOf(boatType.ordinal()));
     }
 
-    public EntityBoat.Type getBoatType()
-    {
-        return EntityBoat.Type.byId(((Integer)this.dataManager.get(BOAT_TYPE)).intValue());
+    public EntityBoat.Type getBoatType() {
+        return EntityBoat.Type.byId(((Integer) this.dataManager.get(BOAT_TYPE)).intValue());
     }
 
-    protected boolean canFitPassenger(Entity passenger)
-    {
+    protected boolean canFitPassenger(Entity passenger) {
         return this.getPassengers().size() < 2;
     }
 
     @Nullable
-    public Entity getControllingPassenger()
-    {
+    public Entity getControllingPassenger() {
         List<Entity> list = this.getPassengers();
-        return list.isEmpty() ? null : (Entity)list.get(0);
+        return list.isEmpty() ? null : (Entity) list.get(0);
     }
 
     @SideOnly(Side.CLIENT)
-    public void updateInputs(boolean p_184442_1_, boolean p_184442_2_, boolean p_184442_3_, boolean p_184442_4_)
-    {
+    public void updateInputs(boolean p_184442_1_, boolean p_184442_2_, boolean p_184442_3_, boolean p_184442_4_) {
         this.leftInputDown = p_184442_1_;
         this.rightInputDown = p_184442_2_;
         this.forwardInputDown = p_184442_3_;
         this.backInputDown = p_184442_4_;
     }
 
-    public static enum Status
-    {
+    public static enum Status {
         IN_WATER,
         UNDER_WATER,
         UNDER_FLOWING_WATER,
@@ -951,8 +834,7 @@
         IN_AIR;
     }
 
-    public static enum Type
-    {
+    public static enum Type {
         OAK(BlockPlanks.EnumType.OAK.getMetadata(), "oak"),
         SPRUCE(BlockPlanks.EnumType.SPRUCE.getMetadata(), "spruce"),
         BIRCH(BlockPlanks.EnumType.BIRCH.getMetadata(), "birch"),
@@ -963,43 +845,34 @@
         private final String name;
         private final int metadata;
 
-        private Type(int metadataIn, String nameIn)
-        {
+        private Type(int metadataIn, String nameIn) {
             this.name = nameIn;
             this.metadata = metadataIn;
         }
 
-        public String getName()
-        {
+        public String getName() {
             return this.name;
         }
 
-        public int getMetadata()
-        {
+        public int getMetadata() {
             return this.metadata;
         }
 
-        public String toString()
-        {
+        public String toString() {
             return this.name;
         }
 
-        public static EntityBoat.Type byId(int id)
-        {
-            if (id < 0 || id >= values().length)
-            {
+        public static EntityBoat.Type byId(int id) {
+            if (id < 0 || id >= values().length) {
                 id = 0;
             }
 
             return values()[id];
         }
 
-        public static EntityBoat.Type getTypeFromString(String nameIn)
-        {
-            for (int i = 0; i < values().length; ++i)
-            {
-                if (values()[i].getName().equals(nameIn))
-                {
+        public static EntityBoat.Type getTypeFromString(String nameIn) {
+            for (int i = 0; i < values().length; ++i) {
+                if (values()[i].getName().equals(nameIn)) {
                     return values()[i];
                 }
             }
@@ -1010,17 +883,15 @@
 
     // Forge: Fix MC-119811 by instantly completing lerp on board
     @Override
-    protected void addPassenger(Entity passenger)
-    {
+    protected void addPassenger(Entity passenger) {
         super.addPassenger(passenger);
-        if(this.canPassengerSteer() && this.lerpSteps > 0)
-        {
+        if (this.canPassengerSteer() && this.lerpSteps > 0) {
             this.lerpSteps = 0;
             this.posX = this.lerpX;
             this.posY = this.lerpY;
             this.posZ = this.lerpZ;
-            this.rotationYaw = (float)this.lerpYaw;
-            this.rotationPitch = (float)this.lerpPitch;
+            this.rotationYaw = (float) this.lerpYaw;
+            this.rotationPitch = (float) this.lerpPitch;
         }
     }
 }
