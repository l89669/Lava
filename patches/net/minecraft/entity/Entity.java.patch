--- ../src-base/minecraft/net/minecraft/entity/Entity.java
+++ ../src-work/minecraft/net/minecraft/entity/Entity.java
@@ -3,21 +3,8 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Random;
-import java.util.Set;
-import java.util.UUID;
-import javax.annotation.Nullable;
 import net.minecraft.advancements.CriteriaTriggers;
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockFence;
-import net.minecraft.block.BlockFenceGate;
-import net.minecraft.block.BlockLiquid;
-import net.minecraft.block.BlockWall;
-import net.minecraft.block.SoundType;
+import net.minecraft.block.*;
 import net.minecraft.block.material.EnumPushReaction;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
@@ -32,6 +19,7 @@
 import net.minecraft.entity.effect.EntityLightningBolt;
 import net.minecraft.entity.item.EntityBoat;
 import net.minecraft.entity.item.EntityItem;
+import net.minecraft.entity.passive.EntityTameable;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.init.Blocks;
@@ -39,54 +27,73 @@
 import net.minecraft.inventory.EntityEquipmentSlot;
 import net.minecraft.item.Item;
 import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.nbt.NBTTagDouble;
-import net.minecraft.nbt.NBTTagFloat;
-import net.minecraft.nbt.NBTTagList;
-import net.minecraft.nbt.NBTTagString;
+import net.minecraft.nbt.*;
 import net.minecraft.network.datasync.DataParameter;
 import net.minecraft.network.datasync.DataSerializers;
 import net.minecraft.network.datasync.EntityDataManager;
 import net.minecraft.scoreboard.ScorePlayerTeam;
 import net.minecraft.scoreboard.Team;
 import net.minecraft.server.MinecraftServer;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.EnumActionResult;
-import net.minecraft.util.EnumBlockRenderType;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.EnumHand;
-import net.minecraft.util.EnumParticleTypes;
-import net.minecraft.util.Mirror;
-import net.minecraft.util.ReportedException;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.Rotation;
-import net.minecraft.util.SoundCategory;
-import net.minecraft.util.SoundEvent;
+import net.minecraft.util.*;
 import net.minecraft.util.datafix.DataFixer;
 import net.minecraft.util.datafix.FixTypes;
 import net.minecraft.util.datafix.IDataFixer;
 import net.minecraft.util.datafix.IDataWalker;
-import net.minecraft.util.math.AxisAlignedBB;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.RayTraceResult;
-import net.minecraft.util.math.Vec2f;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.math.*;
 import net.minecraft.util.text.ITextComponent;
 import net.minecraft.util.text.TextComponentString;
 import net.minecraft.util.text.event.HoverEvent;
 import net.minecraft.util.text.translation.I18n;
 import net.minecraft.world.Explosion;
-import net.minecraft.world.Teleporter;
 import net.minecraft.world.World;
 import net.minecraft.world.WorldServer;
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Server;
+import org.bukkit.TravelAgent;
+import org.bukkit.block.BlockFace;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.entity.Hanging;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.Vehicle;
+import org.bukkit.event.entity.EntityAirChangeEvent;
+import org.bukkit.event.entity.EntityCombustByEntityEvent;
+import org.bukkit.event.entity.EntityCombustEvent;
+import org.bukkit.event.entity.EntityPortalEvent;
+import org.bukkit.event.hanging.HangingBreakByEntityEvent;
+import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
+import org.bukkit.event.vehicle.VehicleEnterEvent;
+import org.bukkit.event.vehicle.VehicleExitEvent;
+import org.bukkit.plugin.PluginManager;
 
-public abstract class Entity implements ICommandSender, net.minecraftforge.common.capabilities.ICapabilitySerializable<NBTTagCompound>
-{
+import javax.annotation.Nullable;
+import java.util.*;
+
+public abstract class Entity implements ICommandSender, net.minecraftforge.common.capabilities.ICapabilitySerializable<NBTTagCompound> {
+    // CraftBukkit start
+    private static final int CURRENT_LEVEL = 2;
+
+    static boolean isLevelAtLeast(NBTTagCompound tag, int level) {
+        return tag.hasKey("Bukkit.updateLevel") && tag.getInteger("Bukkit.updateLevel") >= level;
+    }
+
+    protected CraftEntity bukkitEntity;
+
+    public CraftEntity getBukkitEntity() {
+        if (bukkitEntity == null) {
+            bukkitEntity = CraftEntity.getEntity(world.getServer(), this);
+        }
+        return bukkitEntity;
+    }
+
+    // CraftBukikt end
     private static final Logger LOGGER = LogManager.getLogger();
     private static final List<ItemStack> EMPTY_EQUIPMENT = Collections.<ItemStack>emptyList();
     private static final AxisAlignedBB ZERO_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
@@ -94,7 +101,7 @@
     private static int nextEntityID;
     private int entityId;
     public boolean preventEntitySpawning;
-    private final List<Entity> riddenByEntities;
+    public final List<Entity> riddenByEntities;  // Spigot
     protected int rideCooldown;
     private Entity ridingEntity;
     public boolean forceSpawn;
@@ -137,8 +144,8 @@
     public float entityCollisionReduction;
     protected Random rand;
     public int ticksExisted;
-    private int fire;
-    protected boolean inWater;
+    public int fire;
+    public boolean inWater;
     public int hurtResistantTime;
     protected boolean firstUpdate;
     protected boolean isImmuneToFire;
@@ -172,7 +179,7 @@
     protected UUID entityUniqueID;
     protected String cachedUniqueIdString;
     private final CommandResultStats cmdResultStats;
-    protected boolean glowing;
+    public boolean glowing;
     private final Set<String> tags;
     private boolean isPositionDirty;
     private final double[] pistonDeltas;
@@ -182,8 +189,17 @@
      */
     public boolean updateBlocked;
 
-    public Entity(World worldIn)
-    {
+    // CraftBukkit start
+    public boolean valid;
+    public org.bukkit.projectiles.ProjectileSource projectileSource; // For projectiles only
+    public boolean forceExplosionKnockback; // SPIGOT-949
+
+    public float getBukkitYaw() {
+        return this.rotationYaw;
+    }
+    // CraftBukkit end
+
+    public Entity(World worldIn) {
         this.entityId = nextEntityID++;
         this.riddenByEntities = Lists.<Entity>newArrayList();
         this.boundingBox = ZERO_AABB;
@@ -198,106 +214,90 @@
         this.cachedUniqueIdString = this.entityUniqueID.toString();
         this.cmdResultStats = new CommandResultStats();
         this.tags = Sets.<String>newHashSet();
-        this.pistonDeltas = new double[] {0.0D, 0.0D, 0.0D};
+        this.pistonDeltas = new double[]{0.0D, 0.0D, 0.0D};
         this.world = worldIn;
         this.setPosition(0.0D, 0.0D, 0.0D);
 
-        if (worldIn != null)
-        {
+        if (worldIn != null) {
             this.dimension = worldIn.provider.getDimension();
         }
 
         this.dataManager = new EntityDataManager(this);
-        this.dataManager.register(FLAGS, Byte.valueOf((byte)0));
+        this.dataManager.register(FLAGS, Byte.valueOf((byte) 0));
         this.dataManager.register(AIR, Integer.valueOf(300));
         this.dataManager.register(CUSTOM_NAME_VISIBLE, Boolean.valueOf(false));
         this.dataManager.register(CUSTOM_NAME, "");
         this.dataManager.register(SILENT, Boolean.valueOf(false));
         this.dataManager.register(NO_GRAVITY, Boolean.valueOf(false));
         this.entityInit();
-        net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityEvent.EntityConstructing(this));
-        capabilities = net.minecraftforge.event.ForgeEventFactory.gatherCapabilities(this);
+        if (!(this instanceof EntityPlayer)) { // Lava - move to EntityPlayer
+            net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityEvent.EntityConstructing(this));
+            capabilities = net.minecraftforge.event.ForgeEventFactory.gatherCapabilities(this);
+        }
     }
 
-    /** Forge: Used to store custom data for each entity. */
+    /**
+     * Forge: Used to store custom data for each entity.
+     */
     private NBTTagCompound customEntityData;
     public boolean captureDrops = false;
     public java.util.ArrayList<EntityItem> capturedDrops = new java.util.ArrayList<EntityItem>();
-    private net.minecraftforge.common.capabilities.CapabilityDispatcher capabilities;
+    public net.minecraftforge.common.capabilities.CapabilityDispatcher capabilities; // Lava - private -> public
 
-    public int getEntityId()
-    {
+    public int getEntityId() {
         return this.entityId;
     }
 
-    public void setEntityId(int id)
-    {
+    public void setEntityId(int id) {
         this.entityId = id;
     }
 
-    public Set<String> getTags()
-    {
+    public Set<String> getTags() {
         return this.tags;
     }
 
-    public boolean addTag(String tag)
-    {
-        if (this.tags.size() >= 1024)
-        {
+    public boolean addTag(String tag) {
+        if (this.tags.size() >= 1024) {
             return false;
-        }
-        else
-        {
+        } else {
             this.tags.add(tag);
             return true;
         }
     }
 
-    public boolean removeTag(String tag)
-    {
+    public boolean removeTag(String tag) {
         return this.tags.remove(tag);
     }
 
-    public void onKillCommand()
-    {
+    public void onKillCommand() {
         this.setDead();
     }
 
     protected abstract void entityInit();
 
-    public EntityDataManager getDataManager()
-    {
+    public EntityDataManager getDataManager() {
         return this.dataManager;
     }
 
-    public boolean equals(Object p_equals_1_)
-    {
-        if (p_equals_1_ instanceof Entity)
-        {
-            return ((Entity)p_equals_1_).entityId == this.entityId;
-        }
-        else
-        {
+    public boolean equals(Object p_equals_1_) {
+        if (p_equals_1_ instanceof Entity) {
+            return ((Entity) p_equals_1_).entityId == this.entityId;
+        } else {
             return false;
         }
     }
 
-    public int hashCode()
-    {
+    public int hashCode() {
         return this.entityId;
     }
 
     @SideOnly(Side.CLIENT)
-    protected void preparePlayerToSpawn()
-    {
-        if (this.world != null)
-        {
-            while (this.posY > 0.0D && this.posY < 256.0D)
-            {
+    protected void preparePlayerToSpawn() {
+        if (this.world != null) {
+            while (this.posY > 0.0D && this.posY < 256.0D) {
                 this.setPosition(this.posX, this.posY, this.posZ);
 
-                if (this.world.getCollisionBoxes(this, this.getEntityBoundingBox()).isEmpty())
-                {
+                if (this.world.getCollisionBoxes(this, this.getEntityBoundingBox()).isEmpty()) {
                     break;
                 }
 
@@ -311,95 +311,151 @@
         }
     }
 
-    public void setDead()
-    {
+    public void setDead() {
         this.isDead = true;
     }
 
-    public void setDropItemsWhenDead(boolean dropWhenDead)
-    {
+    public void setDropItemsWhenDead(boolean dropWhenDead) {
     }
 
-    protected void setSize(float width, float height)
-    {
-        if (width != this.width || height != this.height)
-        {
+    protected void setSize(float width, float height) {
+        if (width != this.width || height != this.height) {
             float f = this.width;
             this.width = width;
             this.height = height;
 
-            if (this.width < f)
-            {
-                double d0 = (double)width / 2.0D;
-                this.setEntityBoundingBox(new AxisAlignedBB(this.posX - d0, this.posY, this.posZ - d0, this.posX + d0, this.posY + (double)this.height, this.posZ + d0));
+            if (this.width < f) {
+                double d0 = (double) width / 2.0D;
+                this.setEntityBoundingBox(new AxisAlignedBB(this.posX - d0, this.posY, this.posZ - d0, this.posX + d0, this.posY + (double) this.height, this.posZ + d0));
                 return;
             }
 
             AxisAlignedBB axisalignedbb = this.getEntityBoundingBox();
-            this.setEntityBoundingBox(new AxisAlignedBB(axisalignedbb.minX, axisalignedbb.minY, axisalignedbb.minZ, axisalignedbb.minX + (double)this.width, axisalignedbb.minY + (double)this.height, axisalignedbb.minZ + (double)this.width));
+            this.setEntityBoundingBox(new AxisAlignedBB(axisalignedbb.minX, axisalignedbb.minY, axisalignedbb.minZ, axisalignedbb.minX + (double) this.width, axisalignedbb.minY + (double) this.height, axisalignedbb.minZ + (double) this.width));
 
-            if (this.width > f && !this.firstUpdate && !this.world.isRemote)
-            {
-                this.move(MoverType.SELF, (double)(f - this.width), 0.0D, (double)(f - this.width));
+            if (this.width > f && !this.firstUpdate && !this.world.isRemote) {
+                this.move(MoverType.SELF, (double) (f - this.width), 0.0D, (double) (f - this.width));
             }
         }
     }
 
-    protected void setRotation(float yaw, float pitch)
-    {
+    public void setRotation(float yaw, float pitch) {
+        // CraftBukkit start - yaw was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(yaw)) {
+            yaw = 0;
+        }
+
+        if (yaw == Float.POSITIVE_INFINITY || yaw == Float.NEGATIVE_INFINITY) {
+            if (this instanceof EntityPlayer) {
+                this.world.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid yaw");
+                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Nope");
+            }
+            yaw = 0;
+        }
+
+        // pitch was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(pitch)) {
+            pitch = 0;
+        }
+
+        if (pitch == Float.POSITIVE_INFINITY || pitch == Float.NEGATIVE_INFINITY) {
+            if (this instanceof EntityPlayer) {
+                this.world.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid pitch");
+                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Nope");
+            }
+            pitch = 0;
+        }
+        // CraftBukkit end
+
         this.rotationYaw = yaw % 360.0F;
         this.rotationPitch = pitch % 360.0F;
     }
 
-    public void setPosition(double x, double y, double z)
-    {
+    public void setPosition(double x, double y, double z) {
         this.posX = x;
         this.posY = y;
         this.posZ = z;
-        if (this.isAddedToWorld() && !this.world.isRemote) this.world.updateEntityWithOptionalForce(this, false); // Forge - Process chunk registration after moving.
+        if (this.isAddedToWorld() && !this.world.isRemote)
+            this.world.updateEntityWithOptionalForce(this, false); // Forge - Process chunk registration after moving.
         float f = this.width / 2.0F;
         float f1 = this.height;
-        this.setEntityBoundingBox(new AxisAlignedBB(x - (double)f, y, z - (double)f, x + (double)f, y + (double)f1, z + (double)f));
+        this.setEntityBoundingBox(new AxisAlignedBB(x - (double) f, y, z - (double) f, x + (double) f, y + (double) f1, z + (double) f));
     }
 
     @SideOnly(Side.CLIENT)
-    public void turn(float yaw, float pitch)
-    {
+    public void turn(float yaw, float pitch) {
         float f = this.rotationPitch;
         float f1 = this.rotationYaw;
-        this.rotationYaw = (float)((double)this.rotationYaw + (double)yaw * 0.15D);
-        this.rotationPitch = (float)((double)this.rotationPitch - (double)pitch * 0.15D);
+        this.rotationYaw = (float) ((double) this.rotationYaw + (double) yaw * 0.15D);
+        this.rotationPitch = (float) ((double) this.rotationPitch - (double) pitch * 0.15D);
         this.rotationPitch = MathHelper.clamp(this.rotationPitch, -90.0F, 90.0F);
         this.prevRotationPitch += this.rotationPitch - f;
         this.prevRotationYaw += this.rotationYaw - f1;
 
-        if (this.ridingEntity != null)
-        {
+        if (this.ridingEntity != null) {
             this.ridingEntity.applyOrientationToEntity(this);
         }
     }
 
-    public void onUpdate()
-    {
-        if (!this.world.isRemote)
-        {
+    public void onUpdate() {
+        if (!this.world.isRemote) {
             this.setFlag(6, this.isGlowing());
         }
 
         this.onEntityUpdate();
     }
 
-    public void onEntityUpdate()
-    {
+    public void postTick() {
+        // No clean way to break out of ticking once the entity has been copied to a new world, so instead we move the portalling later in the tick cycle
+        if (!this.world.isRemote && this.world instanceof WorldServer) {
+            this.world.profiler.startSection("portal");
+            if (this.inPortal) {
+                MinecraftServer minecraftserver = this.world.getMinecraftServer();
+
+                if (true || minecraftserver.getAllowNether()) { // CraftBukkit
+                    if (!this.isRiding()) {
+                        int i = this.getMaxInPortalTime();
+
+                        if (this.portalCounter++ >= i) {
+                            this.portalCounter = i;
+                            this.timeUntilPortal = this.getPortalCooldown();
+                            byte b0;
+
+                            if (this.world.provider.getDimensionType().getId() == -1) {
+                                b0 = 0;
+                            } else {
+                                b0 = -1;
+                            }
+
+                            this.changeDimension(b0);
+                        }
+                    }
+
+                    this.inPortal = false;
+                }
+            } else {
+                if (this.portalCounter > 0) {
+                    this.portalCounter -= 4;
+                }
+
+                if (this.portalCounter < 0) {
+                    this.portalCounter = 0;
+                }
+            }
+
+            this.decrementTimeUntilPortal();
+            this.world.profiler.endSection();
+        }
+    }
+
+    public void onEntityUpdate() {
         this.world.profiler.startSection("entityBaseTick");
 
-        if (this.isRiding() && this.getRidingEntity().isDead)
-        {
+        if (this.isRiding() && this.getRidingEntity().isDead) {
             this.dismountRidingEntity();
         }
 
-        if (this.rideCooldown > 0)
-        {
+        if (this.rideCooldown > 0) {
             --this.rideCooldown;
         }
 
@@ -409,7 +465,8 @@
         this.prevPosZ = this.posZ;
         this.prevRotationPitch = this.rotationPitch;
         this.prevRotationYaw = this.rotationYaw;
-
+        // Moved up to postTick
+        /*
         if (!this.world.isRemote && this.world instanceof WorldServer)
         {
             this.world.profiler.startSection("portal");
@@ -462,29 +519,21 @@
             this.decrementTimeUntilPortal();
             this.world.profiler.endSection();
         }
-
+        */
         this.spawnRunningParticles();
         this.handleWaterMovement();
 
-        if (this.world.isRemote)
-        {
+        if (this.world.isRemote) {
             this.extinguish();
-        }
-        else if (this.fire > 0)
-        {
-            if (this.isImmuneToFire)
-            {
+        } else if (this.fire > 0) {
+            if (this.isImmuneToFire) {
                 this.fire -= 4;
 
-                if (this.fire < 0)
-                {
+                if (this.fire < 0) {
                     this.extinguish();
                 }
-            }
-            else
-            {
-                if (this.fire % 20 == 0)
-                {
+            } else {
+                if (this.fire % 20 == 0) {
                     this.attackEntityFrom(DamageSource.ON_FIRE, 1.0F);
                 }
 
@@ -492,19 +541,16 @@
             }
         }
 
-        if (this.isInLava())
-        {
+        if (this.isInLava()) {
             this.setOnFireFromLava();
             this.fallDistance *= 0.5F;
         }
 
-        if (this.posY < -64.0D)
-        {
+        if (this.posY < -64.0D) {
             this.outOfWorld();
         }
 
-        if (!this.world.isRemote)
-        {
+        if (!this.world.isRemote) {
             this.setFlag(0, this.fire > 0);
         }
 
@@ -512,111 +558,121 @@
         this.world.profiler.endSection();
     }
 
-    protected void decrementTimeUntilPortal()
-    {
-        if (this.timeUntilPortal > 0)
-        {
+    protected void decrementTimeUntilPortal() {
+        if (this.timeUntilPortal > 0) {
             --this.timeUntilPortal;
         }
     }
 
-    public int getMaxInPortalTime()
-    {
+    public int getMaxInPortalTime() {
         return 1;
     }
 
-    protected void setOnFireFromLava()
-    {
-        if (!this.isImmuneToFire)
-        {
+    protected void setOnFireFromLava() {
+        if (!this.isImmuneToFire) {
             this.attackEntityFrom(DamageSource.LAVA, 4.0F);
+            // CraftBukkit start - Fallen in lava TODO: this event spams!
+            if (this instanceof EntityLiving) {
+                if (fire <= 0) {
+                    // not on fire yet
+                    // TODO: shouldn't be sending null for the block
+                    org.bukkit.block.Block damager = null; // ((WorldServer) this.l).getWorld().getBlockAt(i, j, k);
+                    org.bukkit.entity.Entity damagee = this.getBukkitEntity();
+                    EntityCombustEvent combustEvent = new org.bukkit.event.entity.EntityCombustByBlockEvent(damager, damagee, 15);
+                    this.world.getServer().getPluginManager().callEvent(combustEvent);
+
+                    if (!combustEvent.isCancelled()) {
+                        this.setFire(combustEvent.getDuration());
+                    }
+                } else {
+                    // This will be called every single tick the entity is in lava, so don't throw an event
+                    this.setFire(15);
+                }
+                return;
+            }
+            // CraftBukkit end - we also don't throw an event unless the object in lava is living, to save on some event calls
             this.setFire(15);
         }
     }
 
-    public void setFire(int seconds)
-    {
+    public void setFire(int seconds) {
         int i = seconds * 20;
 
-        if (this instanceof EntityLivingBase)
-        {
-            i = EnchantmentProtection.getFireTimeForEntity((EntityLivingBase)this, i);
+        if (this instanceof EntityLivingBase) {
+            i = EnchantmentProtection.getFireTimeForEntity((EntityLivingBase) this, i);
         }
 
-        if (this.fire < i)
-        {
+        if (this.fire < i) {
             this.fire = i;
         }
     }
 
-    public void extinguish()
-    {
+    public void extinguish() {
         this.fire = 0;
     }
 
-    protected void outOfWorld()
-    {
+    protected void outOfWorld() {
         this.setDead();
     }
 
-    public boolean isOffsetPositionInLiquid(double x, double y, double z)
-    {
+    public boolean isOffsetPositionInLiquid(double x, double y, double z) {
         AxisAlignedBB axisalignedbb = this.getEntityBoundingBox().offset(x, y, z);
         return this.isLiquidPresentInAABB(axisalignedbb);
     }
 
-    private boolean isLiquidPresentInAABB(AxisAlignedBB bb)
-    {
+    private boolean isLiquidPresentInAABB(AxisAlignedBB bb) {
         return this.world.getCollisionBoxes(this, bb).isEmpty() && !this.world.containsAnyLiquid(bb);
     }
 
-    public void move(MoverType type, double x, double y, double z)
-    {
-        if (this.noClip)
-        {
+    public void move(MoverType type, double x, double y, double z) {
+        if (this.noClip) {
             this.setEntityBoundingBox(this.getEntityBoundingBox().offset(x, y, z));
             this.resetPositionToBB();
-        }
-        else
-        {
-            if (type == MoverType.PISTON)
-            {
+        } else {
+            // CraftBukkit start - Don't do anything if we aren't moving
+            // We need to do this regardless of whether or not we are moving thanks to portals
+            try {
+                this.doBlockCollisions();
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Checking entity block collision");
+                CrashReportCategory crashreportsystemdetails = crashreport.makeCategory("Entity being checked for collision");
+
+                this.addEntityCrashInfo(crashreportsystemdetails);
+                throw new ReportedException(crashreport);
+            }
+            // Check if we're moving
+            if (x == 0 && y == 0 && z == 0 && this.isBeingRidden() && this.isRiding()) {
+                return;
+            }
+            // CraftBukkit end
+            if (type == MoverType.PISTON) {
                 long i = this.world.getTotalWorldTime();
 
-                if (i != this.pistonDeltasGameTime)
-                {
+                if (i != this.pistonDeltasGameTime) {
                     Arrays.fill(this.pistonDeltas, 0.0D);
                     this.pistonDeltasGameTime = i;
                 }
 
-                if (x != 0.0D)
-                {
+                if (x != 0.0D) {
                     int j = EnumFacing.Axis.X.ordinal();
                     double d0 = MathHelper.clamp(x + this.pistonDeltas[j], -0.51D, 0.51D);
                     x = d0 - this.pistonDeltas[j];
                     this.pistonDeltas[j] = d0;
 
-                    if (Math.abs(x) <= 9.999999747378752E-6D)
-                    {
+                    if (Math.abs(x) <= 9.999999747378752E-6D) {
                         return;
                     }
-                }
-                else if (y != 0.0D)
-                {
+                } else if (y != 0.0D) {
                     int l4 = EnumFacing.Axis.Y.ordinal();
                     double d12 = MathHelper.clamp(y + this.pistonDeltas[l4], -0.51D, 0.51D);
                     y = d12 - this.pistonDeltas[l4];
                     this.pistonDeltas[l4] = d12;
 
-                    if (Math.abs(y) <= 9.999999747378752E-6D)
-                    {
+                    if (Math.abs(y) <= 9.999999747378752E-6D) {
                         return;
                     }
-                }
-                else
-                {
-                    if (z == 0.0D)
-                    {
+                } else {
+                    if (z == 0.0D) {
                         return;
                     }
 
@@ -625,8 +681,7 @@
                     z = d13 - this.pistonDeltas[i5];
                     this.pistonDeltas[i5] = d13;
 
-                    if (Math.abs(z) <= 9.999999747378752E-6D)
-                    {
+                    if (Math.abs(z) <= 9.999999747378752E-6D) {
                         return;
                     }
                 }
@@ -637,8 +692,7 @@
             double d11 = this.posY;
             double d1 = this.posZ;
 
-            if (this.isInWeb)
-            {
+            if (this.isInWeb) {
                 this.isInWeb = false;
                 x *= 0.25D;
                 y *= 0.05000000074505806D;
@@ -652,67 +706,43 @@
             double d3 = y;
             double d4 = z;
 
-            if ((type == MoverType.SELF || type == MoverType.PLAYER) && this.onGround && this.isSneaking() && this instanceof EntityPlayer)
-            {
-                for (double d5 = 0.05D; x != 0.0D && this.world.getCollisionBoxes(this, this.getEntityBoundingBox().offset(x, (double)(-this.stepHeight), 0.0D)).isEmpty(); d2 = x)
-                {
-                    if (x < 0.05D && x >= -0.05D)
-                    {
+            if ((type == MoverType.SELF || type == MoverType.PLAYER) && this.onGround && this.isSneaking() && this instanceof EntityPlayer) {
+                for (double d5 = 0.05D; x != 0.0D && this.world.getCollisionBoxes(this, this.getEntityBoundingBox().offset(x, (double) (-this.stepHeight), 0.0D)).isEmpty(); d2 = x) {
+                    if (x < 0.05D && x >= -0.05D) {
                         x = 0.0D;
-                    }
-                    else if (x > 0.0D)
-                    {
+                    } else if (x > 0.0D) {
                         x -= 0.05D;
-                    }
-                    else
-                    {
+                    } else {
                         x += 0.05D;
                     }
                 }
 
-                for (; z != 0.0D && this.world.getCollisionBoxes(this, this.getEntityBoundingBox().offset(0.0D, (double)(-this.stepHeight), z)).isEmpty(); d4 = z)
-                {
-                    if (z < 0.05D && z >= -0.05D)
-                    {
+                for (; z != 0.0D && this.world.getCollisionBoxes(this, this.getEntityBoundingBox().offset(0.0D, (double) (-this.stepHeight), z)).isEmpty(); d4 = z) {
+                    if (z < 0.05D && z >= -0.05D) {
                         z = 0.0D;
-                    }
-                    else if (z > 0.0D)
-                    {
+                    } else if (z > 0.0D) {
                         z -= 0.05D;
-                    }
-                    else
-                    {
+                    } else {
                         z += 0.05D;
                     }
                 }
 
-                for (; x != 0.0D && z != 0.0D && this.world.getCollisionBoxes(this, this.getEntityBoundingBox().offset(x, (double)(-this.stepHeight), z)).isEmpty(); d4 = z)
-                {
-                    if (x < 0.05D && x >= -0.05D)
-                    {
+                for (; x != 0.0D && z != 0.0D && this.world.getCollisionBoxes(this, this.getEntityBoundingBox().offset(x, (double) (-this.stepHeight), z)).isEmpty(); d4 = z) {
+                    if (x < 0.05D && x >= -0.05D) {
                         x = 0.0D;
-                    }
-                    else if (x > 0.0D)
-                    {
+                    } else if (x > 0.0D) {
                         x -= 0.05D;
-                    }
-                    else
-                    {
+                    } else {
                         x += 0.05D;
                     }
 
                     d2 = x;
 
-                    if (z < 0.05D && z >= -0.05D)
-                    {
+                    if (z < 0.05D && z >= -0.05D) {
                         z = 0.0D;
-                    }
-                    else if (z > 0.0D)
-                    {
+                    } else if (z > 0.0D) {
                         z -= 0.05D;
-                    }
-                    else
-                    {
+                    } else {
                         z += 0.05D;
                     }
                 }
@@ -721,85 +751,73 @@
             List<AxisAlignedBB> list1 = this.world.getCollisionBoxes(this, this.getEntityBoundingBox().expand(x, y, z));
             AxisAlignedBB axisalignedbb = this.getEntityBoundingBox();
 
-            if (y != 0.0D)
-            {
+            if (y != 0.0D) {
                 int k = 0;
 
-                for (int l = list1.size(); k < l; ++k)
-                {
-                    y = ((AxisAlignedBB)list1.get(k)).calculateYOffset(this.getEntityBoundingBox(), y);
+                for (int l = list1.size(); k < l; ++k) {
+                    y = ((AxisAlignedBB) list1.get(k)).calculateYOffset(this.getEntityBoundingBox(), y);
                 }
 
                 this.setEntityBoundingBox(this.getEntityBoundingBox().offset(0.0D, y, 0.0D));
             }
 
-            if (x != 0.0D)
-            {
+            if (x != 0.0D) {
                 int j5 = 0;
 
-                for (int l5 = list1.size(); j5 < l5; ++j5)
-                {
-                    x = ((AxisAlignedBB)list1.get(j5)).calculateXOffset(this.getEntityBoundingBox(), x);
+                for (int l5 = list1.size(); j5 < l5; ++j5) {
+                    x = ((AxisAlignedBB) list1.get(j5)).calculateXOffset(this.getEntityBoundingBox(), x);
                 }
 
-                if (x != 0.0D)
-                {
+                if (x != 0.0D) {
                     this.setEntityBoundingBox(this.getEntityBoundingBox().offset(x, 0.0D, 0.0D));
                 }
             }
 
-            if (z != 0.0D)
-            {
+            if (z != 0.0D) {
                 int k5 = 0;
 
-                for (int i6 = list1.size(); k5 < i6; ++k5)
-                {
-                    z = ((AxisAlignedBB)list1.get(k5)).calculateZOffset(this.getEntityBoundingBox(), z);
+                for (int i6 = list1.size(); k5 < i6; ++k5) {
+                    z = ((AxisAlignedBB) list1.get(k5)).calculateZOffset(this.getEntityBoundingBox(), z);
                 }
 
-                if (z != 0.0D)
-                {
+                if (z != 0.0D) {
                     this.setEntityBoundingBox(this.getEntityBoundingBox().offset(0.0D, 0.0D, z));
                 }
             }
 
             boolean flag = this.onGround || d3 != y && d3 < 0.0D;
 
-            if (this.stepHeight > 0.0F && flag && (d2 != x || d4 != z))
-            {
+            if (this.stepHeight > 0.0F && flag && (d2 != x || d4 != z)) {
                 double d14 = x;
                 double d6 = y;
                 double d7 = z;
                 AxisAlignedBB axisalignedbb1 = this.getEntityBoundingBox();
                 this.setEntityBoundingBox(axisalignedbb);
-                y = (double)this.stepHeight;
+                y = (double) this.stepHeight;
                 List<AxisAlignedBB> list = this.world.getCollisionBoxes(this, this.getEntityBoundingBox().expand(d2, y, d4));
                 AxisAlignedBB axisalignedbb2 = this.getEntityBoundingBox();
                 AxisAlignedBB axisalignedbb3 = axisalignedbb2.expand(d2, 0.0D, d4);
                 double d8 = y;
                 int j1 = 0;
 
-                for (int k1 = list.size(); j1 < k1; ++j1)
-                {
-                    d8 = ((AxisAlignedBB)list.get(j1)).calculateYOffset(axisalignedbb3, d8);
+                for (int k1 = list.size(); j1 < k1; ++j1) {
+                    d8 = ((AxisAlignedBB) list.get(j1)).calculateYOffset(axisalignedbb3, d8);
                 }
 
                 axisalignedbb2 = axisalignedbb2.offset(0.0D, d8, 0.0D);
                 double d18 = d2;
                 int l1 = 0;
 
-                for (int i2 = list.size(); l1 < i2; ++l1)
-                {
-                    d18 = ((AxisAlignedBB)list.get(l1)).calculateXOffset(axisalignedbb2, d18);
+                for (int i2 = list.size(); l1 < i2; ++l1) {
+                    d18 = ((AxisAlignedBB) list.get(l1)).calculateXOffset(axisalignedbb2, d18);
                 }
 
                 axisalignedbb2 = axisalignedbb2.offset(d18, 0.0D, 0.0D);
                 double d19 = d4;
                 int j2 = 0;
 
-                for (int k2 = list.size(); j2 < k2; ++j2)
-                {
-                    d19 = ((AxisAlignedBB)list.get(j2)).calculateZOffset(axisalignedbb2, d19);
+                for (int k2 = list.size(); j2 < k2; ++j2) {
+                    d19 = ((AxisAlignedBB) list.get(j2)).calculateZOffset(axisalignedbb2, d19);
                 }
 
                 axisalignedbb2 = axisalignedbb2.offset(0.0D, 0.0D, d19);
@@ -807,42 +825,36 @@
                 double d20 = y;
                 int l2 = 0;
 
-                for (int i3 = list.size(); l2 < i3; ++l2)
-                {
-                    d20 = ((AxisAlignedBB)list.get(l2)).calculateYOffset(axisalignedbb4, d20);
+                for (int i3 = list.size(); l2 < i3; ++l2) {
+                    d20 = ((AxisAlignedBB) list.get(l2)).calculateYOffset(axisalignedbb4, d20);
                 }
 
                 axisalignedbb4 = axisalignedbb4.offset(0.0D, d20, 0.0D);
                 double d21 = d2;
                 int j3 = 0;
 
-                for (int k3 = list.size(); j3 < k3; ++j3)
-                {
-                    d21 = ((AxisAlignedBB)list.get(j3)).calculateXOffset(axisalignedbb4, d21);
+                for (int k3 = list.size(); j3 < k3; ++j3) {
+                    d21 = ((AxisAlignedBB) list.get(j3)).calculateXOffset(axisalignedbb4, d21);
                 }
 
                 axisalignedbb4 = axisalignedbb4.offset(d21, 0.0D, 0.0D);
                 double d22 = d4;
                 int l3 = 0;
 
-                for (int i4 = list.size(); l3 < i4; ++l3)
-                {
-                    d22 = ((AxisAlignedBB)list.get(l3)).calculateZOffset(axisalignedbb4, d22);
+                for (int i4 = list.size(); l3 < i4; ++l3) {
+                    d22 = ((AxisAlignedBB) list.get(l3)).calculateZOffset(axisalignedbb4, d22);
                 }
 
                 axisalignedbb4 = axisalignedbb4.offset(0.0D, 0.0D, d22);
                 double d23 = d18 * d18 + d19 * d19;
                 double d9 = d21 * d21 + d22 * d22;
 
-                if (d23 > d9)
-                {
+                if (d23 > d9) {
                     x = d18;
                     z = d19;
                     y = -d8;
                     this.setEntityBoundingBox(axisalignedbb2);
-                }
-                else
-                {
+                } else {
                     x = d21;
                     z = d22;
                     y = -d20;
@@ -851,15 +863,13 @@
 
                 int j4 = 0;
 
-                for (int k4 = list.size(); j4 < k4; ++j4)
-                {
-                    y = ((AxisAlignedBB)list.get(j4)).calculateYOffset(this.getEntityBoundingBox(), y);
+                for (int k4 = list.size(); j4 < k4; ++j4) {
+                    y = ((AxisAlignedBB) list.get(j4)).calculateYOffset(this.getEntityBoundingBox(), y);
                 }
 
                 this.setEntityBoundingBox(this.getEntityBoundingBox().offset(0.0D, y, 0.0D));
 
-                if (d14 * d14 + d7 * d7 >= x * x + z * z)
-                {
+                if (d14 * d14 + d7 * d7 >= x * x + z * z) {
                     x = d14;
                     y = d6;
                     z = d7;
@@ -880,14 +890,12 @@
             BlockPos blockpos = new BlockPos(j6, i1, k6);
             IBlockState iblockstate = this.world.getBlockState(blockpos);
 
-            if (iblockstate.getMaterial() == Material.AIR)
-            {
+            if (iblockstate.getMaterial() == Material.AIR) {
                 BlockPos blockpos1 = blockpos.down();
                 IBlockState iblockstate1 = this.world.getBlockState(blockpos1);
                 Block block1 = iblockstate1.getBlock();
 
-                if (block1 instanceof BlockFence || block1 instanceof BlockWall || block1 instanceof BlockFenceGate)
-                {
+                if (block1 instanceof BlockFence || block1 instanceof BlockWall || block1 instanceof BlockFenceGate) {
                     iblockstate = iblockstate1;
                     blockpos = blockpos1;
                 }
@@ -895,70 +903,78 @@
 
             this.updateFallState(y, this.onGround, iblockstate, blockpos);
 
-            if (d2 != x)
-            {
+            if (d2 != x) {
                 this.motionX = 0.0D;
             }
 
-            if (d4 != z)
-            {
+            if (d4 != z) {
                 this.motionZ = 0.0D;
             }
 
             Block block = iblockstate.getBlock();
 
-            if (d3 != y)
-            {
+            if (d3 != y) {
                 block.onLanded(this.world, this);
             }
 
-            if (this.canTriggerWalking() && (!this.onGround || !this.isSneaking() || !(this instanceof EntityPlayer)) && !this.isRiding())
-            {
+            if (collidedHorizontally && getBukkitEntity() instanceof Vehicle) {
+                Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+                org.bukkit.block.Block bl = this.world.getWorld().getBlockAt(MathHelper.floor(this.posX), MathHelper.floor(this.posY), MathHelper.floor(this.posZ));
+
+                if (d2 > x) {
+                    bl = bl.getRelative(BlockFace.EAST);
+                } else if (d2 < x) {
+                    bl = bl.getRelative(BlockFace.WEST);
+                } else if (d4 > z) {
+                    bl = bl.getRelative(BlockFace.SOUTH);
+                } else if (d4 < z) {
+                    bl = bl.getRelative(BlockFace.NORTH);
+                }
+
+                if (bl.getType() != org.bukkit.Material.AIR) {
+                    VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl);
+                    world.getServer().getPluginManager().callEvent(event);
+                }
+            }
+
+            if (this.canTriggerWalking() && (!this.onGround || !this.isSneaking() || !(this instanceof EntityPlayer)) && !this.isRiding()) {
                 double d15 = this.posX - d10;
                 double d16 = this.posY - d11;
                 double d17 = this.posZ - d1;
 
-                if (block != Blocks.LADDER)
-                {
+                if (block != Blocks.LADDER) {
                     d16 = 0.0D;
                 }
 
-                if (block != null && this.onGround)
-                {
+                if (block != null && this.onGround) {
                     block.onEntityWalk(this.world, blockpos, this);
                 }
 
-                this.distanceWalkedModified = (float)((double)this.distanceWalkedModified + (double)MathHelper.sqrt(d15 * d15 + d17 * d17) * 0.6D);
-                this.distanceWalkedOnStepModified = (float)((double)this.distanceWalkedOnStepModified + (double)MathHelper.sqrt(d15 * d15 + d16 * d16 + d17 * d17) * 0.6D);
+                this.distanceWalkedModified = (float) ((double) this.distanceWalkedModified + (double) MathHelper.sqrt(d15 * d15 + d17 * d17) * 0.6D);
+                this.distanceWalkedOnStepModified = (float) ((double) this.distanceWalkedOnStepModified + (double) MathHelper.sqrt(d15 * d15 + d16 * d16 + d17 * d17) * 0.6D);
 
-                if (this.distanceWalkedOnStepModified > (float)this.nextStepDistance && iblockstate.getMaterial() != Material.AIR)
-                {
-                    this.nextStepDistance = (int)this.distanceWalkedOnStepModified + 1;
+                if (this.distanceWalkedOnStepModified > (float) this.nextStepDistance && iblockstate.getMaterial() != Material.AIR) {
+                    this.nextStepDistance = (int) this.distanceWalkedOnStepModified + 1;
 
-                    if (this.isInWater())
-                    {
+                    if (this.isInWater()) {
                         Entity entity = this.isBeingRidden() && this.getControllingPassenger() != null ? this.getControllingPassenger() : this;
                         float f = entity == this ? 0.35F : 0.4F;
                         float f1 = MathHelper.sqrt(entity.motionX * entity.motionX * 0.20000000298023224D + entity.motionY * entity.motionY + entity.motionZ * entity.motionZ * 0.20000000298023224D) * f;
 
-                        if (f1 > 1.0F)
-                        {
+                        if (f1 > 1.0F) {
                             f1 = 1.0F;
                         }
 
                         this.playSound(this.getSwimSound(), f1, 1.0F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);
-                    }
-                    else
-                    {
+                    } else {
                         this.playStepSound(blockpos, block);
                     }
-                }
-                else if (this.distanceWalkedOnStepModified > this.nextFlap && this.makeFlySound() && iblockstate.getMaterial() == Material.AIR)
-                {
+                } else if (this.distanceWalkedOnStepModified > this.nextFlap && this.makeFlySound() && iblockstate.getMaterial() == Material.AIR) {
                     this.nextFlap = this.playFlySound(this.distanceWalkedOnStepModified);
                 }
             }
-
+            // Move to the top of the method
+            /*
             try
             {
                 this.doBlockCollisions();
@@ -970,30 +986,31 @@
                 this.addEntityCrashInfo(crashreportcategory);
                 throw new ReportedException(crashreport);
             }
+            */
 
             boolean flag1 = this.isWet();
 
-            if (this.world.isFlammableWithin(this.getEntityBoundingBox().shrink(0.001D)))
-            {
+            if (this.world.isFlammableWithin(this.getEntityBoundingBox().shrink(0.001D))) {
                 this.dealFireDamage(1);
 
-                if (!flag1)
-                {
+                if (!flag1) {
                     ++this.fire;
 
-                    if (this.fire == 0)
-                    {
-                        this.setFire(8);
+                    if (this.fire == 0) {
+//                        this.setFire(8);
+                        EntityCombustEvent event = new org.bukkit.event.entity.EntityCombustByBlockEvent(null, getBukkitEntity(), 8);
+                        world.getServer().getPluginManager().callEvent(event);
+
+                        if (!event.isCancelled()) {
+                            this.setFire(event.getDuration());
+                        }
                     }
                 }
-            }
-            else if (this.fire <= 0)
-            {
+            } else if (this.fire <= 0) {
                 this.fire = -this.getFireImmuneTicks();
             }
 
-            if (flag1 && this.isBurning())
-            {
+            if (flag1 && this.isBurning()) {
                 this.playSound(SoundEvents.ENTITY_GENERIC_EXTINGUISH_FIRE, 0.7F, 1.6F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);
                 this.fire = -this.getFireImmuneTicks();
             }
@@ -1002,50 +1019,40 @@
         }
     }
 
-    public void resetPositionToBB()
-    {
+    public void resetPositionToBB() {
         AxisAlignedBB axisalignedbb = this.getEntityBoundingBox();
         this.posX = (axisalignedbb.minX + axisalignedbb.maxX) / 2.0D;
         this.posY = axisalignedbb.minY;
         this.posZ = (axisalignedbb.minZ + axisalignedbb.maxZ) / 2.0D;
-        if (this.isAddedToWorld() && !this.world.isRemote) this.world.updateEntityWithOptionalForce(this, false); // Forge - Process chunk registration after moving.
+        if (this.isAddedToWorld && !this.world.isRemote)
+            this.world.updateEntityWithOptionalForce(this, false); // Forge - Process chunk registration after moving.
     }
 
-    protected SoundEvent getSwimSound()
-    {
+    protected SoundEvent getSwimSound() {
         return SoundEvents.ENTITY_GENERIC_SWIM;
     }
 
-    protected SoundEvent getSplashSound()
-    {
+    protected SoundEvent getSplashSound() {
         return SoundEvents.ENTITY_GENERIC_SPLASH;
     }
 
-    protected void doBlockCollisions()
-    {
+    protected void doBlockCollisions() {
         AxisAlignedBB axisalignedbb = this.getEntityBoundingBox();
         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain(axisalignedbb.minX + 0.001D, axisalignedbb.minY + 0.001D, axisalignedbb.minZ + 0.001D);
         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos1 = BlockPos.PooledMutableBlockPos.retain(axisalignedbb.maxX - 0.001D, axisalignedbb.maxY - 0.001D, axisalignedbb.maxZ - 0.001D);
         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos2 = BlockPos.PooledMutableBlockPos.retain();
 
-        if (this.world.isAreaLoaded(blockpos$pooledmutableblockpos, blockpos$pooledmutableblockpos1))
-        {
-            for (int i = blockpos$pooledmutableblockpos.getX(); i <= blockpos$pooledmutableblockpos1.getX(); ++i)
-            {
-                for (int j = blockpos$pooledmutableblockpos.getY(); j <= blockpos$pooledmutableblockpos1.getY(); ++j)
-                {
-                    for (int k = blockpos$pooledmutableblockpos.getZ(); k <= blockpos$pooledmutableblockpos1.getZ(); ++k)
-                    {
+        if (this.world.isAreaLoaded(blockpos$pooledmutableblockpos, blockpos$pooledmutableblockpos1)) {
+            for (int i = blockpos$pooledmutableblockpos.getX(); i <= blockpos$pooledmutableblockpos1.getX(); ++i) {
+                for (int j = blockpos$pooledmutableblockpos.getY(); j <= blockpos$pooledmutableblockpos1.getY(); ++j) {
+                    for (int k = blockpos$pooledmutableblockpos.getZ(); k <= blockpos$pooledmutableblockpos1.getZ(); ++k) {
                         blockpos$pooledmutableblockpos2.setPos(i, j, k);
                         IBlockState iblockstate = this.world.getBlockState(blockpos$pooledmutableblockpos2);
 
-                        try
-                        {
+                        try {
                             iblockstate.getBlock().onEntityCollidedWithBlock(this.world, blockpos$pooledmutableblockpos2, iblockstate, this);
                             this.onInsideBlock(iblockstate);
-                        }
-                        catch (Throwable throwable)
-                        {
+                        } catch (Throwable throwable) {
                             CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Colliding entity with block");
                             CrashReportCategory crashreportcategory = crashreport.makeCategory("Block being collided with");
                             CrashReportCategory.addBlockInfo(crashreportcategory, blockpos$pooledmutableblockpos2, iblockstate);
@@ -1061,266 +1068,211 @@
         blockpos$pooledmutableblockpos2.release();
     }
 
-    protected void onInsideBlock(IBlockState p_191955_1_)
-    {
+    protected void onInsideBlock(IBlockState p_191955_1_) {
     }
 
-    protected void playStepSound(BlockPos pos, Block blockIn)
-    {
+    protected void playStepSound(BlockPos pos, Block blockIn) {
         SoundType soundtype = blockIn.getSoundType(world.getBlockState(pos), world, pos, this);
 
-        if (this.world.getBlockState(pos.up()).getBlock() == Blocks.SNOW_LAYER)
-        {
+        if (this.world.getBlockState(pos.up()).getBlock() == Blocks.SNOW_LAYER) {
             soundtype = Blocks.SNOW_LAYER.getSoundType();
             this.playSound(soundtype.getStepSound(), soundtype.getVolume() * 0.15F, soundtype.getPitch());
-        }
-        else if (!blockIn.getDefaultState().getMaterial().isLiquid())
-        {
+        } else if (!blockIn.getDefaultState().getMaterial().isLiquid()) {
             this.playSound(soundtype.getStepSound(), soundtype.getVolume() * 0.15F, soundtype.getPitch());
         }
     }
 
-    protected float playFlySound(float p_191954_1_)
-    {
+    protected float playFlySound(float p_191954_1_) {
         return 0.0F;
     }
 
-    protected boolean makeFlySound()
-    {
+    protected boolean makeFlySound() {
         return false;
     }
 
-    public void playSound(SoundEvent soundIn, float volume, float pitch)
-    {
-        if (!this.isSilent())
-        {
-            this.world.playSound((EntityPlayer)null, this.posX, this.posY, this.posZ, soundIn, this.getSoundCategory(), volume, pitch);
+    public void playSound(SoundEvent soundIn, float volume, float pitch) {
+        if (!this.isSilent()) {
+            this.world.playSound((EntityPlayer) null, this.posX, this.posY, this.posZ, soundIn, this.getSoundCategory(), volume, pitch);
         }
     }
 
-    public boolean isSilent()
-    {
-        return ((Boolean)this.dataManager.get(SILENT)).booleanValue();
+    public boolean isSilent() {
+        return ((Boolean) this.dataManager.get(SILENT)).booleanValue();
     }
 
-    public void setSilent(boolean isSilent)
-    {
+    public void setSilent(boolean isSilent) {
         this.dataManager.set(SILENT, Boolean.valueOf(isSilent));
     }
 
-    public boolean hasNoGravity()
-    {
-        return ((Boolean)this.dataManager.get(NO_GRAVITY)).booleanValue();
+    public boolean hasNoGravity() {
+        return ((Boolean) this.dataManager.get(NO_GRAVITY)).booleanValue();
     }
 
-    public void setNoGravity(boolean noGravity)
-    {
+    public void setNoGravity(boolean noGravity) {
         this.dataManager.set(NO_GRAVITY, Boolean.valueOf(noGravity));
     }
 
-    protected boolean canTriggerWalking()
-    {
+    protected boolean canTriggerWalking() {
         return true;
     }
 
-    protected void updateFallState(double y, boolean onGroundIn, IBlockState state, BlockPos pos)
-    {
-        if (onGroundIn)
-        {
-            if (this.fallDistance > 0.0F)
-            {
+    protected void updateFallState(double y, boolean onGroundIn, IBlockState state, BlockPos pos) {
+        if (onGroundIn) {
+            if (this.fallDistance > 0.0F) {
                 state.getBlock().onFallenUpon(this.world, pos, this, this.fallDistance);
             }
 
             this.fallDistance = 0.0F;
+        } else if (y < 0.0D) {
+            this.fallDistance = (float) ((double) this.fallDistance - y);
         }
-        else if (y < 0.0D)
-        {
-            this.fallDistance = (float)((double)this.fallDistance - y);
-        }
     }
 
     @Nullable
-    public AxisAlignedBB getCollisionBoundingBox()
-    {
+    public AxisAlignedBB getCollisionBoundingBox() {
         return null;
     }
 
-    protected void dealFireDamage(int amount)
-    {
-        if (!this.isImmuneToFire)
-        {
-            this.attackEntityFrom(DamageSource.IN_FIRE, (float)amount);
+    protected void dealFireDamage(int amount) {
+        if (!this.isImmuneToFire) {
+            this.attackEntityFrom(DamageSource.IN_FIRE, (float) amount);
         }
     }
 
-    public final boolean isImmuneToFire()
-    {
+    protected void dealFireDamage(float amount) {
+        if (!this.isImmuneToFire) {
+            this.attackEntityFrom(DamageSource.IN_FIRE, (float) amount);
+        }
+    }
+
+    public final boolean isImmuneToFire() {
         return this.isImmuneToFire;
     }
 
-    public void fall(float distance, float damageMultiplier)
-    {
-        if (this.isBeingRidden())
-        {
-            for (Entity entity : this.getPassengers())
-            {
+    public void fall(float distance, float damageMultiplier) {
+        if (this.isBeingRidden()) {
+            for (Entity entity : this.getPassengers()) {
                 entity.fall(distance, damageMultiplier);
             }
         }
     }
 
-    public boolean isWet()
-    {
-        if (this.inWater)
-        {
+    public boolean isWet() {
+        if (this.inWater) {
             return true;
-        }
-        else
-        {
+        } else {
             BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain(this.posX, this.posY, this.posZ);
 
-            if (!this.world.isRainingAt(blockpos$pooledmutableblockpos) && !this.world.isRainingAt(blockpos$pooledmutableblockpos.setPos(this.posX, this.posY + (double)this.height, this.posZ)))
-            {
+            if (!this.world.isRainingAt(blockpos$pooledmutableblockpos) && !this.world.isRainingAt(blockpos$pooledmutableblockpos.setPos(this.posX, this.posY + (double) this.height, this.posZ))) {
                 blockpos$pooledmutableblockpos.release();
                 return false;
-            }
-            else
-            {
+            } else {
                 blockpos$pooledmutableblockpos.release();
                 return true;
             }
         }
     }
 
-    public boolean isInWater()
-    {
+    public boolean isInWater() {
         return this.inWater;
     }
 
-    public boolean isOverWater()
-    {
+    public boolean isOverWater() {
         return this.world.handleMaterialAcceleration(this.getEntityBoundingBox().grow(0.0D, -20.0D, 0.0D).shrink(0.001D), Material.WATER, this);
     }
 
-    public boolean handleWaterMovement()
-    {
-        if (this.getRidingEntity() instanceof EntityBoat)
-        {
+    public boolean handleWaterMovement() {
+        if (this.getRidingEntity() instanceof EntityBoat) {
             this.inWater = false;
-        }
-        else if (this.world.handleMaterialAcceleration(this.getEntityBoundingBox().grow(0.0D, -0.4000000059604645D, 0.0D).shrink(0.001D), Material.WATER, this))
-        {
-            if (!this.inWater && !this.firstUpdate)
-            {
+        } else if (this.world.handleMaterialAcceleration(this.getEntityBoundingBox().grow(0.0D, -0.4000000059604645D, 0.0D).shrink(0.001D), Material.WATER, this)) {
+            if (!this.inWater && !this.firstUpdate) {
                 this.doWaterSplashEffect();
             }
 
             this.fallDistance = 0.0F;
             this.inWater = true;
             this.extinguish();
-        }
-        else
-        {
+        } else {
             this.inWater = false;
         }
 
         return this.inWater;
     }
 
-    protected void doWaterSplashEffect()
-    {
+    protected void doWaterSplashEffect() {
         Entity entity = this.isBeingRidden() && this.getControllingPassenger() != null ? this.getControllingPassenger() : this;
         float f = entity == this ? 0.2F : 0.9F;
         float f1 = MathHelper.sqrt(entity.motionX * entity.motionX * 0.20000000298023224D + entity.motionY * entity.motionY + entity.motionZ * entity.motionZ * 0.20000000298023224D) * f;
 
-        if (f1 > 1.0F)
-        {
+        if (f1 > 1.0F) {
             f1 = 1.0F;
         }
 
         this.playSound(this.getSplashSound(), f1, 1.0F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);
-        float f2 = (float)MathHelper.floor(this.getEntityBoundingBox().minY);
+        float f2 = (float) MathHelper.floor(this.getEntityBoundingBox().minY);
 
-        for (int i = 0; (float)i < 1.0F + this.width * 20.0F; ++i)
-        {
+        for (int i = 0; (float) i < 1.0F + this.width * 20.0F; ++i) {
             float f3 = (this.rand.nextFloat() * 2.0F - 1.0F) * this.width;
             float f4 = (this.rand.nextFloat() * 2.0F - 1.0F) * this.width;
-            this.world.spawnParticle(EnumParticleTypes.WATER_BUBBLE, this.posX + (double)f3, (double)(f2 + 1.0F), this.posZ + (double)f4, this.motionX, this.motionY - (double)(this.rand.nextFloat() * 0.2F), this.motionZ);
+            this.world.spawnParticle(EnumParticleTypes.WATER_BUBBLE, this.posX + (double) f3, (double) (f2 + 1.0F), this.posZ + (double) f4, this.motionX, this.motionY - (double) (this.rand.nextFloat() * 0.2F), this.motionZ);
         }
 
-        for (int j = 0; (float)j < 1.0F + this.width * 20.0F; ++j)
-        {
+        for (int j = 0; (float) j < 1.0F + this.width * 20.0F; ++j) {
             float f5 = (this.rand.nextFloat() * 2.0F - 1.0F) * this.width;
             float f6 = (this.rand.nextFloat() * 2.0F - 1.0F) * this.width;
-            this.world.spawnParticle(EnumParticleTypes.WATER_SPLASH, this.posX + (double)f5, (double)(f2 + 1.0F), this.posZ + (double)f6, this.motionX, this.motionY, this.motionZ);
+            this.world.spawnParticle(EnumParticleTypes.WATER_SPLASH, this.posX + (double) f5, (double) (f2 + 1.0F), this.posZ + (double) f6, this.motionX, this.motionY, this.motionZ);
         }
     }
 
-    public void spawnRunningParticles()
-    {
-        if (this.isSprinting() && !this.isInWater())
-        {
+    public void spawnRunningParticles() {
+        if (this.isSprinting() && !this.isInWater()) {
             this.createRunningParticles();
         }
     }
 
-    protected void createRunningParticles()
-    {
+    protected void createRunningParticles() {
         int i = MathHelper.floor(this.posX);
         int j = MathHelper.floor(this.posY - 0.20000000298023224D);
         int k = MathHelper.floor(this.posZ);
         BlockPos blockpos = new BlockPos(i, j, k);
         IBlockState iblockstate = this.world.getBlockState(blockpos);
 
-        if(!iblockstate.getBlock().addRunningEffects(iblockstate, world, blockpos, this))
-        if (iblockstate.getRenderType() != EnumBlockRenderType.INVISIBLE)
-        {
-            this.world.spawnParticle(EnumParticleTypes.BLOCK_CRACK, this.posX + ((double)this.rand.nextFloat() - 0.5D) * (double)this.width, this.getEntityBoundingBox().minY + 0.1D, this.posZ + ((double)this.rand.nextFloat() - 0.5D) * (double)this.width, -this.motionX * 4.0D, 1.5D, -this.motionZ * 4.0D, Block.getStateId(iblockstate));
-        }
+        if (!iblockstate.getBlock().addRunningEffects(iblockstate, world, blockpos, this))
+            if (iblockstate.getRenderType() != EnumBlockRenderType.INVISIBLE) {
+                this.world.spawnParticle(EnumParticleTypes.BLOCK_CRACK, this.posX + ((double) this.rand.nextFloat() - 0.5D) * (double) this.width, this.getEntityBoundingBox().minY + 0.1D, this.posZ + ((double) this.rand.nextFloat() - 0.5D) * (double) this.width, -this.motionX * 4.0D, 1.5D, -this.motionZ * 4.0D, Block.getStateId(iblockstate));
+            }
     }
 
-    public boolean isInsideOfMaterial(Material materialIn)
-    {
-        if (this.getRidingEntity() instanceof EntityBoat)
-        {
+    public boolean isInsideOfMaterial(Material materialIn) {
+        if (this.getRidingEntity() instanceof EntityBoat) {
             return false;
-        }
-        else
-        {
-            double d0 = this.posY + (double)this.getEyeHeight();
+        } else {
+            double d0 = this.posY + (double) this.getEyeHeight();
             BlockPos blockpos = new BlockPos(this.posX, d0, this.posZ);
             IBlockState iblockstate = this.world.getBlockState(blockpos);
 
             Boolean result = iblockstate.getBlock().isEntityInsideMaterial(this.world, blockpos, iblockstate, this, d0, materialIn, true);
             if (result != null) return result;
 
-            if (iblockstate.getMaterial() == materialIn)
-            {
+            if (iblockstate.getMaterial() == materialIn) {
                 return net.minecraftforge.common.ForgeHooks.isInsideOfMaterial(materialIn, this, blockpos);
-            }
-            else
-            {
+            } else {
                 return false;
             }
         }
     }
 
-    public boolean isInLava()
-    {
+    public boolean isInLava() {
         return this.world.isMaterialInBB(this.getEntityBoundingBox().grow(-0.10000000149011612D, -0.4000000059604645D, -0.10000000149011612D), Material.LAVA);
     }
 
-    public void moveRelative(float strafe, float up, float forward, float friction)
-    {
+    public void moveRelative(float strafe, float up, float forward, float friction) {
         float f = strafe * strafe + up * up + forward * forward;
 
-        if (f >= 1.0E-4F)
-        {
+        if (f >= 1.0E-4F) {
             f = MathHelper.sqrt(f);
 
-            if (f < 1.0F)
-            {
+            if (f < 1.0F) {
                 f = 1.0F;
             }
 
@@ -1330,50 +1282,45 @@
             forward = forward * f;
             float f1 = MathHelper.sin(this.rotationYaw * 0.017453292F);
             float f2 = MathHelper.cos(this.rotationYaw * 0.017453292F);
-            this.motionX += (double)(strafe * f2 - forward * f1);
-            this.motionY += (double)up;
-            this.motionZ += (double)(forward * f2 + strafe * f1);
+            this.motionX += (double) (strafe * f2 - forward * f1);
+            this.motionY += (double) up;
+            this.motionZ += (double) (forward * f2 + strafe * f1);
         }
     }
 
     @SideOnly(Side.CLIENT)
-    public int getBrightnessForRender()
-    {
+    public int getBrightnessForRender() {
         BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos(MathHelper.floor(this.posX), 0, MathHelper.floor(this.posZ));
 
-        if (this.world.isBlockLoaded(blockpos$mutableblockpos))
-        {
-            blockpos$mutableblockpos.setY(MathHelper.floor(this.posY + (double)this.getEyeHeight()));
+        if (this.world.isBlockLoaded(blockpos$mutableblockpos)) {
+            blockpos$mutableblockpos.setY(MathHelper.floor(this.posY + (double) this.getEyeHeight()));
             return this.world.getCombinedLight(blockpos$mutableblockpos, 0);
-        }
-        else
-        {
+        } else {
             return 0;
         }
     }
 
-    public float getBrightness()
-    {
+    public float getBrightness() {
         BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos(MathHelper.floor(this.posX), 0, MathHelper.floor(this.posZ));
 
-        if (this.world.isBlockLoaded(blockpos$mutableblockpos))
-        {
-            blockpos$mutableblockpos.setY(MathHelper.floor(this.posY + (double)this.getEyeHeight()));
+        if (this.world.isBlockLoaded(blockpos$mutableblockpos)) {
+            blockpos$mutableblockpos.setY(MathHelper.floor(this.posY + (double) this.getEyeHeight()));
             return this.world.getLightBrightness(blockpos$mutableblockpos);
-        }
-        else
-        {
+        } else {
             return 0.0F;
         }
     }
 
-    public void setWorld(World worldIn)
-    {
+    public void setWorld(World worldIn) {
+        if (world == null) {
+            setDead();
+            this.world = ((CraftWorld) Bukkit.getServer().getWorlds().get(0)).getHandle();
+            return;
+        }
         this.world = worldIn;
     }
 
-    public void setPositionAndRotation(double x, double y, double z, float yaw, float pitch)
-    {
+    public void setPositionAndRotation(double x, double y, double z, float yaw, float pitch) {
         this.posX = MathHelper.clamp(x, -3.0E7D, 3.0E7D);
         this.posY = y;
         this.posZ = MathHelper.clamp(z, -3.0E7D, 3.0E7D);
@@ -1385,30 +1332,27 @@
         this.rotationPitch = pitch;
         this.prevRotationYaw = this.rotationYaw;
         this.prevRotationPitch = this.rotationPitch;
-        double d0 = (double)(this.prevRotationYaw - yaw);
+        double d0 = (double) (this.prevRotationYaw - yaw);
 
-        if (d0 < -180.0D)
-        {
+        if (d0 < -180.0D) {
             this.prevRotationYaw += 360.0F;
         }
 
-        if (d0 >= 180.0D)
-        {
+        if (d0 >= 180.0D) {
             this.prevRotationYaw -= 360.0F;
         }
 
-        if (!this.world.isRemote) this.world.getChunkFromChunkCoords((int) Math.floor(this.posX) >> 4, (int) Math.floor(this.posZ) >> 4); // Forge - ensure target chunk is loaded.
+        if (!this.world.isRemote)
+            this.world.getChunkFromChunkCoords((int) Math.floor(this.posX) >> 4, (int) Math.floor(this.posZ) >> 4); // Forge - ensure target chunk is loaded.
         this.setPosition(this.posX, this.posY, this.posZ);
         this.setRotation(yaw, pitch);
     }
 
-    public void moveToBlockPosAndAngles(BlockPos pos, float rotationYawIn, float rotationPitchIn)
-    {
-        this.setLocationAndAngles((double)pos.getX() + 0.5D, (double)pos.getY(), (double)pos.getZ() + 0.5D, rotationYawIn, rotationPitchIn);
+    public void moveToBlockPosAndAngles(BlockPos pos, float rotationYawIn, float rotationPitchIn) {
+        this.setLocationAndAngles((double) pos.getX() + 0.5D, (double) pos.getY(), (double) pos.getZ() + 0.5D, rotationYawIn, rotationPitchIn);
     }
 
-    public void setLocationAndAngles(double x, double y, double z, float yaw, float pitch)
-    {
+    public void setLocationAndAngles(double x, double y, double z, float yaw, float pitch) {
         this.posX = x;
         this.posY = y;
         this.posZ = z;
@@ -1423,71 +1367,59 @@
         this.setPosition(this.posX, this.posY, this.posZ);
     }
 
-    public float getDistance(Entity entityIn)
-    {
-        float f = (float)(this.posX - entityIn.posX);
-        float f1 = (float)(this.posY - entityIn.posY);
-        float f2 = (float)(this.posZ - entityIn.posZ);
+    public float getDistance(Entity entityIn) {
+        float f = (float) (this.posX - entityIn.posX);
+        float f1 = (float) (this.posY - entityIn.posY);
+        float f2 = (float) (this.posZ - entityIn.posZ);
         return MathHelper.sqrt(f * f + f1 * f1 + f2 * f2);
     }
 
-    public double getDistanceSq(double x, double y, double z)
-    {
+    public double getDistanceSq(double x, double y, double z) {
         double d0 = this.posX - x;
         double d1 = this.posY - y;
         double d2 = this.posZ - z;
         return d0 * d0 + d1 * d1 + d2 * d2;
     }
 
-    public double getDistanceSq(BlockPos pos)
-    {
+    public double getDistanceSq(BlockPos pos) {
         return pos.distanceSq(this.posX, this.posY, this.posZ);
     }
 
-    public double getDistanceSqToCenter(BlockPos pos)
-    {
+    public double getDistanceSqToCenter(BlockPos pos) {
         return pos.distanceSqToCenter(this.posX, this.posY, this.posZ);
     }
 
-    public double getDistance(double x, double y, double z)
-    {
+    public double getDistance(double x, double y, double z) {
         double d0 = this.posX - x;
         double d1 = this.posY - y;
         double d2 = this.posZ - z;
-        return (double)MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
+        return (double) MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
     }
 
-    public double getDistanceSq(Entity entityIn)
-    {
+    public double getDistanceSq(Entity entityIn) {
         double d0 = this.posX - entityIn.posX;
         double d1 = this.posY - entityIn.posY;
         double d2 = this.posZ - entityIn.posZ;
         return d0 * d0 + d1 * d1 + d2 * d2;
     }
 
-    public void onCollideWithPlayer(EntityPlayer entityIn)
-    {
+    public void onCollideWithPlayer(EntityPlayer entityIn) {
     }
 
-    public void applyEntityCollision(Entity entityIn)
-    {
-        if (!this.isRidingSameEntity(entityIn))
-        {
-            if (!entityIn.noClip && !this.noClip)
-            {
+    public void applyEntityCollision(Entity entityIn) {
+        if (!this.isRidingSameEntity(entityIn)) {
+            if (!entityIn.noClip && !this.noClip) {
                 double d0 = entityIn.posX - this.posX;
                 double d1 = entityIn.posZ - this.posZ;
                 double d2 = MathHelper.absMax(d0, d1);
 
-                if (d2 >= 0.009999999776482582D)
-                {
-                    d2 = (double)MathHelper.sqrt(d2);
+                if (d2 >= 0.009999999776482582D) {
+                    d2 = (double) MathHelper.sqrt(d2);
                     d0 = d0 / d2;
                     d1 = d1 / d2;
                     double d3 = 1.0D / d2;
 
-                    if (d3 > 1.0D)
-                    {
+                    if (d3 > 1.0D) {
                         d3 = 1.0D;
                     }
 
@@ -1495,16 +1427,14 @@
                     d1 = d1 * d3;
                     d0 = d0 * 0.05000000074505806D;
                     d1 = d1 * 0.05000000074505806D;
-                    d0 = d0 * (double)(1.0F - this.entityCollisionReduction);
-                    d1 = d1 * (double)(1.0F - this.entityCollisionReduction);
+                    d0 = d0 * (double) (1.0F - this.entityCollisionReduction);
+                    d1 = d1 * (double) (1.0F - this.entityCollisionReduction);
 
-                    if (!this.isBeingRidden())
-                    {
+                    if (!this.isBeingRidden()) {
                         this.addVelocity(-d0, 0.0D, -d1);
                     }
 
-                    if (!entityIn.isBeingRidden())
-                    {
+                    if (!entityIn.isBeingRidden()) {
                         entityIn.addVelocity(d0, 0.0D, d1);
                     }
                 }
@@ -1512,101 +1442,80 @@
         }
     }
 
-    public void addVelocity(double x, double y, double z)
-    {
+    public void addVelocity(double x, double y, double z) {
         this.motionX += x;
         this.motionY += y;
         this.motionZ += z;
         this.isAirBorne = true;
     }
 
-    protected void markVelocityChanged()
-    {
+    protected void markVelocityChanged() {
         this.velocityChanged = true;
     }
 
-    public boolean attackEntityFrom(DamageSource source, float amount)
-    {
-        if (this.isEntityInvulnerable(source))
-        {
+    public boolean attackEntityFrom(DamageSource source, float amount) {
+        if (this.isEntityInvulnerable(source)) {
             return false;
-        }
-        else
-        {
+        } else {
             this.markVelocityChanged();
             return false;
         }
     }
 
-    public Vec3d getLook(float partialTicks)
-    {
-        if (partialTicks == 1.0F)
-        {
+    public Vec3d getLook(float partialTicks) {
+        if (partialTicks == 1.0F) {
             return this.getVectorForRotation(this.rotationPitch, this.rotationYaw);
-        }
-        else
-        {
+        } else {
             float f = this.prevRotationPitch + (this.rotationPitch - this.prevRotationPitch) * partialTicks;
             float f1 = this.prevRotationYaw + (this.rotationYaw - this.prevRotationYaw) * partialTicks;
             return this.getVectorForRotation(f, f1);
         }
     }
 
-    protected final Vec3d getVectorForRotation(float pitch, float yaw)
-    {
-        float f = MathHelper.cos(-yaw * 0.017453292F - (float)Math.PI);
-        float f1 = MathHelper.sin(-yaw * 0.017453292F - (float)Math.PI);
+    protected final Vec3d getVectorForRotation(float pitch, float yaw) {
+        float f = MathHelper.cos(-yaw * 0.017453292F - (float) Math.PI);
+        float f1 = MathHelper.sin(-yaw * 0.017453292F - (float) Math.PI);
         float f2 = -MathHelper.cos(-pitch * 0.017453292F);
         float f3 = MathHelper.sin(-pitch * 0.017453292F);
-        return new Vec3d((double)(f1 * f2), (double)f3, (double)(f * f2));
+        return new Vec3d((double) (f1 * f2), (double) f3, (double) (f * f2));
     }
 
-    public Vec3d getPositionEyes(float partialTicks)
-    {
-        if (partialTicks == 1.0F)
-        {
-            return new Vec3d(this.posX, this.posY + (double)this.getEyeHeight(), this.posZ);
-        }
-        else
-        {
-            double d0 = this.prevPosX + (this.posX - this.prevPosX) * (double)partialTicks;
-            double d1 = this.prevPosY + (this.posY - this.prevPosY) * (double)partialTicks + (double)this.getEyeHeight();
-            double d2 = this.prevPosZ + (this.posZ - this.prevPosZ) * (double)partialTicks;
+    public Vec3d getPositionEyes(float partialTicks) {
+        if (partialTicks == 1.0F) {
+            return new Vec3d(this.posX, this.posY + (double) this.getEyeHeight(), this.posZ);
+        } else {
+            double d0 = this.prevPosX + (this.posX - this.prevPosX) * (double) partialTicks;
+            double d1 = this.prevPosY + (this.posY - this.prevPosY) * (double) partialTicks + (double) this.getEyeHeight();
+            double d2 = this.prevPosZ + (this.posZ - this.prevPosZ) * (double) partialTicks;
             return new Vec3d(d0, d1, d2);
         }
     }
 
     @Nullable
     @SideOnly(Side.CLIENT)
-    public RayTraceResult rayTrace(double blockReachDistance, float partialTicks)
-    {
+    public RayTraceResult rayTrace(double blockReachDistance, float partialTicks) {
         Vec3d vec3d = this.getPositionEyes(partialTicks);
         Vec3d vec3d1 = this.getLook(partialTicks);
         Vec3d vec3d2 = vec3d.addVector(vec3d1.x * blockReachDistance, vec3d1.y * blockReachDistance, vec3d1.z * blockReachDistance);
         return this.world.rayTraceBlocks(vec3d, vec3d2, false, false, true);
     }
 
-    public boolean canBeCollidedWith()
-    {
+    public boolean canBeCollidedWith() {
         return false;
     }
 
-    public boolean canBePushed()
-    {
+    public boolean canBePushed() {
         return false;
     }
 
-    public void awardKillScore(Entity p_191956_1_, int p_191956_2_, DamageSource p_191956_3_)
-    {
-        if (p_191956_1_ instanceof EntityPlayerMP)
-        {
-            CriteriaTriggers.ENTITY_KILLED_PLAYER.trigger((EntityPlayerMP)p_191956_1_, this, p_191956_3_);
+    public void awardKillScore(Entity p_191956_1_, int p_191956_2_, DamageSource p_191956_3_) {
+        if (p_191956_1_ instanceof EntityPlayerMP) {
+            CriteriaTriggers.ENTITY_KILLED_PLAYER.trigger((EntityPlayerMP) p_191956_1_, this, p_191956_3_);
         }
     }
 
     @SideOnly(Side.CLIENT)
-    public boolean isInRangeToRender3d(double x, double y, double z)
-    {
+    public boolean isInRangeToRender3d(double x, double y, double z) {
         double d0 = this.posX - x;
         double d1 = this.posY - y;
         double d2 = this.posZ - z;
@@ -1615,12 +1524,10 @@
     }
 
     @SideOnly(Side.CLIENT)
-    public boolean isInRangeToRenderDist(double distance)
-    {
+    public boolean isInRangeToRenderDist(double distance) {
         double d0 = this.getEntityBoundingBox().getAverageEdgeLength();
 
-        if (Double.isNaN(d0))
-        {
+        if (Double.isNaN(d0)) {
             d0 = 1.0D;
         }
 
@@ -1628,50 +1535,37 @@
         return distance < d0 * d0;
     }
 
-    public boolean writeToNBTAtomically(NBTTagCompound compound)
-    {
+    public boolean writeToNBTAtomically(NBTTagCompound compound) {
         String s = this.getEntityString();
 
-        if (!this.isDead && s != null)
-        {
+        if (!this.isDead && s != null) {
             compound.setString("id", s);
             this.writeToNBT(compound);
             return true;
-        }
-        else
-        {
+        } else {
             return false;
         }
     }
 
-    public boolean writeToNBTOptional(NBTTagCompound compound)
-    {
+    public boolean writeToNBTOptional(NBTTagCompound compound) {
         String s = this.getEntityString();
 
-        if (!this.isDead && s != null && !this.isRiding())
-        {
+        if (!this.isDead && s != null && !this.isRiding()) {
             compound.setString("id", s);
             this.writeToNBT(compound);
             return true;
-        }
-        else
-        {
+        } else {
             return false;
         }
     }
 
-    public static void registerFixes(DataFixer fixer)
-    {
-        fixer.registerWalker(FixTypes.ENTITY, new IDataWalker()
-        {
-            public NBTTagCompound process(IDataFixer fixer, NBTTagCompound compound, int versionIn)
-            {
-                if (compound.hasKey("Passengers", 9))
-                {
+    public static void registerFixes(DataFixer fixer) {
+        fixer.registerWalker(FixTypes.ENTITY, new IDataWalker() {
+            public NBTTagCompound process(IDataFixer fixer, NBTTagCompound compound, int versionIn) {
+                if (compound.hasKey("Passengers", 9)) {
                     NBTTagList nbttaglist = compound.getTagList("Passengers", 10);
 
-                    for (int i = 0; i < nbttaglist.tagCount(); ++i)
-                    {
+                    for (int i = 0; i < nbttaglist.tagCount(); ++i) {
                         nbttaglist.set(i, fixer.process(FixTypes.ENTITY, nbttaglist.getCompoundTagAt(i), versionIn));
                     }
                 }
@@ -1681,56 +1575,62 @@
         });
     }
 
-    public NBTTagCompound writeToNBT(NBTTagCompound compound)
-    {
-        try
-        {
+    public NBTTagCompound writeToNBT(NBTTagCompound compound) {
+        try {
             compound.setTag("Pos", this.newDoubleNBTList(this.posX, this.posY, this.posZ));
             compound.setTag("Motion", this.newDoubleNBTList(this.motionX, this.motionY, this.motionZ));
+            // CraftBukkit start - Checking for NaN pitch/yaw and resetting to zero
+            // TODO: make sure this is the best way to address this.
+            if (Float.isNaN(this.rotationYaw)) {
+                this.rotationYaw = 0;
+            }
+
+            if (Float.isNaN(this.rotationPitch)) {
+                this.rotationPitch = 0;
+            }
+            // CraftBukkit end
             compound.setTag("Rotation", this.newFloatNBTList(this.rotationYaw, this.rotationPitch));
             compound.setFloat("FallDistance", this.fallDistance);
-            compound.setShort("Fire", (short)this.fire);
-            compound.setShort("Air", (short)this.getAir());
+            compound.setShort("Fire", (short) this.fire);
+            compound.setShort("Air", (short) this.getAir());
             compound.setBoolean("OnGround", this.onGround);
             compound.setInteger("Dimension", this.dimension);
             compound.setBoolean("Invulnerable", this.invulnerable);
             compound.setInteger("PortalCooldown", this.timeUntilPortal);
             compound.setUniqueId("UUID", this.getUniqueID());
-
-            if (this.hasCustomName())
-            {
+            // CraftBukkit start
+            // PAIL: Check above UUID reads 1.8 properly, ie: UUIDMost / UUIDLeast
+            compound.setLong("WorldUUIDLeast", this.world.getSaveHandler().getUUID().getLeastSignificantBits());
+            compound.setLong("WorldUUIDMost", this.world.getSaveHandler().getUUID().getMostSignificantBits());
+            compound.setInteger("Bukkit.updateLevel", CURRENT_LEVEL);
+            // CraftBukkit end
+            if (this.hasCustomName()) {
                 compound.setString("CustomName", this.getCustomNameTag());
             }
 
-            if (this.getAlwaysRenderNameTag())
-            {
+            if (this.getAlwaysRenderNameTag()) {
                 compound.setBoolean("CustomNameVisible", this.getAlwaysRenderNameTag());
             }
 
             this.cmdResultStats.writeStatsToNBT(compound);
 
-            if (this.isSilent())
-            {
+            if (this.isSilent()) {
                 compound.setBoolean("Silent", this.isSilent());
             }
 
-            if (this.hasNoGravity())
-            {
+            if (this.hasNoGravity()) {
                 compound.setBoolean("NoGravity", this.hasNoGravity());
             }
 
-            if (this.glowing)
-            {
+            if (this.glowing) {
                 compound.setBoolean("Glowing", this.glowing);
             }
             compound.setBoolean("UpdateBlocked", updateBlocked);
 
-            if (!this.tags.isEmpty())
-            {
+            if (!this.tags.isEmpty()) {
                 NBTTagList nbttaglist = new NBTTagList();
 
-                for (String s : this.tags)
-                {
+                for (String s : this.tags) {
                     nbttaglist.appendTag(new NBTTagString(s));
                 }
 
@@ -1742,30 +1642,24 @@
 
             this.writeEntityToNBT(compound);
 
-            if (this.isBeingRidden())
-            {
+            if (this.isBeingRidden()) {
                 NBTTagList nbttaglist1 = new NBTTagList();
 
-                for (Entity entity : this.getPassengers())
-                {
+                for (Entity entity : this.getPassengers()) {
                     NBTTagCompound nbttagcompound = new NBTTagCompound();
 
-                    if (entity.writeToNBTAtomically(nbttagcompound))
-                    {
+                    if (entity.writeToNBTAtomically(nbttagcompound)) {
                         nbttaglist1.appendTag(nbttagcompound);
                     }
                 }
 
-                if (!nbttaglist1.hasNoTags())
-                {
+                if (!nbttaglist1.hasNoTags()) {
                     compound.setTag("Passengers", nbttaglist1);
                 }
             }
 
             return compound;
-        }
-        catch (Throwable throwable)
-        {
+        } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Saving entity NBT");
             CrashReportCategory crashreportcategory = crashreport.makeCategory("Entity being saved");
             this.addEntityCrashInfo(crashreportcategory);
@@ -1773,10 +1667,8 @@
         }
     }
 
-    public void readFromNBT(NBTTagCompound compound)
-    {
-        try
-        {
+    public void readFromNBT(NBTTagCompound compound) {
+        try {
             NBTTagList nbttaglist = compound.getTagList("Pos", 6);
             NBTTagList nbttaglist2 = compound.getTagList("Motion", 6);
             NBTTagList nbttaglist3 = compound.getTagList("Rotation", 5);
@@ -1784,6 +1676,7 @@
             this.motionY = nbttaglist2.getDoubleAt(1);
             this.motionZ = nbttaglist2.getDoubleAt(2);
 
+            /* CraftBukkit start - Moved section down
             if (Math.abs(this.motionX) > 10.0D)
             {
                 this.motionX = 0.0D;
@@ -1798,6 +1691,7 @@
             {
                 this.motionZ = 0.0D;
             }
+            // CraftBukkit end */
 
             this.posX = nbttaglist.getDoubleAt(0);
             this.posY = nbttaglist.getDoubleAt(1);
@@ -1819,16 +1713,14 @@
             this.setAir(compound.getShort("Air"));
             this.onGround = compound.getBoolean("OnGround");
 
-            if (compound.hasKey("Dimension"))
-            {
+            if (compound.hasKey("Dimension")) {
                 this.dimension = compound.getInteger("Dimension");
             }
 
             this.invulnerable = compound.getBoolean("Invulnerable");
             this.timeUntilPortal = compound.getInteger("PortalCooldown");
 
-            if (compound.hasUniqueId("UUID"))
-            {
+            if (compound.hasUniqueId("UUID")) {
                 this.entityUniqueID = compound.getUniqueId("UUID");
                 this.cachedUniqueIdString = this.entityUniqueID.toString();
             }
@@ -1836,8 +1728,7 @@
             this.setPosition(this.posX, this.posY, this.posZ);
             this.setRotation(this.rotationYaw, this.rotationPitch);
 
-            if (compound.hasKey("CustomName", 8))
-            {
+            if (compound.hasKey("CustomName", 8)) {
                 this.setCustomNameTag(compound.getString("CustomName"));
             }
 
@@ -1849,29 +1740,69 @@
             updateBlocked = compound.getBoolean("UpdateBlocked");
 
             if (compound.hasKey("ForgeData")) customEntityData = compound.getCompoundTag("ForgeData");
-            if (this.capabilities != null && compound.hasKey("ForgeCaps")) this.capabilities.deserializeNBT(compound.getCompoundTag("ForgeCaps"));
+            if (this.capabilities != null && compound.hasKey("ForgeCaps"))
+                this.capabilities.deserializeNBT(compound.getCompoundTag("ForgeCaps"));
 
-            if (compound.hasKey("Tags", 9))
-            {
+            if (compound.hasKey("Tags", 9)) {
                 this.tags.clear();
                 NBTTagList nbttaglist1 = compound.getTagList("Tags", 8);
                 int i = Math.min(nbttaglist1.tagCount(), 1024);
 
-                for (int j = 0; j < i; ++j)
-                {
+                for (int j = 0; j < i; ++j) {
                     this.tags.add(nbttaglist1.getStringTagAt(j));
                 }
             }
 
             this.readEntityFromNBT(compound);
 
-            if (this.shouldSetPosAfterLoading())
-            {
+            if (this.shouldSetPosAfterLoading()) {
                 this.setPosition(this.posX, this.posY, this.posZ);
             }
-        }
-        catch (Throwable throwable)
-        {
+
+            if (this instanceof EntityLiving) {
+                EntityLiving entity = (EntityLiving) this;
+
+                // Reset the persistence for tamed animals
+                if (entity instanceof EntityTameable && !isLevelAtLeast(compound, 2) && !compound.getBoolean("PersistenceRequired")) {
+                    ((EntityLiving) entity).persistenceRequired = !(entity).canDespawn();
+                }
+            }
+            double limit = getBukkitEntity() instanceof Vehicle ? 100.0D : 10.0D;
+            if (Math.abs(this.motionX) > limit) {
+                this.motionX = 0.0D;
+            }
+
+            if (Math.abs(this.motionY) > limit) {
+                this.motionY = 0.0D;
+            }
+
+            if (Math.abs(this.motionZ) > limit) {
+                this.motionZ = 0.0D;
+            }
+
+            // Reset world
+            if (this instanceof EntityPlayer) {
+                Server server = Bukkit.getServer();
+                org.bukkit.World bworld = null;
+
+                // TODO: Remove World related checks, replaced with WorldUID
+                String worldName = compound.getString("world");
+
+                if (compound.hasKey("WorldUUIDMost") && compound.hasKey("WorldUUIDLeast")) {
+                    UUID uid = new UUID(compound.getLong("WorldUUIDMost"), compound.getLong("WorldUUIDLeast"));
+                    bworld = server.getWorld(uid);
+                } else {
+                    bworld = server.getWorld(worldName);
+                }
+
+                if (bworld == null) {
+                    EntityPlayer entityPlayer = (EntityPlayer) this;
+                    bworld = ((org.bukkit.craftbukkit.CraftServer) server).getServer().getWorldServer(entityPlayer.dimension).getWorld();
+                }
+
+                setWorld(bworld == null ? null : ((CraftWorld) bworld).getHandle());
+            }
+        } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Loading entity NBT");
             CrashReportCategory crashreportcategory = crashreport.makeCategory("Entity being loaded");
             this.addEntityCrashInfo(crashreportcategory);
@@ -1879,14 +1810,12 @@
         }
     }
 
-    protected boolean shouldSetPosAfterLoading()
-    {
+    protected boolean shouldSetPosAfterLoading() {
         return true;
     }
 
     @Nullable
-    protected final String getEntityString()
-    {
+    public final String getEntityString() {
         ResourceLocation resourcelocation = EntityList.getKey(this);
         return resourcelocation == null ? null : resourcelocation.toString();
     }
@@ -1895,24 +1824,20 @@
 
     protected abstract void writeEntityToNBT(NBTTagCompound compound);
 
-    protected NBTTagList newDoubleNBTList(double... numbers)
-    {
+    protected NBTTagList newDoubleNBTList(double... numbers) {
         NBTTagList nbttaglist = new NBTTagList();
 
-        for (double d0 : numbers)
-        {
+        for (double d0 : numbers) {
             nbttaglist.appendTag(new NBTTagDouble(d0));
         }
 
         return nbttaglist;
     }
 
-    protected NBTTagList newFloatNBTList(float... numbers)
-    {
+    protected NBTTagList newFloatNBTList(float... numbers) {
         NBTTagList nbttaglist = new NBTTagList();
 
-        for (float f : numbers)
-        {
+        for (float f : numbers) {
             nbttaglist.appendTag(new NBTTagFloat(f));
         }
 
@@ -1920,63 +1845,50 @@
     }
 
     @Nullable
-    public EntityItem dropItem(Item itemIn, int size)
-    {
+    public EntityItem dropItem(Item itemIn, int size) {
         return this.dropItemWithOffset(itemIn, size, 0.0F);
     }
 
     @Nullable
-    public EntityItem dropItemWithOffset(Item itemIn, int size, float offsetY)
-    {
+    public EntityItem dropItemWithOffset(Item itemIn, int size, float offsetY) {
         return this.entityDropItem(new ItemStack(itemIn, size, 0), offsetY);
     }
 
     @Nullable
-    public EntityItem entityDropItem(ItemStack stack, float offsetY)
-    {
-        if (stack.isEmpty())
-        {
+    public EntityItem entityDropItem(ItemStack stack, float offsetY) {
+        if (stack.isEmpty()) {
             return null;
-        }
-        else
-        {
-            EntityItem entityitem = new EntityItem(this.world, this.posX, this.posY + (double)offsetY, this.posZ, stack);
+        } else {
+            EntityItem entityitem = new EntityItem(this.world, this.posX, this.posY + (double) offsetY, this.posZ, stack);
             entityitem.setDefaultPickupDelay();
             if (captureDrops)
                 this.capturedDrops.add(entityitem);
-            else
+            else {
                 this.world.spawnEntity(entityitem);
+            }
             return entityitem;
         }
     }
 
-    public boolean isEntityAlive()
-    {
+    public boolean isEntityAlive() {
         return !this.isDead;
     }
 
-    public boolean isEntityInsideOpaqueBlock()
-    {
-        if (this.noClip)
-        {
+    public boolean isEntityInsideOpaqueBlock() {
+        if (this.noClip) {
             return false;
-        }
-        else
-        {
+        } else {
             BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
-            for (int i = 0; i < 8; ++i)
-            {
-                int j = MathHelper.floor(this.posY + (double)(((float)((i >> 0) % 2) - 0.5F) * 0.1F) + (double)this.getEyeHeight());
-                int k = MathHelper.floor(this.posX + (double)(((float)((i >> 1) % 2) - 0.5F) * this.width * 0.8F));
-                int l = MathHelper.floor(this.posZ + (double)(((float)((i >> 2) % 2) - 0.5F) * this.width * 0.8F));
+            for (int i = 0; i < 8; ++i) {
+                int j = MathHelper.floor(this.posY + (double) (((float) ((i >> 0) % 2) - 0.5F) * 0.1F) + (double) this.getEyeHeight());
+                int k = MathHelper.floor(this.posX + (double) (((float) ((i >> 1) % 2) - 0.5F) * this.width * 0.8F));
+                int l = MathHelper.floor(this.posZ + (double) (((float) ((i >> 2) % 2) - 0.5F) * this.width * 0.8F));
 
-                if (blockpos$pooledmutableblockpos.getX() != k || blockpos$pooledmutableblockpos.getY() != j || blockpos$pooledmutableblockpos.getZ() != l)
-                {
+                if (blockpos$pooledmutableblockpos.getX() != k || blockpos$pooledmutableblockpos.getY() != j || blockpos$pooledmutableblockpos.getZ() != l) {
                     blockpos$pooledmutableblockpos.setPos(k, j, l);
 
-                    if (this.world.getBlockState(blockpos$pooledmutableblockpos).causesSuffocation())
-                    {
+                    if (this.world.getBlockState(blockpos$pooledmutableblockpos).causesSuffocation()) {
                         blockpos$pooledmutableblockpos.release();
                         return true;
                     }
@@ -1988,113 +1900,88 @@
         }
     }
 
-    public boolean processInitialInteract(EntityPlayer player, EnumHand hand)
-    {
+    public boolean processInitialInteract(EntityPlayer player, EnumHand hand) {
         return false;
     }
 
     @Nullable
-    public AxisAlignedBB getCollisionBox(Entity entityIn)
-    {
+    public AxisAlignedBB getCollisionBox(Entity entityIn) {
         return null;
     }
 
-    public void updateRidden()
-    {
+    public void updateRidden() {
         Entity entity = this.getRidingEntity();
 
-        if (this.isRiding() && entity.isDead)
-        {
+        if (this.isRiding() && entity.isDead) {
             this.dismountRidingEntity();
-        }
-        else
-        {
+        } else {
             this.motionX = 0.0D;
             this.motionY = 0.0D;
             this.motionZ = 0.0D;
-            if(!updateBlocked)
-            this.onUpdate();
+            if (!updateBlocked)
+                this.onUpdate();
 
-            if (this.isRiding())
-            {
+            if (this.isRiding()) {
                 entity.updatePassenger(this);
             }
         }
     }
 
-    public void updatePassenger(Entity passenger)
-    {
-        if (this.isPassenger(passenger))
-        {
+    public void updatePassenger(Entity passenger) {
+        if (this.isPassenger(passenger)) {
             passenger.setPosition(this.posX, this.posY + this.getMountedYOffset() + passenger.getYOffset(), this.posZ);
         }
     }
 
     @SideOnly(Side.CLIENT)
-    public void applyOrientationToEntity(Entity entityToUpdate)
-    {
+    public void applyOrientationToEntity(Entity entityToUpdate) {
     }
 
-    public double getYOffset()
-    {
+    public double getYOffset() {
         return 0.0D;
     }
 
-    public double getMountedYOffset()
-    {
-        return (double)this.height * 0.75D;
+    public double getMountedYOffset() {
+        return (double) this.height * 0.75D;
     }
 
-    public boolean startRiding(Entity entityIn)
-    {
+    public boolean startRiding(Entity entityIn) {
         return this.startRiding(entityIn, false);
     }
 
-    public boolean startRiding(Entity entityIn, boolean force)
-    {
-        for (Entity entity = entityIn; entity.ridingEntity != null; entity = entity.ridingEntity)
-        {
-            if (entity.ridingEntity == this)
-            {
+    public boolean startRiding(Entity entityIn, boolean force) {
+        for (Entity entity = entityIn; entity.ridingEntity != null; entity = entity.ridingEntity) {
+            if (entity.ridingEntity == this) {
                 return false;
             }
         }
 
         if (!net.minecraftforge.event.ForgeEventFactory.canMountEntity(this, entityIn, true)) return false;
-        if (force || this.canBeRidden(entityIn) && entityIn.canFitPassenger(this))
-        {
-            if (this.isRiding())
-            {
+        if (force || this.canBeRidden(entityIn) && entityIn.canFitPassenger(this)) {
+            if (this.isRiding()) {
                 this.dismountRidingEntity();
             }
 
             this.ridingEntity = entityIn;
             this.ridingEntity.addPassenger(this);
             return true;
-        }
-        else
-        {
+        } else {
             return false;
         }
     }
 
-    protected boolean canBeRidden(Entity entityIn)
-    {
+    protected boolean canBeRidden(Entity entityIn) {
         return this.rideCooldown <= 0;
     }
 
-    public void removePassengers()
-    {
-        for (int i = this.riddenByEntities.size() - 1; i >= 0; --i)
-        {
-            ((Entity)this.riddenByEntities.get(i)).dismountRidingEntity();
+    public void removePassengers() {
+        for (int i = this.riddenByEntities.size() - 1; i >= 0; --i) {
+            ((Entity) this.riddenByEntities.get(i)).dismountRidingEntity();
         }
     }
 
-    public void dismountRidingEntity()
-    {
-        if (this.ridingEntity != null)
-        {
+    public void dismountRidingEntity() {
+        if (this.ridingEntity != null) {
             Entity entity = this.ridingEntity;
             if (!net.minecraftforge.event.ForgeEventFactory.canMountEntity(this, entity, false)) return;
             this.ridingEntity = null;
@@ -2102,88 +1989,104 @@
         }
     }
 
-    protected void addPassenger(Entity passenger)
-    {
-        if (passenger.getRidingEntity() != this)
-        {
+    protected void addPassenger(Entity passenger) {
+        if (passenger.getRidingEntity() != this) {
             throw new IllegalStateException("Use x.startRiding(y), not y.addPassenger(x)");
-        }
-        else
-        {
-            if (!this.world.isRemote && passenger instanceof EntityPlayer && !(this.getControllingPassenger() instanceof EntityPlayer))
-            {
-                this.riddenByEntities.add(0, passenger);
+        } else {
+            com.google.common.base.Preconditions.checkState(!passenger.riddenByEntities.contains(this), "Circular entity riding! %s %s", this, passenger);
+
+            CraftEntity craft = (CraftEntity) passenger.getBukkitEntity().getVehicle();
+            Entity orig = craft == null ? null : craft.getHandle();
+            if (getBukkitEntity() instanceof Vehicle && passenger.getBukkitEntity() instanceof LivingEntity && passenger.world.isChunkLoaded((int) passenger.posX >> 4, (int) passenger.posZ >> 4, false)) { // Boolean not used
+                VehicleEnterEvent event = new VehicleEnterEvent(
+                        (Vehicle) getBukkitEntity(),
+                        passenger.getBukkitEntity()
+                );
+                Bukkit.getPluginManager().callEvent(event);
+                CraftEntity craftn = (CraftEntity) passenger.getBukkitEntity().getVehicle();
+                Entity n = craftn == null ? null : craftn.getHandle();
+                if (event.isCancelled() || n != orig) {
+                    return;
+                }
             }
-            else
-            {
+            // Spigot start
+            org.spigotmc.event.entity.EntityMountEvent event = new org.spigotmc.event.entity.EntityMountEvent(passenger.getBukkitEntity(), this.getBukkitEntity());
+            Bukkit.getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                return;
+            }
+            // Spigot end
+            if (!this.world.isRemote && passenger instanceof EntityPlayer && !(this.getControllingPassenger() instanceof EntityPlayer)) {
+                this.riddenByEntities.add(0, passenger);
+            } else {
                 this.riddenByEntities.add(passenger);
             }
         }
     }
 
-    protected void removePassenger(Entity passenger)
-    {
-        if (passenger.getRidingEntity() == this)
-        {
+    protected void removePassenger(Entity passenger) {
+        if (passenger.getRidingEntity() == this) {
             throw new IllegalStateException("Use x.stopRiding(y), not y.removePassenger(x)");
-        }
-        else
-        {
+        } else {
+            CraftEntity craft = (CraftEntity) passenger.getBukkitEntity().getVehicle();
+            Entity orig = craft == null ? null : craft.getHandle();
+            if (getBukkitEntity() instanceof Vehicle && passenger.getBukkitEntity() instanceof LivingEntity) {
+                VehicleExitEvent event = new VehicleExitEvent(
+                        (Vehicle) getBukkitEntity(),
+                        (LivingEntity) passenger.getBukkitEntity()
+                );
+                Bukkit.getPluginManager().callEvent(event);
+                CraftEntity craftn = (CraftEntity) passenger.getBukkitEntity().getVehicle();
+                Entity n = craftn == null ? null : craftn.getHandle();
+                if (event.isCancelled() || n != orig) {
+                    return;
+                }
+            }
+            Bukkit.getPluginManager().callEvent(new org.spigotmc.event.entity.EntityDismountEvent(passenger.getBukkitEntity(), this.getBukkitEntity())); // Spigot
             this.riddenByEntities.remove(passenger);
             passenger.rideCooldown = 60;
         }
     }
 
-    protected boolean canFitPassenger(Entity passenger)
-    {
+    protected boolean canFitPassenger(Entity passenger) {
         return this.getPassengers().size() < 1;
     }
 
     @SideOnly(Side.CLIENT)
-    public void setPositionAndRotationDirect(double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport)
-    {
+    public void setPositionAndRotationDirect(double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport) {
         this.setPosition(x, y, z);
         this.setRotation(yaw, pitch);
     }
 
-    public float getCollisionBorderSize()
-    {
+    public float getCollisionBorderSize() {
         return 0.0F;
     }
 
-    public Vec3d getLookVec()
-    {
+    public Vec3d getLookVec() {
         return this.getVectorForRotation(this.rotationPitch, this.rotationYaw);
     }
 
     @SideOnly(Side.CLIENT)
-    public Vec2f getPitchYaw()
-    {
+    public Vec2f getPitchYaw() {
         return new Vec2f(this.rotationPitch, this.rotationYaw);
     }
 
     @SideOnly(Side.CLIENT)
-    public Vec3d getForward()
-    {
+    public Vec3d getForward() {
         return Vec3d.fromPitchYawVector(this.getPitchYaw());
     }
 
-    public void setPortal(BlockPos pos)
-    {
-        if (this.timeUntilPortal > 0)
-        {
+    public void setPortal(BlockPos pos) {
+        if (this.timeUntilPortal > 0) {
             this.timeUntilPortal = this.getPortalCooldown();
-        }
-        else
-        {
-            if (!this.world.isRemote && !pos.equals(this.lastPortalPos))
-            {
+        } else {
+            if (!this.world.isRemote && !pos.equals(this.lastPortalPos)) {
                 this.lastPortalPos = new BlockPos(pos);
                 BlockPattern.PatternHelper blockpattern$patternhelper = Blocks.PORTAL.createPatternHelper(this.world, this.lastPortalPos);
-                double d0 = blockpattern$patternhelper.getForwards().getAxis() == EnumFacing.Axis.X ? (double)blockpattern$patternhelper.getFrontTopLeft().getZ() : (double)blockpattern$patternhelper.getFrontTopLeft().getX();
+                double d0 = blockpattern$patternhelper.getForwards().getAxis() == EnumFacing.Axis.X ? (double) blockpattern$patternhelper.getFrontTopLeft().getZ() : (double) blockpattern$patternhelper.getFrontTopLeft().getX();
                 double d1 = blockpattern$patternhelper.getForwards().getAxis() == EnumFacing.Axis.X ? this.posZ : this.posX;
-                d1 = Math.abs(MathHelper.pct(d1 - (double)(blockpattern$patternhelper.getForwards().rotateY().getAxisDirection() == EnumFacing.AxisDirection.NEGATIVE ? 1 : 0), d0, d0 - (double)blockpattern$patternhelper.getWidth()));
-                double d2 = MathHelper.pct(this.posY - 1.0D, (double)blockpattern$patternhelper.getFrontTopLeft().getY(), (double)(blockpattern$patternhelper.getFrontTopLeft().getY() - blockpattern$patternhelper.getHeight()));
+                d1 = Math.abs(MathHelper.pct(d1 - (double) (blockpattern$patternhelper.getForwards().rotateY().getAxisDirection() == EnumFacing.AxisDirection.NEGATIVE ? 1 : 0), d0, d0 - (double) blockpattern$patternhelper.getWidth()));
+                double d2 = MathHelper.pct(this.posY - 1.0D, (double) blockpattern$patternhelper.getFrontTopLeft().getY(), (double) (blockpattern$patternhelper.getFrontTopLeft().getY() - blockpattern$patternhelper.getHeight()));
                 this.lastPortalVec = new Vec3d(d1, d2, 0.0D);
                 this.teleportDirection = blockpattern$patternhelper.getForwards();
             }
@@ -2192,273 +2095,252 @@
         }
     }
 
-    public int getPortalCooldown()
-    {
+    public int getPortalCooldown() {
         return 300;
     }
 
     @SideOnly(Side.CLIENT)
-    public void setVelocity(double x, double y, double z)
-    {
+    public void setVelocity(double x, double y, double z) {
         this.motionX = x;
         this.motionY = y;
         this.motionZ = z;
     }
 
     @SideOnly(Side.CLIENT)
-    public void handleStatusUpdate(byte id)
-    {
+    public void handleStatusUpdate(byte id) {
     }
 
     @SideOnly(Side.CLIENT)
-    public void performHurtAnimation()
-    {
+    public void performHurtAnimation() {
     }
 
-    public Iterable<ItemStack> getHeldEquipment()
-    {
+    public Iterable<ItemStack> getHeldEquipment() {
         return EMPTY_EQUIPMENT;
     }
 
-    public Iterable<ItemStack> getArmorInventoryList()
-    {
+    public Iterable<ItemStack> getArmorInventoryList() {
         return EMPTY_EQUIPMENT;
     }
 
-    public Iterable<ItemStack> getEquipmentAndArmor()
-    {
+    public Iterable<ItemStack> getEquipmentAndArmor() {
         return Iterables.<ItemStack>concat(this.getHeldEquipment(), this.getArmorInventoryList());
     }
 
-    public void setItemStackToSlot(EntityEquipmentSlot slotIn, ItemStack stack)
-    {
+    public void setItemStackToSlot(EntityEquipmentSlot slotIn, ItemStack stack) {
     }
 
-    public boolean isBurning()
-    {
+    public boolean isBurning() {
         boolean flag = this.world != null && this.world.isRemote;
         return !this.isImmuneToFire && (this.fire > 0 || flag && this.getFlag(0));
     }
 
-    public boolean isRiding()
-    {
+    public boolean isRiding() {
         return this.getRidingEntity() != null;
     }
 
-    public boolean isBeingRidden()
-    {
+    public boolean isBeingRidden() {
         return !this.getPassengers().isEmpty();
     }
 
-    public boolean isSneaking()
-    {
+    public boolean isSneaking() {
         return this.getFlag(1);
     }
 
-    public void setSneaking(boolean sneaking)
-    {
+    public void setSneaking(boolean sneaking) {
         this.setFlag(1, sneaking);
     }
 
-    public boolean isSprinting()
-    {
+    public boolean isSprinting() {
         return this.getFlag(3);
     }
 
-    public void setSprinting(boolean sprinting)
-    {
+    public void setSprinting(boolean sprinting) {
         this.setFlag(3, sprinting);
     }
 
-    public boolean isGlowing()
-    {
+    public boolean isGlowing() {
         return this.glowing || this.world.isRemote && this.getFlag(6);
     }
 
-    public void setGlowing(boolean glowingIn)
-    {
+    public void setGlowing(boolean glowingIn) {
         this.glowing = glowingIn;
 
-        if (!this.world.isRemote)
-        {
+        if (!this.world.isRemote) {
             this.setFlag(6, this.glowing);
         }
     }
 
-    public boolean isInvisible()
-    {
+    public boolean isInvisible() {
         return this.getFlag(5);
     }
 
     @SideOnly(Side.CLIENT)
-    public boolean isInvisibleToPlayer(EntityPlayer player)
-    {
-        if (player.isSpectator())
-        {
+    public boolean isInvisibleToPlayer(EntityPlayer player) {
+        if (player.isSpectator()) {
             return false;
-        }
-        else
-        {
+        } else {
             Team team = this.getTeam();
             return team != null && player != null && player.getTeam() == team && team.getSeeFriendlyInvisiblesEnabled() ? false : this.isInvisible();
         }
     }
 
     @Nullable
-    public Team getTeam()
-    {
+    public Team getTeam() {
         return this.world.getScoreboard().getPlayersTeam(this.getCachedUniqueIdString());
     }
 
-    public boolean isOnSameTeam(Entity entityIn)
-    {
+    public boolean isOnSameTeam(Entity entityIn) {
         return this.isOnScoreboardTeam(entityIn.getTeam());
     }
 
-    public boolean isOnScoreboardTeam(Team teamIn)
-    {
+    public boolean isOnScoreboardTeam(Team teamIn) {
         return this.getTeam() != null ? this.getTeam().isSameTeam(teamIn) : false;
     }
 
-    public void setInvisible(boolean invisible)
-    {
+    public void setInvisible(boolean invisible) {
         this.setFlag(5, invisible);
     }
 
-    protected boolean getFlag(int flag)
-    {
-        return (((Byte)this.dataManager.get(FLAGS)).byteValue() & 1 << flag) != 0;
+    public boolean getFlag(int flag) {
+        return (((Byte) this.dataManager.get(FLAGS)).byteValue() & 1 << flag) != 0;
     }
 
-    protected void setFlag(int flag, boolean set)
-    {
-        byte b0 = ((Byte)this.dataManager.get(FLAGS)).byteValue();
+    public void setFlag(int flag, boolean set) {
+        byte b0 = ((Byte) this.dataManager.get(FLAGS)).byteValue();
 
-        if (set)
-        {
-            this.dataManager.set(FLAGS, Byte.valueOf((byte)(b0 | 1 << flag)));
+        if (set) {
+            this.dataManager.set(FLAGS, Byte.valueOf((byte) (b0 | 1 << flag)));
+        } else {
+            this.dataManager.set(FLAGS, Byte.valueOf((byte) (b0 & ~(1 << flag))));
         }
-        else
-        {
-            this.dataManager.set(FLAGS, Byte.valueOf((byte)(b0 & ~(1 << flag))));
-        }
     }
 
-    public int getAir()
-    {
-        return ((Integer)this.dataManager.get(AIR)).intValue();
+    public int getAir() {
+        return ((Integer) this.dataManager.get(AIR)).intValue();
     }
 
-    public void setAir(int air)
-    {
-        this.dataManager.set(AIR, Integer.valueOf(air));
+    public void setAir(int air) {
+//        this.dataManager.set(AIR, Integer.valueOf(air));
+        EntityAirChangeEvent event = new EntityAirChangeEvent(this.getBukkitEntity(), air);
+        event.getEntity().getServer().getPluginManager().callEvent(event);
+        if (event.isCancelled()) {
+            return;
+        }
+        this.dataManager.set(Entity.AIR, event.getAmount());
     }
 
-    public void onStruckByLightning(EntityLightningBolt lightningBolt)
-    {
+    public void onStruckByLightning(@Nullable EntityLightningBolt lightningBolt) {
+        if (lightningBolt == null)
+            lightningBolt = new EntityLightningBolt(this.world, this.posX, this.posY, this.posZ, false);
+        final org.bukkit.entity.Entity thisBukkitEntity = this.getBukkitEntity();
+        final org.bukkit.entity.Entity stormBukkitEntity = lightningBolt.getBukkitEntity();
+        final PluginManager pluginManager = Bukkit.getPluginManager();
+
+        if (thisBukkitEntity instanceof Hanging) {
+            HangingBreakByEntityEvent hangingEvent = new HangingBreakByEntityEvent((Hanging) thisBukkitEntity, stormBukkitEntity);
+            pluginManager.callEvent(hangingEvent);
+
+            if (hangingEvent.isCancelled()) {
+                return;
+            }
+        }
+
+        if (this.isImmuneToFire) {
+            return;
+        }
+        CraftEventFactory.entityDamage = lightningBolt;
+        if (!this.attackEntityFrom(DamageSource.LIGHTNING_BOLT, 5.0F)) {
+            CraftEventFactory.entityDamage = null;
+            return;
+        }
         this.attackEntityFrom(DamageSource.LIGHTNING_BOLT, 5.0F);
         ++this.fire;
 
-        if (this.fire == 0)
-        {
-            this.setFire(8);
+        if (this.fire == 0) {
+            // this.setFire(8);
+            // CraftBukkit start - Call a combust event when lightning strikes
+            EntityCombustByEntityEvent entityCombustEvent = new EntityCombustByEntityEvent(stormBukkitEntity, thisBukkitEntity, 8);
+            pluginManager.callEvent(entityCombustEvent);
+            if (!entityCombustEvent.isCancelled()) {
+                this.setFire(entityCombustEvent.getDuration());
+            }
+            // CraftBukkit end
         }
     }
 
-    public void onKillEntity(EntityLivingBase entityLivingIn)
-    {
+    public void onKillEntity(EntityLivingBase entityLivingIn) {
     }
 
-    protected boolean pushOutOfBlocks(double x, double y, double z)
-    {
+    protected boolean pushOutOfBlocks(double x, double y, double z) {
         BlockPos blockpos = new BlockPos(x, y, z);
-        double d0 = x - (double)blockpos.getX();
-        double d1 = y - (double)blockpos.getY();
-        double d2 = z - (double)blockpos.getZ();
+        double d0 = x - (double) blockpos.getX();
+        double d1 = y - (double) blockpos.getY();
+        double d2 = z - (double) blockpos.getZ();
 
-        if (!this.world.collidesWithAnyBlock(this.getEntityBoundingBox()))
-        {
+        if (!this.world.collidesWithAnyBlock(this.getEntityBoundingBox())) {
             return false;
-        }
-        else
-        {
+        } else {
             EnumFacing enumfacing = EnumFacing.UP;
             double d3 = Double.MAX_VALUE;
 
-            if (!this.world.isBlockFullCube(blockpos.west()) && d0 < d3)
-            {
+            if (!this.world.isBlockFullCube(blockpos.west()) && d0 < d3) {
                 d3 = d0;
                 enumfacing = EnumFacing.WEST;
             }
 
-            if (!this.world.isBlockFullCube(blockpos.east()) && 1.0D - d0 < d3)
-            {
+            if (!this.world.isBlockFullCube(blockpos.east()) && 1.0D - d0 < d3) {
                 d3 = 1.0D - d0;
                 enumfacing = EnumFacing.EAST;
             }
 
-            if (!this.world.isBlockFullCube(blockpos.north()) && d2 < d3)
-            {
+            if (!this.world.isBlockFullCube(blockpos.north()) && d2 < d3) {
                 d3 = d2;
                 enumfacing = EnumFacing.NORTH;
             }
 
-            if (!this.world.isBlockFullCube(blockpos.south()) && 1.0D - d2 < d3)
-            {
+            if (!this.world.isBlockFullCube(blockpos.south()) && 1.0D - d2 < d3) {
                 d3 = 1.0D - d2;
                 enumfacing = EnumFacing.SOUTH;
             }
 
-            if (!this.world.isBlockFullCube(blockpos.up()) && 1.0D - d1 < d3)
-            {
+            if (!this.world.isBlockFullCube(blockpos.up()) && 1.0D - d1 < d3) {
                 d3 = 1.0D - d1;
                 enumfacing = EnumFacing.UP;
             }
 
             float f = this.rand.nextFloat() * 0.2F + 0.1F;
-            float f1 = (float)enumfacing.getAxisDirection().getOffset();
+            float f1 = (float) enumfacing.getAxisDirection().getOffset();
 
-            if (enumfacing.getAxis() == EnumFacing.Axis.X)
-            {
-                this.motionX = (double)(f1 * f);
+            if (enumfacing.getAxis() == EnumFacing.Axis.X) {
+                this.motionX = (double) (f1 * f);
                 this.motionY *= 0.75D;
                 this.motionZ *= 0.75D;
-            }
-            else if (enumfacing.getAxis() == EnumFacing.Axis.Y)
-            {
+            } else if (enumfacing.getAxis() == EnumFacing.Axis.Y) {
                 this.motionX *= 0.75D;
-                this.motionY = (double)(f1 * f);
+                this.motionY = (double) (f1 * f);
                 this.motionZ *= 0.75D;
-            }
-            else if (enumfacing.getAxis() == EnumFacing.Axis.Z)
-            {
+            } else if (enumfacing.getAxis() == EnumFacing.Axis.Z) {
                 this.motionX *= 0.75D;
                 this.motionY *= 0.75D;
-                this.motionZ = (double)(f1 * f);
+                this.motionZ = (double) (f1 * f);
             }
 
             return true;
         }
     }
 
-    public void setInWeb()
-    {
+    public void setInWeb() {
         this.isInWeb = true;
         this.fallDistance = 0.0F;
     }
 
-    public String getName()
-    {
-        if (this.hasCustomName())
-        {
+    public String getName() {
+        if (this.hasCustomName()) {
             return this.getCustomNameTag();
-        }
-        else
-        {
+        } else {
             String s = EntityList.getEntityString(this);
 
-            if (s == null)
-            {
+            if (s == null) {
                 s = "generic";
             }
 
@@ -2467,66 +2349,53 @@
     }
 
     @Nullable
-    public Entity[] getParts()
-    {
+    public Entity[] getParts() {
         return null;
     }
 
-    public boolean isEntityEqual(Entity entityIn)
-    {
+    public boolean isEntityEqual(Entity entityIn) {
         return this == entityIn;
     }
 
-    public float getRotationYawHead()
-    {
+    public float getRotationYawHead() {
         return 0.0F;
     }
 
-    public void setRotationYawHead(float rotation)
-    {
+    public void setRotationYawHead(float rotation) {
     }
 
-    public void setRenderYawOffset(float offset)
-    {
+    public void setRenderYawOffset(float offset) {
     }
 
-    public boolean canBeAttackedWithItem()
-    {
+    public boolean canBeAttackedWithItem() {
         return true;
     }
 
-    public boolean hitByEntity(Entity entityIn)
-    {
+    public boolean hitByEntity(Entity entityIn) {
         return false;
     }
 
-    public String toString()
-    {
+    public String toString() {
         return String.format("%s['%s'/%d, l='%s', x=%.2f, y=%.2f, z=%.2f]", this.getClass().getSimpleName(), this.getName(), this.entityId, this.world == null ? "~NULL~" : this.world.getWorldInfo().getWorldName(), this.posX, this.posY, this.posZ);
     }
 
-    public boolean isEntityInvulnerable(DamageSource source)
-    {
+    public boolean isEntityInvulnerable(DamageSource source) {
         return this.invulnerable && source != DamageSource.OUT_OF_WORLD && !source.isCreativePlayer();
     }
 
-    public boolean getIsInvulnerable()
-    {
+    public boolean getIsInvulnerable() {
         return this.invulnerable;
     }
 
-    public void setEntityInvulnerable(boolean isInvulnerable)
-    {
+    public void setEntityInvulnerable(boolean isInvulnerable) {
         this.invulnerable = isInvulnerable;
     }
 
-    public void copyLocationAndAnglesFrom(Entity entityIn)
-    {
+    public void copyLocationAndAnglesFrom(Entity entityIn) {
         this.setLocationAndAngles(entityIn.posX, entityIn.posY, entityIn.posZ, entityIn.rotationYaw, entityIn.rotationPitch);
     }
 
-    private void copyDataFromOld(Entity entityIn)
-    {
+    private void copyDataFromOld(Entity entityIn) {
         NBTTagCompound nbttagcompound = entityIn.writeToNBT(new NBTTagCompound());
         nbttagcompound.removeTag("Dimension");
         this.readFromNBT(nbttagcompound);
@@ -2537,34 +2406,85 @@
     }
 
     @Nullable
-    public Entity changeDimension(int dimensionIn)
-    {
+    public Entity changeDimension(int dimensionIn) {
         if (this.world.isRemote || this.isDead) return null;
-        return changeDimension(dimensionIn, this.getServer().getWorld(dimensionIn).getDefaultTeleporter());
+        return changeDimension(dimensionIn, this.getServer().getWorldServer(dimensionIn).getDefaultTeleporter());
     }
 
     @Nullable // Forge: Entities that require custom handling should override this method, not the other
-    public Entity changeDimension(int dimensionIn, net.minecraftforge.common.util.ITeleporter teleporter)
-    {
-        if (!this.world.isRemote && !this.isDead)
-        {
+    public Entity changeDimension(int dimensionIn, net.minecraftforge.common.util.ITeleporter teleporter) {
+        if (!this.world.isRemote && !this.isDead) {
             if (!net.minecraftforge.common.ForgeHooks.onTravelToDimension(this, dimensionIn)) return null;
             this.world.profiler.startSection("changeDimension");
             MinecraftServer minecraftserver = this.getServer();
-            int i = this.dimension;
-            WorldServer worldserver = minecraftserver.getWorld(i);
-            WorldServer worldserver1 = minecraftserver.getWorld(dimensionIn);
-            this.dimension = dimensionIn;
+            // CraftBukkit start - Move logic into new function "teleportTo(Location,boolean)"
+            // int i = this.dimension;
+            // WorldServer worldserver = minecraftserver.getWorld(i);
+            // WorldServer worldserver1 = minecraftserver.getWorld(dimensionIn);
+            WorldServer exitWorld = null;
+            if (this.dimension < CraftWorld.CUSTOM_DIMENSION_OFFSET) { // Plugins must specify exit from custom Bukkit worlds
+                // Only target existing worlds (compensate for allow-nether/allow-end as false)
+                for (WorldServer world : minecraftserver.worlds) {
+                    if (world.dimension == dimensionIn) {
+                        exitWorld = world;
+                    }
+                }
+            }
 
+            BlockPos blockposition = null; // PAIL: CHECK
+            Location enter = this.getBukkitEntity().getLocation();
+            Location exit;
+            if (exitWorld != null) {
+                if (blockposition != null) {
+                    exit = new Location(exitWorld.getWorld(), blockposition.getX(), blockposition.getY(), blockposition.getZ());
+                } else {
+                    exit = minecraftserver.getPlayerList().calculateTarget(enter, minecraftserver.getWorld(dimensionIn));
+                }
+            } else {
+                exit = null;
+            }
+            boolean useTravelAgent = exitWorld != null && !(this.dimension == 1 && exitWorld.dimension == 1); // don't use agent for custom worlds or return from THE_END
+
+            TravelAgent agent = exit != null ? (TravelAgent) ((CraftWorld) exit.getWorld()).getHandle().getDefaultTeleporter() : org.bukkit.craftbukkit.CraftTravelAgent.DEFAULT; // return arbitrary TA to compensate for implementation dependent plugins
+            boolean oldCanCreate = agent.getCanCreatePortal();
+            agent.setCanCreatePortal(false); // General entities cannot create portals
+
+            EntityPortalEvent event = new EntityPortalEvent(this.getBukkitEntity(), enter, exit, agent);
+            event.useTravelAgent(useTravelAgent);
+            event.getEntity().getServer().getPluginManager().callEvent(event);
+            if (event.isCancelled() || event.getTo() == null || event.getTo().getWorld() == null || !this.isEntityAlive()) {
+                agent.setCanCreatePortal(oldCanCreate);
+                return null;
+            }
+            exit = event.useTravelAgent() ? event.getPortalTravelAgent().findOrCreate(event.getTo()) : event.getTo();
+            agent.setCanCreatePortal(oldCanCreate);
+
+            // Need to make sure the profiler state is reset afterwards (but we still want to time the call)
+            Entity entity = this.teleportTo(exit, true);
+            this.world.profiler.endSection();
+            return entity;
+        }
+        return null;
+    }
+
+    public Entity teleportTo(Location exit, boolean portal) {
+        if (true) {
+            WorldServer worldserver = ((CraftWorld) getBukkitEntity().getLocation().getWorld()).getHandle();
+            WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
+            int i = worldserver1.dimension;
+            this.dimension = i;
+            /* CraftBukkit start - TODO: Check if we need this
             if (i == 1 && dimensionIn == 1 && teleporter.isVanilla())
             {
                 worldserver1 = minecraftserver.getWorld(0);
                 this.dimension = 0;
             }
+            // CraftBukkit end */
 
             this.world.removeEntity(this);
             this.isDead = false;
             this.world.profiler.startSection("reposition");
+            /* CraftBukkit start - Handled in calculateTarget
             BlockPos blockpos;
 
             if (dimensionIn == 1 && teleporter.isVanilla())
@@ -2596,15 +2516,19 @@
                 teleporter.placeEntity(worldserver1, this, f);
                 blockpos = new BlockPos(this);
             }
+            // CraftBukkit end */
 
-            worldserver.updateEntityWithOptionalForce(this, false);
+            // worldserver.updateEntityWithOptionalForce(this, false); // Handled in repositionEntity
+            // CraftBukkit start - Ensure chunks are loaded in case TravelAgent is not used which would initially cause chunks to load during find/create
+            // minecraftserver.getPlayerList().changeWorld(this, j, worldserver, worldserver1);
+            worldserver1.getMinecraftServer().getPlayerList().repositionEntity(this, exit, portal);
             this.world.profiler.endStartSection("reloading");
             Entity entity = EntityList.newEntity(this.getClass(), worldserver1);
 
-            if (entity != null)
-            {
+            if (entity != null) {
                 entity.copyDataFromOld(this);
 
+                /* CraftBukkit start - We need to do this...
                 if (i == 1 && dimensionIn == 1 && teleporter.isVanilla())
                 {
                     BlockPos blockpos1 = worldserver1.getTopSolidOrLiquidBlock(worldserver1.getSpawnPoint());
@@ -2614,205 +2538,181 @@
                 {
                     entity.moveToBlockPosAndAngles(blockpos, entity.rotationYaw, entity.rotationPitch);
                 }
+                // CraftBukkit end */
 
                 boolean flag = entity.forceSpawn;
                 entity.forceSpawn = true;
                 worldserver1.spawnEntity(entity);
                 entity.forceSpawn = flag;
                 worldserver1.updateEntityWithOptionalForce(entity, false);
+                // CraftBukkit start - Forward the CraftEntity to the new entity
+                this.getBukkitEntity().setHandle(entity);
+                entity.bukkitEntity = this.getBukkitEntity();
+
+                if (this instanceof EntityLiving) {
+                    ((EntityLiving) this).clearLeashed(true, false); // Unleash to prevent duping of leads.
+                }
+                // CraftBukkit end
             }
 
             this.isDead = true;
             this.world.profiler.endSection();
             worldserver.resetUpdateEntityTick();
             worldserver1.resetUpdateEntityTick();
-            this.world.profiler.endSection();
+            // this.world.profiler.endSection(); // CraftBukkit: Moved up to keep balanced
             return entity;
-        }
-        else
-        {
+        } else {
             return null;
         }
     }
 
-    public boolean isNonBoss()
-    {
+    public boolean isNonBoss() {
         return true;
     }
 
-    public float getExplosionResistance(Explosion explosionIn, World worldIn, BlockPos pos, IBlockState blockStateIn)
-    {
+    public float getExplosionResistance(Explosion explosionIn, World worldIn, BlockPos pos, IBlockState blockStateIn) {
         return blockStateIn.getBlock().getExplosionResistance(worldIn, pos, this, explosionIn);
     }
 
-    public boolean canExplosionDestroyBlock(Explosion explosionIn, World worldIn, BlockPos pos, IBlockState blockStateIn, float p_174816_5_)
-    {
+    public boolean canExplosionDestroyBlock(Explosion explosionIn, World worldIn, BlockPos pos, IBlockState blockStateIn, float p_174816_5_) {
         return true;
     }
 
-    public int getMaxFallHeight()
-    {
+    public int getMaxFallHeight() {
         return 3;
     }
 
-    public Vec3d getLastPortalVec()
-    {
+    public Vec3d getLastPortalVec() {
         return this.lastPortalVec;
     }
 
-    public EnumFacing getTeleportDirection()
-    {
+    public EnumFacing getTeleportDirection() {
         return this.teleportDirection;
     }
 
-    public boolean doesEntityNotTriggerPressurePlate()
-    {
+    public boolean doesEntityNotTriggerPressurePlate() {
         return false;
     }
 
-    public void addEntityCrashInfo(CrashReportCategory category)
-    {
-        category.addDetail("Entity Type", new ICrashReportDetail<String>()
-        {
-            public String call() throws Exception
-            {
+    public void addEntityCrashInfo(CrashReportCategory category) {
+        category.addDetail("Entity Type", new ICrashReportDetail<String>() {
+            public String call() throws Exception {
                 return EntityList.getKey(Entity.this) + " (" + Entity.this.getClass().getCanonicalName() + ")";
             }
         });
         category.addCrashSection("Entity ID", Integer.valueOf(this.entityId));
-        category.addDetail("Entity Name", new ICrashReportDetail<String>()
-        {
-            public String call() throws Exception
-            {
+        category.addDetail("Entity Name", new ICrashReportDetail<String>() {
+            public String call() throws Exception {
                 return Entity.this.getName();
             }
         });
         category.addCrashSection("Entity's Exact location", String.format("%.2f, %.2f, %.2f", this.posX, this.posY, this.posZ));
         category.addCrashSection("Entity's Block location", CrashReportCategory.getCoordinateInfo(MathHelper.floor(this.posX), MathHelper.floor(this.posY), MathHelper.floor(this.posZ)));
         category.addCrashSection("Entity's Momentum", String.format("%.2f, %.2f, %.2f", this.motionX, this.motionY, this.motionZ));
-        category.addDetail("Entity's Passengers", new ICrashReportDetail<String>()
-        {
-            public String call() throws Exception
-            {
+        category.addDetail("Entity's Passengers", new ICrashReportDetail<String>() {
+            public String call() throws Exception {
                 return Entity.this.getPassengers().toString();
             }
         });
-        category.addDetail("Entity's Vehicle", new ICrashReportDetail<String>()
-        {
-            public String call() throws Exception
-            {
+        category.addDetail("Entity's Vehicle", new ICrashReportDetail<String>() {
+            public String call() throws Exception {
                 return Entity.this.getRidingEntity().toString();
             }
         });
     }
 
-    public void setUniqueId(UUID uniqueIdIn)
-    {
+    public void setUniqueId(UUID uniqueIdIn) {
         this.entityUniqueID = uniqueIdIn;
         this.cachedUniqueIdString = this.entityUniqueID.toString();
     }
 
     @SideOnly(Side.CLIENT)
-    public boolean canRenderOnFire()
-    {
+    public boolean canRenderOnFire() {
         return this.isBurning();
     }
 
-    public UUID getUniqueID()
-    {
+    public UUID getUniqueID() {
         return this.entityUniqueID;
     }
 
-    public String getCachedUniqueIdString()
-    {
+    public String getCachedUniqueIdString() {
         return this.cachedUniqueIdString;
     }
 
-    public boolean isPushedByWater()
-    {
+    public boolean isPushedByWater() {
         return true;
     }
 
     @SideOnly(Side.CLIENT)
-    public static double getRenderDistanceWeight()
-    {
+    public static double getRenderDistanceWeight() {
         return renderDistanceWeight;
     }
 
     @SideOnly(Side.CLIENT)
-    public static void setRenderDistanceWeight(double renderDistWeight)
-    {
+    public static void setRenderDistanceWeight(double renderDistWeight) {
         renderDistanceWeight = renderDistWeight;
     }
 
-    public ITextComponent getDisplayName()
-    {
+    public ITextComponent getDisplayName() {
         TextComponentString textcomponentstring = new TextComponentString(ScorePlayerTeam.formatPlayerName(this.getTeam(), this.getName()));
         textcomponentstring.getStyle().setHoverEvent(this.getHoverEvent());
         textcomponentstring.getStyle().setInsertion(this.getCachedUniqueIdString());
         return textcomponentstring;
     }
 
-    public void setCustomNameTag(String name)
-    {
+    public void setCustomNameTag(String name) {
+        // CraftBukkit start - Add a sane limit for name length
+        if (name.length() > 256) {
+            name = name.substring(0, 256);
+        }
+        // CraftBukkit end
         this.dataManager.set(CUSTOM_NAME, name);
     }
 
-    public String getCustomNameTag()
-    {
-        return (String)this.dataManager.get(CUSTOM_NAME);
+    public String getCustomNameTag() {
+        return (String) this.dataManager.get(CUSTOM_NAME);
     }
 
-    public boolean hasCustomName()
-    {
-        return !((String)this.dataManager.get(CUSTOM_NAME)).isEmpty();
+    public boolean hasCustomName() {
+        return !((String) this.dataManager.get(CUSTOM_NAME)).isEmpty();
     }
 
-    public void setAlwaysRenderNameTag(boolean alwaysRenderNameTag)
-    {
+    public void setAlwaysRenderNameTag(boolean alwaysRenderNameTag) {
         this.dataManager.set(CUSTOM_NAME_VISIBLE, Boolean.valueOf(alwaysRenderNameTag));
     }
 
-    public boolean getAlwaysRenderNameTag()
-    {
-        return ((Boolean)this.dataManager.get(CUSTOM_NAME_VISIBLE)).booleanValue();
+    public boolean getAlwaysRenderNameTag() {
+        return ((Boolean) this.dataManager.get(CUSTOM_NAME_VISIBLE)).booleanValue();
     }
 
-    public void setPositionAndUpdate(double x, double y, double z)
-    {
+    public void setPositionAndUpdate(double x, double y, double z) {
         this.isPositionDirty = true;
         this.setLocationAndAngles(x, y, z, this.rotationYaw, this.rotationPitch);
         this.world.updateEntityWithOptionalForce(this, false);
     }
 
-    public void notifyDataManagerChange(DataParameter<?> key)
-    {
+    public void notifyDataManagerChange(DataParameter<?> key) {
     }
 
     @SideOnly(Side.CLIENT)
-    public boolean getAlwaysRenderNameTagForRender()
-    {
+    public boolean getAlwaysRenderNameTagForRender() {
         return this.getAlwaysRenderNameTag();
     }
 
-    public EnumFacing getHorizontalFacing()
-    {
-        return EnumFacing.getHorizontal(MathHelper.floor((double)(this.rotationYaw * 4.0F / 360.0F) + 0.5D) & 3);
+    public EnumFacing getHorizontalFacing() {
+        return EnumFacing.getHorizontal(MathHelper.floor((double) (this.rotationYaw * 4.0F / 360.0F) + 0.5D) & 3);
     }
 
-    public EnumFacing getAdjustedHorizontalFacing()
-    {
+    public EnumFacing getAdjustedHorizontalFacing() {
         return this.getHorizontalFacing();
     }
 
-    protected HoverEvent getHoverEvent()
-    {
+    protected HoverEvent getHoverEvent() {
         NBTTagCompound nbttagcompound = new NBTTagCompound();
         ResourceLocation resourcelocation = EntityList.getKey(this);
         nbttagcompound.setString("id", this.getCachedUniqueIdString());
 
-        if (resourcelocation != null)
-        {
+        if (resourcelocation != null) {
             nbttagcompound.setString("type", resourcelocation.toString());
         }
 
@@ -2820,120 +2720,114 @@
         return new HoverEvent(HoverEvent.Action.SHOW_ENTITY, new TextComponentString(nbttagcompound.toString()));
     }
 
-    public boolean isSpectatedByPlayer(EntityPlayerMP player)
-    {
+    public boolean isSpectatedByPlayer(EntityPlayerMP player) {
         return true;
     }
 
-    public AxisAlignedBB getEntityBoundingBox()
-    {
+    public AxisAlignedBB getEntityBoundingBox() {
         return this.boundingBox;
     }
 
     @SideOnly(Side.CLIENT)
-    public AxisAlignedBB getRenderBoundingBox()
-    {
+    public AxisAlignedBB getRenderBoundingBox() {
         return this.getEntityBoundingBox();
     }
 
-    public void setEntityBoundingBox(AxisAlignedBB bb)
-    {
-        this.boundingBox = bb;
+    public void setEntityBoundingBox(AxisAlignedBB bb) {
+//        this.boundingBox = bb;
+        double a = bb.minX,
+                b = bb.minY,
+                c = bb.minZ,
+                d = bb.maxX,
+                e = bb.maxY,
+                f = bb.maxZ;
+        double len = bb.maxX - bb.minX;
+        if (len < 0) d = a;
+        if (len > 64) d = a + 64.0;
+
+        len = bb.maxY - bb.minY;
+        if (len < 0) e = b;
+        if (len > 64) e = b + 64.0;
+
+        len = bb.maxZ - bb.minZ;
+        if (len < 0) f = c;
+        if (len > 64) f = c + 64.0;
+        this.boundingBox = new AxisAlignedBB(a, b, c, d, e, f);
     }
 
-    public float getEyeHeight()
-    {
+    public float getEyeHeight() {
         return this.height * 0.85F;
     }
 
-    public boolean isOutsideBorder()
-    {
+    public boolean isOutsideBorder() {
         return this.isOutsideBorder;
     }
 
-    public void setOutsideBorder(boolean outsideBorder)
-    {
+    public void setOutsideBorder(boolean outsideBorder) {
         this.isOutsideBorder = outsideBorder;
     }
 
-    public boolean replaceItemInInventory(int inventorySlot, ItemStack itemStackIn)
-    {
+    public boolean replaceItemInInventory(int inventorySlot, ItemStack itemStackIn) {
         return false;
     }
 
-    public void sendMessage(ITextComponent component)
-    {
+    public void sendMessage(ITextComponent component) {
     }
 
-    public boolean canUseCommand(int permLevel, String commandName)
-    {
+    public boolean canUseCommand(int permLevel, String commandName) {
         return true;
     }
 
-    public BlockPos getPosition()
-    {
+    public BlockPos getPosition() {
         return new BlockPos(this.posX, this.posY + 0.5D, this.posZ);
     }
 
-    public Vec3d getPositionVector()
-    {
+    public Vec3d getPositionVector() {
         return new Vec3d(this.posX, this.posY, this.posZ);
     }
 
-    public World getEntityWorld()
-    {
+    public World getEntityWorld() {
         return this.world;
     }
 
-    public Entity getCommandSenderEntity()
-    {
+    public Entity getCommandSenderEntity() {
         return this;
     }
 
-    public boolean sendCommandFeedback()
-    {
+    public boolean sendCommandFeedback() {
         return false;
     }
 
-    public void setCommandStat(CommandResultStats.Type type, int amount)
-    {
-        if (this.world != null && !this.world.isRemote)
-        {
+    public void setCommandStat(CommandResultStats.Type type, int amount) {
+        if (this.world != null && !this.world.isRemote) {
             this.cmdResultStats.setCommandStatForSender(this.world.getMinecraftServer(), this, type, amount);
         }
     }
 
     @Nullable
-    public MinecraftServer getServer()
-    {
+    public MinecraftServer getServer() {
         return this.world.getMinecraftServer();
     }
 
-    public CommandResultStats getCommandStats()
-    {
+    public CommandResultStats getCommandStats() {
         return this.cmdResultStats;
     }
 
-    public void setCommandStats(Entity entityIn)
-    {
+    public void setCommandStats(Entity entityIn) {
         this.cmdResultStats.addAllStats(entityIn.getCommandStats());
     }
 
-    public EnumActionResult applyPlayerInteraction(EntityPlayer player, Vec3d vec, EnumHand hand)
-    {
+    public EnumActionResult applyPlayerInteraction(EntityPlayer player, Vec3d vec, EnumHand hand) {
         return EnumActionResult.PASS;
     }
 
-    public boolean isImmuneToExplosions()
-    {
+    public boolean isImmuneToExplosions() {
         return false;
     }
 
-    protected void applyEnchantments(EntityLivingBase entityLivingBaseIn, Entity entityIn)
-    {
-        if (entityIn instanceof EntityLivingBase)
-        {
-            EnchantmentHelper.applyThornEnchantments((EntityLivingBase)entityIn, entityLivingBaseIn);
+    protected void applyEnchantments(EntityLivingBase entityLivingBaseIn, Entity entityIn) {
+        if (entityIn instanceof EntityLivingBase) {
+            EnchantmentHelper.applyThornEnchantments((EntityLivingBase) entityIn, entityLivingBaseIn);
         }
 
         EnchantmentHelper.applyArthropodEnchantments(entityLivingBaseIn, entityIn);
@@ -2955,7 +2849,9 @@
      *
      * @return True if this entity is being tracked by a world
      */
-    public final boolean isAddedToWorld() { return this.isAddedToWorld; }
+    public final boolean isAddedToWorld() {
+        return this.isAddedToWorld;
+    }
 
     /**
      * Called after the entity has been added to the world's
@@ -2978,12 +2874,11 @@
     /**
      * Returns a NBTTagCompound that can be used to store custom data for this entity.
      * It will be written, and read from disc, so it persists over world saves.
+     *
      * @return A NBTTagCompound
      */
-    public NBTTagCompound getEntityData()
-    {
-        if (customEntityData == null)
-        {
+    public NBTTagCompound getEntityData() {
+        if (customEntityData == null) {
             customEntityData = new NBTTagCompound();
         }
         return customEntityData;
@@ -2991,10 +2886,10 @@
 
     /**
      * Used in model rendering to determine if the entity riding this entity should be in the 'sitting' position.
+     *
      * @return false to prevent an entity that is mounted to this entity from displaying the 'sitting' animation.
      */
-    public boolean shouldRiderSit()
-    {
+    public boolean shouldRiderSit() {
         return true;
     }
 
@@ -3004,49 +2899,29 @@
      * @param target The full target the player is looking at
      * @return A ItemStack to add to the player's inventory, empty ItemStack if nothing should be added.
      */
-    public ItemStack getPickedResult(RayTraceResult target)
-    {
-        if (this instanceof net.minecraft.entity.item.EntityPainting)
-        {
+    public ItemStack getPickedResult(RayTraceResult target) {
+        if (this instanceof net.minecraft.entity.item.EntityPainting) {
             return new ItemStack(net.minecraft.init.Items.PAINTING);
-        }
-        else if (this instanceof EntityLeashKnot)
-        {
+        } else if (this instanceof EntityLeashKnot) {
             return new ItemStack(net.minecraft.init.Items.LEAD);
-        }
-        else if (this instanceof net.minecraft.entity.item.EntityItemFrame)
-        {
-            ItemStack held = ((net.minecraft.entity.item.EntityItemFrame)this).getDisplayedItem();
-            if (held.isEmpty())
-            {
+        } else if (this instanceof net.minecraft.entity.item.EntityItemFrame) {
+            ItemStack held = ((net.minecraft.entity.item.EntityItemFrame) this).getDisplayedItem();
+            if (held.isEmpty()) {
                 return new ItemStack(net.minecraft.init.Items.ITEM_FRAME);
-            }
-            else
-            {
+            } else {
                 return held.copy();
             }
-        }
-        else if (this instanceof net.minecraft.entity.item.EntityMinecart)
-        {
-            return ((net.minecraft.entity.item.EntityMinecart)this).getCartItem();
-        }
-        else if (this instanceof net.minecraft.entity.item.EntityBoat)
-        {
-            return new ItemStack(((EntityBoat)this).getItemBoat());
-        }
-        else if (this instanceof net.minecraft.entity.item.EntityArmorStand)
-        {
+        } else if (this instanceof net.minecraft.entity.item.EntityMinecart) {
+            return ((net.minecraft.entity.item.EntityMinecart) this).getCartItem();
+        } else if (this instanceof EntityBoat) {
+            return new ItemStack(((EntityBoat) this).getItemBoat());
+        } else if (this instanceof net.minecraft.entity.item.EntityArmorStand) {
             return new ItemStack(net.minecraft.init.Items.ARMOR_STAND);
-        }
-        else if (this instanceof net.minecraft.entity.item.EntityEnderCrystal)
-        {
+        } else if (this instanceof net.minecraft.entity.item.EntityEnderCrystal) {
             return new ItemStack(net.minecraft.init.Items.END_CRYSTAL);
-        }
-        else
-        {
+        } else {
             ResourceLocation name = EntityList.getKey(this);
-            if (name != null && EntityList.ENTITY_EGGS.containsKey(name))
-            {
+            if (name != null && EntityList.ENTITY_EGGS.containsKey(name)) {
                 ItemStack stack = new ItemStack(net.minecraft.init.Items.SPAWN_EGG);
                 net.minecraft.item.ItemMonsterPlacer.applyEntityIdToItemStack(stack, name);
                 return stack;
@@ -3055,8 +2930,7 @@
         return ItemStack.EMPTY;
     }
 
-    public UUID getPersistentID()
-    {
+    public UUID getPersistentID() {
         return entityUniqueID;
     }
 
@@ -3064,25 +2938,24 @@
      * Reset the entity ID to a new value. Not to be used from Mod code
      */
     @Deprecated // TODO: remove (1.13?)
-    public final void resetEntityId()
-    {
+    public final void resetEntityId() {
         this.entityId = nextEntityID++;
     }
 
-    public boolean shouldRenderInPass(int pass)
-    {
+    public boolean shouldRenderInPass(int pass) {
         return pass == 0;
     }
 
     /**
      * Returns true if the entity is of the @link{EnumCreatureType} provided
-     * @param type The EnumCreatureType type this entity is evaluating
+     *
+     * @param type          The EnumCreatureType type this entity is evaluating
      * @param forSpawnCount If this is being invoked to check spawn count caps.
      * @return If the creature is of the type provided
      */
-    public boolean isCreatureType(EnumCreatureType type, boolean forSpawnCount)
-    {
-        if (forSpawnCount && (this instanceof EntityLiving) && ((EntityLiving)this).isNoDespawnRequired()) return false;
+    public boolean isCreatureType(EnumCreatureType type, boolean forSpawnCount) {
+        if (forSpawnCount && (this instanceof EntityLiving) && ((EntityLiving) this).isNoDespawnRequired())
+            return false;
         return type.getCreatureClass().isAssignableFrom(this.getClass());
     }
 
@@ -3092,8 +2965,7 @@
      *
      * @return if the entity can be interacted with from a rider
      */
-    public boolean canRiderInteract()
-    {
+    public boolean canRiderInteract() {
         return false;
     }
 
@@ -3103,31 +2975,26 @@
      * @param rider The entity that is riding
      * @return if the entity should be dismounted when under water
      */
-    public boolean shouldDismountInWater(Entity rider)
-    {
+    public boolean shouldDismountInWater(Entity rider) {
         return this instanceof EntityLivingBase;
     }
 
     @Override
-    public boolean hasCapability(net.minecraftforge.common.capabilities.Capability<?> capability, @Nullable net.minecraft.util.EnumFacing facing)
-    {
+    public boolean hasCapability(net.minecraftforge.common.capabilities.Capability<?> capability, @Nullable EnumFacing facing) {
         return capabilities != null && capabilities.hasCapability(capability, facing);
     }
 
     @Override
     @Nullable
-    public <T> T getCapability(net.minecraftforge.common.capabilities.Capability<T> capability, @Nullable net.minecraft.util.EnumFacing facing)
-    {
+    public <T> T getCapability(net.minecraftforge.common.capabilities.Capability<T> capability, @Nullable EnumFacing facing) {
         return capabilities == null ? null : capabilities.getCapability(capability, facing);
     }
 
-    public void deserializeNBT(NBTTagCompound nbt)
-    {
+    public void deserializeNBT(NBTTagCompound nbt) {
         this.readFromNBT(nbt);
     }
 
-    public NBTTagCompound serializeNBT()
-    {
+    public NBTTagCompound serializeNBT() {
         NBTTagCompound ret = new NBTTagCompound();
         ret.setString("id", this.getEntityString());
         return this.writeToNBT(ret);
@@ -3136,35 +3003,30 @@
     /**
      * Checks if this {@link Entity} can trample a {@link Block}.
      *
-     * @param world The world in which the block will be trampled
-     * @param block The block being tested
-     * @param pos The block pos
+     * @param world        The world in which the block will be trampled
+     * @param block        The block being tested
+     * @param pos          The block pos
      * @param fallDistance The fall distance
      * @return {@code true} if this entity can trample, {@code false} otherwise
      */
-    public boolean canTrample(World world, Block block, BlockPos pos, float fallDistance)
-    {
+    public boolean canTrample(World world, Block block, BlockPos pos, float fallDistance) {
         return world.rand.nextFloat() < fallDistance - 0.5F
-            && this instanceof EntityLivingBase
-            && (this instanceof EntityPlayer || net.minecraftforge.event.ForgeEventFactory.getMobGriefingEvent(world, this))
-            && this.width * this.width * this.height > 0.512F;
+                && this instanceof EntityLivingBase
+                && (this instanceof EntityPlayer || net.minecraftforge.event.ForgeEventFactory.getMobGriefingEvent(world, this))
+                && this.width * this.width * this.height > 0.512F;
     }
     /* ================================== Forge End =====================================*/
 
-    public void addTrackingPlayer(EntityPlayerMP player)
-    {
+    public void addTrackingPlayer(EntityPlayerMP player) {
     }
 
-    public void removeTrackingPlayer(EntityPlayerMP player)
-    {
+    public void removeTrackingPlayer(EntityPlayerMP player) {
     }
 
-    public float getRotatedYaw(Rotation transformRotation)
-    {
+    public float getRotatedYaw(Rotation transformRotation) {
         float f = MathHelper.wrapDegrees(this.rotationYaw);
 
-        switch (transformRotation)
-        {
+        switch (transformRotation) {
             case CLOCKWISE_180:
                 return f + 180.0F;
             case COUNTERCLOCKWISE_90:
@@ -3176,12 +3038,10 @@
         }
     }
 
-    public float getMirroredYaw(Mirror transformMirror)
-    {
+    public float getMirroredYaw(Mirror transformMirror) {
         float f = MathHelper.wrapDegrees(this.rotationYaw);
 
-        switch (transformMirror)
-        {
+        switch (transformMirror) {
             case LEFT_RIGHT:
                 return -f;
             case FRONT_BACK:
@@ -3191,35 +3051,28 @@
         }
     }
 
-    public boolean ignoreItemEntityData()
-    {
+    public boolean ignoreItemEntityData() {
         return false;
     }
 
-    public boolean setPositionNonDirty()
-    {
+    public boolean setPositionNonDirty() {
         boolean flag = this.isPositionDirty;
         this.isPositionDirty = false;
         return flag;
     }
 
     @Nullable
-    public Entity getControllingPassenger()
-    {
+    public Entity getControllingPassenger() {
         return null;
     }
 
-    public List<Entity> getPassengers()
-    {
-        return (List<Entity>)(this.riddenByEntities.isEmpty() ? Collections.emptyList() : Lists.newArrayList(this.riddenByEntities));
+    public List<Entity> getPassengers() {
+        return (List<Entity>) (this.riddenByEntities.isEmpty() ? Collections.emptyList() : Lists.newArrayList(this.riddenByEntities));
     }
 
-    public boolean isPassenger(Entity entityIn)
-    {
-        for (Entity entity : this.getPassengers())
-        {
-            if (entity.equals(entityIn))
-            {
+    public boolean isPassenger(Entity entityIn) {
+        for (Entity entity : this.getPassengers()) {
+            if (entity.equals(entityIn)) {
                 return true;
             }
         }
@@ -3227,61 +3080,49 @@
         return false;
     }
 
-    public Collection<Entity> getRecursivePassengers()
-    {
+    public Collection<Entity> getRecursivePassengers() {
         Set<Entity> set = Sets.<Entity>newHashSet();
         this.getRecursivePassengersByType(Entity.class, set);
         return set;
     }
 
-    public <T extends Entity> Collection<T> getRecursivePassengersByType(Class<T> entityClass)
-    {
+    public <T extends Entity> Collection<T> getRecursivePassengersByType(Class<T> entityClass) {
         Set<T> set = Sets.<T>newHashSet();
         this.getRecursivePassengersByType(entityClass, set);
         return set;
     }
 
-    private <T extends Entity> void getRecursivePassengersByType(Class<T> entityClass, Set<T> theSet)
-    {
-        for (Entity entity : this.getPassengers())
-        {
-            if (entityClass.isAssignableFrom(entity.getClass()))
-            {
-                theSet.add((T)entity);
+    private <T extends Entity> void getRecursivePassengersByType(Class<T> entityClass, Set<T> theSet) {
+        for (Entity entity : this.getPassengers()) {
+            if (entityClass.isAssignableFrom(entity.getClass())) {
+                theSet.add((T) entity);
             }
 
             entity.getRecursivePassengersByType(entityClass, theSet);
         }
     }
 
-    public Entity getLowestRidingEntity()
-    {
+    public Entity getLowestRidingEntity() {
         Entity entity;
 
-        for (entity = this; entity.isRiding(); entity = entity.getRidingEntity())
-        {
+        for (entity = this; entity.isRiding(); entity = entity.getRidingEntity()) {
             ;
         }
 
         return entity;
     }
 
-    public boolean isRidingSameEntity(Entity entityIn)
-    {
+    public boolean isRidingSameEntity(Entity entityIn) {
         return this.getLowestRidingEntity() == entityIn.getLowestRidingEntity();
     }
 
-    public boolean isRidingOrBeingRiddenBy(Entity entityIn)
-    {
-        for (Entity entity : this.getPassengers())
-        {
-            if (entity.equals(entityIn))
-            {
+    public boolean isRidingOrBeingRiddenBy(Entity entityIn) {
+        for (Entity entity : this.getPassengers()) {
+            if (entity.equals(entityIn)) {
                 return true;
             }
 
-            if (entity.isRidingOrBeingRiddenBy(entityIn))
-            {
+            if (entity.isRidingOrBeingRiddenBy(entityIn)) {
                 return true;
             }
         }
@@ -3289,38 +3130,30 @@
         return false;
     }
 
-    public boolean canPassengerSteer()
-    {
+    public boolean canPassengerSteer() {
         Entity entity = this.getControllingPassenger();
 
-        if (entity instanceof EntityPlayer)
-        {
-            return ((EntityPlayer)entity).isUser();
-        }
-        else
-        {
+        if (entity instanceof EntityPlayer) {
+            return ((EntityPlayer) entity).isUser();
+        } else {
             return !this.world.isRemote;
         }
     }
 
     @Nullable
-    public Entity getRidingEntity()
-    {
+    public Entity getRidingEntity() {
         return this.ridingEntity;
     }
 
-    public EnumPushReaction getPushReaction()
-    {
+    public EnumPushReaction getPushReaction() {
         return EnumPushReaction.NORMAL;
     }
 
-    public SoundCategory getSoundCategory()
-    {
+    public SoundCategory getSoundCategory() {
         return SoundCategory.NEUTRAL;
     }
 
-    protected int getFireImmuneTicks()
-    {
+    public int getFireImmuneTicks() {
         return 1;
     }
 }
