--- ../src-base/minecraft/net/minecraft/world/chunk/Chunk.java
+++ ../src-work/minecraft/net/minecraft/world/chunk/Chunk.java
@@ -3,20 +3,18 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import javax.annotation.Nullable;
+import gnu.trove.map.hash.TObjectIntHashMap;
 import net.minecraft.block.Block;
-import net.minecraft.block.ITileEntityProvider;
+import net.minecraft.block.BlockSand;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EnumCreatureType;
+import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.init.Biomes;
 import net.minecraft.init.Blocks;
 import net.minecraft.network.PacketBuffer;
@@ -40,9 +38,18 @@
 import net.minecraftforge.fml.relauncher.SideOnly;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.Server;
+import org.bukkit.craftbukkit.CraftChunk;
 
-public class Chunk implements net.minecraftforge.common.capabilities.ICapabilityProvider
-{
+import javax.annotation.Nullable;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.stream.Collectors;
+
+public class Chunk implements net.minecraftforge.common.capabilities.ICapabilityProvider {
     private static final Logger LOGGER = LogManager.getLogger();
     public static final ExtendedBlockStorage NULL_BLOCK_STORAGE = null;
     private final ExtendedBlockStorage[] storageArrays;
@@ -50,13 +57,13 @@
     private final int[] precipitationHeightMap;
     private final boolean[] updateSkylightColumns;
     private boolean loaded;
-    private final World world;
-    private final int[] heightMap;
+    public final World world;
+    public final int[] heightMap;
     public final int x;
     public final int z;
     private boolean isGapLightingUpdated;
-    private final Map<BlockPos, TileEntity> tileEntities;
-    private final ClassInheritanceMultiMap<Entity>[] entityLists;
+    public final Map<BlockPos, TileEntity> tileEntities;
+    public final ClassInheritanceMultiMap<Entity>[] entityLists; // Spigot
     private boolean isTerrainPopulated;
     private boolean isLightPopulated;
     private boolean ticked;
@@ -68,9 +75,37 @@
     private int queuedLightChecks;
     private final ConcurrentLinkedQueue<BlockPos> tileEntityPosQueue;
     public boolean unloadQueued;
+    public TObjectIntHashMap<Class> entityCount = new TObjectIntHashMap<>(); // Spigot
+    // CraftBukkit start - Neighbor loaded cache for chunk lighting and entity ticking
+    private int neighbors = 0x1 << 12;
+    public long chunkKey;
 
-    public Chunk(World worldIn, int x, int z)
-    {
+    public boolean areNeighborsLoaded(final int radius) {
+        switch (radius) {
+            case 2:
+                return this.neighbors == Integer.MAX_VALUE >> 6;
+            case 1:
+                final int mask =
+                        //       x        z   offset          x        z   offset          x         z   offset
+                        (0x1 << (1 * 5 + 1 + 12)) | (0x1 << (0 * 5 + 1 + 12)) | (0x1 << (-1 * 5 + 1 + 12)) |
+                                (0x1 << (1 * 5 + 0 + 12)) | (0x1 << (0 * 5 + 0 + 12)) | (0x1 << (-1 * 5 + 0 + 12)) |
+                                (0x1 << (1 * 5 + -1 + 12)) | (0x1 << (0 * 5 + -1 + 12)) | (0x1 << (-1 * 5 + -1 + 12));
+                return (this.neighbors & mask) == mask;
+            default:
+                throw new UnsupportedOperationException(String.valueOf(radius));
+        }
+    }
+
+    public void setNeighborLoaded(final int x, final int z) {
+        this.neighbors |= 0x1 << (x * 5 + 12 + z);
+    }
+
+    public void setNeighborUnloaded(final int x, final int z) {
+        this.neighbors &= ~(0x1 << (x * 5 + 12 + z));
+    }
+    // CraftBukkit end
+
+    public Chunk(World worldIn, int x, int z) {
         this.storageArrays = new ExtendedBlockStorage[16];
         this.blockBiomeArray = new byte[256];
         this.precipitationHeightMap = new int[256];
@@ -78,42 +113,40 @@
         this.tileEntities = Maps.<BlockPos, TileEntity>newHashMap();
         this.queuedLightChecks = 4096;
         this.tileEntityPosQueue = Queues.<BlockPos>newConcurrentLinkedQueue();
-        this.entityLists = (ClassInheritanceMultiMap[])(new ClassInheritanceMultiMap[16]);
+        this.entityLists = (ClassInheritanceMultiMap[]) (new ClassInheritanceMultiMap[16]);
         this.world = worldIn;
         this.x = x;
         this.z = z;
         this.heightMap = new int[256];
 
-        for (int i = 0; i < this.entityLists.length; ++i)
-        {
+        for (int i = 0; i < this.entityLists.length; ++i) {
             this.entityLists[i] = new ClassInheritanceMultiMap(Entity.class);
         }
 
         Arrays.fill(this.precipitationHeightMap, -999);
-        Arrays.fill(this.blockBiomeArray, (byte) - 1);
+        Arrays.fill(this.blockBiomeArray, (byte) -1);
         capabilities = net.minecraftforge.event.ForgeEventFactory.gatherCapabilities(this);
+        this.bukkitChunk = new CraftChunk(this);
+        this.chunkKey = ChunkPos.asLong(this.x, this.z);
     }
 
-    public Chunk(World worldIn, ChunkPrimer primer, int x, int z)
-    {
+    public org.bukkit.Chunk bukkitChunk;
+    public boolean mustSave;
+
+    public Chunk(World worldIn, ChunkPrimer primer, int x, int z) {
         this(worldIn, x, z);
         int i = 256;
         boolean flag = worldIn.provider.hasSkyLight();
 
-        for (int j = 0; j < 16; ++j)
-        {
-            for (int k = 0; k < 16; ++k)
-            {
-                for (int l = 0; l < 256; ++l)
-                {
+        for (int j = 0; j < 16; ++j) {
+            for (int k = 0; k < 16; ++k) {
+                for (int l = 0; l < 256; ++l) {
                     IBlockState iblockstate = primer.getBlockState(j, l, k);
 
-                    if (iblockstate.getMaterial() != Material.AIR)
-                    {
+                    if (iblockstate.getMaterial() != Material.AIR) {
                         int i1 = l >> 4;
 
-                        if (this.storageArrays[i1] == NULL_BLOCK_STORAGE)
-                        {
+                        if (this.storageArrays[i1] == NULL_BLOCK_STORAGE) {
                             this.storageArrays[i1] = new ExtendedBlockStorage(i1 << 4, flag);
                         }
 
@@ -124,28 +157,22 @@
         }
     }
 
-    public boolean isAtLocation(int x, int z)
-    {
+    public boolean isAtLocation(int x, int z) {
         return x == this.x && z == this.z;
     }
 
-    public int getHeight(BlockPos pos)
-    {
+    public int getHeight(BlockPos pos) {
         return this.getHeightValue(pos.getX() & 15, pos.getZ() & 15);
     }
 
-    public int getHeightValue(int x, int z)
-    {
+    public int getHeightValue(int x, int z) {
         return this.heightMap[z << 4 | x];
     }
 
     @Nullable
-    private ExtendedBlockStorage getLastExtendedBlockStorage()
-    {
-        for (int i = this.storageArrays.length - 1; i >= 0; --i)
-        {
-            if (this.storageArrays[i] != NULL_BLOCK_STORAGE)
-            {
+    private ExtendedBlockStorage getLastExtendedBlockStorage() {
+        for (int i = this.storageArrays.length - 1; i >= 0; --i) {
+            if (this.storageArrays[i] != NULL_BLOCK_STORAGE) {
                 return this.storageArrays[i];
             }
         }
@@ -153,39 +180,31 @@
         return null;
     }
 
-    public int getTopFilledSegment()
-    {
+    public int getTopFilledSegment() {
         ExtendedBlockStorage extendedblockstorage = this.getLastExtendedBlockStorage();
         return extendedblockstorage == null ? 0 : extendedblockstorage.getYLocation();
     }
 
-    public ExtendedBlockStorage[] getBlockStorageArray()
-    {
+    public ExtendedBlockStorage[] getBlockStorageArray() {
         return this.storageArrays;
     }
 
     @SideOnly(Side.CLIENT)
-    protected void generateHeightMap()
-    {
+    protected void generateHeightMap() {
         int i = this.getTopFilledSegment();
         this.heightMapMinimum = Integer.MAX_VALUE;
 
-        for (int j = 0; j < 16; ++j)
-        {
-            for (int k = 0; k < 16; ++k)
-            {
+        for (int j = 0; j < 16; ++j) {
+            for (int k = 0; k < 16; ++k) {
                 this.precipitationHeightMap[j + (k << 4)] = -999;
 
-                for (int l = i + 16; l > 0; --l)
-                {
+                for (int l = i + 16; l > 0; --l) {
                     IBlockState iblockstate = this.getBlockState(j, l - 1, k);
 
-                    if (this.getBlockLightOpacity(j, l - 1, k) != 0)
-                    {
+                    if (this.getBlockLightOpacity(j, l - 1, k) != 0) {
                         this.heightMap[k << 4 | j] = l;
 
-                        if (l < this.heightMapMinimum)
-                        {
+                        if (l < this.heightMapMinimum) {
                             this.heightMapMinimum = l;
                         }
 
@@ -198,25 +217,19 @@
         this.dirty = true;
     }
 
-    public void generateSkylightMap()
-    {
+    public void generateSkylightMap() {
         int i = this.getTopFilledSegment();
         this.heightMapMinimum = Integer.MAX_VALUE;
 
-        for (int j = 0; j < 16; ++j)
-        {
-            for (int k = 0; k < 16; ++k)
-            {
+        for (int j = 0; j < 16; ++j) {
+            for (int k = 0; k < 16; ++k) {
                 this.precipitationHeightMap[j + (k << 4)] = -999;
 
-                for (int l = i + 16; l > 0; --l)
-                {
-                    if (this.getBlockLightOpacity(j, l - 1, k) != 0)
-                    {
+                for (int l = i + 16; l > 0; --l) {
+                    if (this.getBlockLightOpacity(j, l - 1, k) != 0) {
                         this.heightMap[k << 4 | j] = l;
 
-                        if (l < this.heightMapMinimum)
-                        {
+                        if (l < this.heightMapMinimum) {
                             this.heightMapMinimum = l;
                         }
 
@@ -224,28 +237,23 @@
                     }
                 }
 
-                if (this.world.provider.hasSkyLight())
-                {
+                if (this.world.provider.hasSkyLight()) {
                     int k1 = 15;
                     int i1 = i + 16 - 1;
 
-                    while (true)
-                    {
+                    while (true) {
                         int j1 = this.getBlockLightOpacity(j, i1, k);
 
-                        if (j1 == 0 && k1 != 15)
-                        {
+                        if (j1 == 0 && k1 != 15) {
                             j1 = 1;
                         }
 
                         k1 -= j1;
 
-                        if (k1 > 0)
-                        {
+                        if (k1 > 0) {
                             ExtendedBlockStorage extendedblockstorage = this.storageArrays[i1 >> 4];
 
-                            if (extendedblockstorage != NULL_BLOCK_STORAGE)
-                            {
+                            if (extendedblockstorage != NULL_BLOCK_STORAGE) {
                                 extendedblockstorage.setSkyLight(j, i1 & 15, k, k1);
                                 this.world.notifyLightSet(new BlockPos((this.x << 4) + j, i1, (this.z << 4) + k));
                             }
@@ -253,8 +261,7 @@
 
                         --i1;
 
-                        if (i1 <= 0 || k1 <= 0)
-                        {
+                        if (i1 <= 0 || k1 <= 0) {
                             break;
                         }
                     }
@@ -265,44 +272,35 @@
         this.dirty = true;
     }
 
-    private void propagateSkylightOcclusion(int x, int z)
-    {
+    private void propagateSkylightOcclusion(int x, int z) {
         this.updateSkylightColumns[x + z * 16] = true;
         this.isGapLightingUpdated = true;
     }
 
-    private void recheckGaps(boolean onlyOne)
-    {
+    private void recheckGaps(boolean onlyOne) {
         this.world.profiler.startSection("recheckGaps");
 
-        if (this.world.isAreaLoaded(new BlockPos(this.x * 16 + 8, 0, this.z * 16 + 8), 16))
-        {
-            for (int i = 0; i < 16; ++i)
-            {
-                for (int j = 0; j < 16; ++j)
-                {
-                    if (this.updateSkylightColumns[i + j * 16])
-                    {
+        if (this.world.isAreaLoaded(new BlockPos(this.x * 16 + 8, 0, this.z * 16 + 8), 16)) {
+            for (int i = 0; i < 16; ++i) {
+                for (int j = 0; j < 16; ++j) {
+                    if (this.updateSkylightColumns[i + j * 16]) {
                         this.updateSkylightColumns[i + j * 16] = false;
                         int k = this.getHeightValue(i, j);
                         int l = this.x * 16 + i;
                         int i1 = this.z * 16 + j;
                         int j1 = Integer.MAX_VALUE;
 
-                        for (EnumFacing enumfacing : EnumFacing.Plane.HORIZONTAL)
-                        {
+                        for (EnumFacing enumfacing : EnumFacing.Plane.HORIZONTAL) {
                             j1 = Math.min(j1, this.world.getChunksLowestHorizon(l + enumfacing.getFrontOffsetX(), i1 + enumfacing.getFrontOffsetZ()));
                         }
 
                         this.checkSkylightNeighborHeight(l, i1, j1);
 
-                        for (EnumFacing enumfacing1 : EnumFacing.Plane.HORIZONTAL)
-                        {
+                        for (EnumFacing enumfacing1 : EnumFacing.Plane.HORIZONTAL) {
                             this.checkSkylightNeighborHeight(l + enumfacing1.getFrontOffsetX(), i1 + enumfacing1.getFrontOffsetZ(), k);
                         }
 
-                        if (onlyOne)
-                        {
+                        if (onlyOne) {
                             this.world.profiler.endSection();
                             return;
                         }
@@ -316,26 +314,19 @@
         this.world.profiler.endSection();
     }
 
-    private void checkSkylightNeighborHeight(int x, int z, int maxValue)
-    {
+    private void checkSkylightNeighborHeight(int x, int z, int maxValue) {
         int i = this.world.getHeight(new BlockPos(x, 0, z)).getY();
 
-        if (i > maxValue)
-        {
+        if (i > maxValue) {
             this.updateSkylightNeighborHeight(x, z, maxValue, i + 1);
-        }
-        else if (i < maxValue)
-        {
+        } else if (i < maxValue) {
             this.updateSkylightNeighborHeight(x, z, i, maxValue + 1);
         }
     }
 
-    private void updateSkylightNeighborHeight(int x, int z, int startY, int endY)
-    {
-        if (endY > startY && this.world.isAreaLoaded(new BlockPos(x, 0, z), 16))
-        {
-            for (int i = startY; i < endY; ++i)
-            {
+    private void updateSkylightNeighborHeight(int x, int z, int startY, int endY) {
+        if (endY > startY && this.world.isAreaLoaded(new BlockPos(x, 0, z), 16)) {
+            for (int i = startY; i < endY; ++i) {
                 this.world.checkLightFor(EnumSkyBlock.SKY, new BlockPos(x, i, z));
             }
 
@@ -343,51 +334,39 @@
         }
     }
 
-    private void relightBlock(int x, int y, int z)
-    {
+    private void relightBlock(int x, int y, int z) {
         int i = this.heightMap[z << 4 | x] & 255;
         int j = i;
 
-        if (y > i)
-        {
+        if (y > i) {
             j = y;
         }
 
-        while (j > 0 && this.getBlockLightOpacity(x, j - 1, z) == 0)
-        {
+        while (j > 0 && this.getBlockLightOpacity(x, j - 1, z) == 0) {
             --j;
         }
 
-        if (j != i)
-        {
+        if (j != i) {
             this.world.markBlocksDirtyVertical(x + this.x * 16, z + this.z * 16, j, i);
             this.heightMap[z << 4 | x] = j;
             int k = this.x * 16 + x;
             int l = this.z * 16 + z;
 
-            if (this.world.provider.hasSkyLight())
-            {
-                if (j < i)
-                {
-                    for (int j1 = j; j1 < i; ++j1)
-                    {
+            if (this.world.provider.hasSkyLight()) {
+                if (j < i) {
+                    for (int j1 = j; j1 < i; ++j1) {
                         ExtendedBlockStorage extendedblockstorage2 = this.storageArrays[j1 >> 4];
 
-                        if (extendedblockstorage2 != NULL_BLOCK_STORAGE)
-                        {
+                        if (extendedblockstorage2 != NULL_BLOCK_STORAGE) {
                             extendedblockstorage2.setSkyLight(x, j1 & 15, z, 15);
                             this.world.notifyLightSet(new BlockPos((this.x << 4) + x, j1, (this.z << 4) + z));
                         }
                     }
-                }
-                else
-                {
-                    for (int i1 = i; i1 < j; ++i1)
-                    {
+                } else {
+                    for (int i1 = i; i1 < j; ++i1) {
                         ExtendedBlockStorage extendedblockstorage = this.storageArrays[i1 >> 4];
 
-                        if (extendedblockstorage != NULL_BLOCK_STORAGE)
-                        {
+                        if (extendedblockstorage != NULL_BLOCK_STORAGE) {
                             extendedblockstorage.setSkyLight(x, i1 & 15, z, 0);
                             this.world.notifyLightSet(new BlockPos((this.x << 4) + x, i1, (this.z << 4) + z));
                         }
@@ -396,27 +375,23 @@
 
                 int k1 = 15;
 
-                while (j > 0 && k1 > 0)
-                {
+                while (j > 0 && k1 > 0) {
                     --j;
                     int i2 = this.getBlockLightOpacity(x, j, z);
 
-                    if (i2 == 0)
-                    {
+                    if (i2 == 0) {
                         i2 = 1;
                     }
 
                     k1 -= i2;
 
-                    if (k1 < 0)
-                    {
+                    if (k1 < 0) {
                         k1 = 0;
                     }
 
                     ExtendedBlockStorage extendedblockstorage1 = this.storageArrays[j >> 4];
 
-                    if (extendedblockstorage1 != NULL_BLOCK_STORAGE)
-                    {
+                    if (extendedblockstorage1 != NULL_BLOCK_STORAGE) {
                         extendedblockstorage1.setSkyLight(x, j & 15, z, k1);
                     }
                 }
@@ -426,21 +401,17 @@
             int j2 = i;
             int k2 = l1;
 
-            if (l1 < i)
-            {
+            if (l1 < i) {
                 j2 = l1;
                 k2 = i;
             }
 
-            if (l1 < this.heightMapMinimum)
-            {
+            if (l1 < this.heightMapMinimum) {
                 this.heightMapMinimum = l1;
             }
 
-            if (this.world.provider.hasSkyLight())
-            {
-                for (EnumFacing enumfacing : EnumFacing.Plane.HORIZONTAL)
-                {
+            if (this.world.provider.hasSkyLight()) {
+                for (EnumFacing enumfacing : EnumFacing.Plane.HORIZONTAL) {
                     this.updateSkylightNeighborHeight(k + enumfacing.getFrontOffsetX(), l + enumfacing.getFrontOffsetZ(), j2, k2);
                 }
 
@@ -451,64 +422,48 @@
         }
     }
 
-    public int getBlockLightOpacity(BlockPos pos)
-    {
+    public int getBlockLightOpacity(BlockPos pos) {
         return this.getBlockState(pos).getLightOpacity(this.world, pos);
     }
 
-    private int getBlockLightOpacity(int x, int y, int z)
-    {
+    private int getBlockLightOpacity(int x, int y, int z) {
         IBlockState state = this.getBlockState(x, y, z); //Forge: Can sometimes be called before we are added to the global world list. So use the less accurate one during that. It'll be recalculated later
         return !loaded ? state.getLightOpacity() : state.getLightOpacity(world, new BlockPos(this.x << 4 | x & 15, y, this.z << 4 | z & 15));
     }
 
-    public IBlockState getBlockState(BlockPos pos)
-    {
+    public IBlockState getBlockState(BlockPos pos) {
         return this.getBlockState(pos.getX(), pos.getY(), pos.getZ());
     }
 
-    public IBlockState getBlockState(final int x, final int y, final int z)
-    {
-        if (this.world.getWorldType() == WorldType.DEBUG_ALL_BLOCK_STATES)
-        {
+    public IBlockState getBlockState(final int x, final int y, final int z) {
+        if (this.world.getWorldType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             IBlockState iblockstate = null;
 
-            if (y == 60)
-            {
+            if (y == 60) {
                 iblockstate = Blocks.BARRIER.getDefaultState();
             }
 
-            if (y == 70)
-            {
+            if (y == 70) {
                 iblockstate = ChunkGeneratorDebug.getBlockStateFor(x, z);
             }
 
             return iblockstate == null ? Blocks.AIR.getDefaultState() : iblockstate;
-        }
-        else
-        {
-            try
-            {
-                if (y >= 0 && y >> 4 < this.storageArrays.length)
-                {
+        } else {
+            try {
+                if (y >= 0 && y >> 4 < this.storageArrays.length) {
                     ExtendedBlockStorage extendedblockstorage = this.storageArrays[y >> 4];
 
-                    if (extendedblockstorage != NULL_BLOCK_STORAGE)
-                    {
+                    if (extendedblockstorage != NULL_BLOCK_STORAGE) {
                         return extendedblockstorage.get(x & 15, y & 15, z & 15);
                     }
                 }
 
                 return Blocks.AIR.getDefaultState();
-            }
-            catch (Throwable throwable)
-            {
+            } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Getting block state");
                 CrashReportCategory crashreportcategory = crashreport.makeCategory("Block being got");
-                crashreportcategory.addDetail("Location", new ICrashReportDetail<String>()
-                {
-                    public String call() throws Exception
-                    {
+                crashreportcategory.addDetail("Location", new ICrashReportDetail<String>() {
+                    public String call() throws Exception {
                         return CrashReportCategory.getCoordinateInfo(x, y, z);
                     }
                 });
@@ -518,37 +473,30 @@
     }
 
     @Nullable
-    public IBlockState setBlockState(BlockPos pos, IBlockState state)
-    {
+    public IBlockState setBlockState(BlockPos pos, IBlockState state) {
         int i = pos.getX() & 15;
         int j = pos.getY();
         int k = pos.getZ() & 15;
         int l = k << 4 | i;
 
-        if (j >= this.precipitationHeightMap[l] - 1)
-        {
+        if (j >= this.precipitationHeightMap[l] - 1) {
             this.precipitationHeightMap[l] = -999;
         }
 
         int i1 = this.heightMap[l];
         IBlockState iblockstate = this.getBlockState(pos);
 
-        if (iblockstate == state)
-        {
+        if (iblockstate == state) {
             return null;
-        }
-        else
-        {
+        } else {
             Block block = state.getBlock();
             Block block1 = iblockstate.getBlock();
             int k1 = iblockstate.getLightOpacity(this.world, pos); // Relocate old light value lookup here, so that it is called before TE is removed.
             ExtendedBlockStorage extendedblockstorage = this.storageArrays[j >> 4];
             boolean flag = false;
 
-            if (extendedblockstorage == NULL_BLOCK_STORAGE)
-            {
-                if (block == Blocks.AIR)
-                {
+            if (extendedblockstorage == NULL_BLOCK_STORAGE) {
+                if (block == Blocks.AIR) {
                     return null;
                 }
 
@@ -561,71 +509,55 @@
 
             //if (block1 != block)
             {
-                if (!this.world.isRemote)
-                {
+                if (!this.world.isRemote) {
                     if (block1 != block) //Only fire block breaks when the block changes.
-                    block1.breakBlock(this.world, pos, iblockstate);
+                        block1.breakBlock(this.world, pos, iblockstate);
                     TileEntity te = this.getTileEntity(pos, Chunk.EnumCreateEntityType.CHECK);
-                    if (te != null && te.shouldRefresh(this.world, pos, iblockstate, state)) this.world.removeTileEntity(pos);
-                }
-                else if (block1.hasTileEntity(iblockstate))
-                {
+                    if (te != null && te.shouldRefresh(this.world, pos, iblockstate, state))
+                        this.world.removeTileEntity(pos);
+                } else if (block1.hasTileEntity(iblockstate)) {
                     TileEntity te = this.getTileEntity(pos, Chunk.EnumCreateEntityType.CHECK);
                     if (te != null && te.shouldRefresh(this.world, pos, iblockstate, state))
-                    this.world.removeTileEntity(pos);
+                        this.world.removeTileEntity(pos);
                 }
             }
 
-            if (extendedblockstorage.get(i, j & 15, k).getBlock() != block)
-            {
+            if (extendedblockstorage.get(i, j & 15, k).getBlock() != block) {
                 return null;
-            }
-            else
-            {
-                if (flag)
-                {
+            } else {
+                if (flag) {
                     this.generateSkylightMap();
-                }
-                else
-                {
+                } else {
                     int j1 = state.getLightOpacity(this.world, pos);
 
-                    if (j1 > 0)
-                    {
-                        if (j >= i1)
-                        {
+                    if (j1 > 0) {
+                        if (j >= i1) {
                             this.relightBlock(i, j + 1, k);
                         }
-                    }
-                    else if (j == i1 - 1)
-                    {
+                    } else if (j == i1 - 1) {
                         this.relightBlock(i, j, k);
                     }
 
-                    if (j1 != k1 && (j1 < k1 || this.getLightFor(EnumSkyBlock.SKY, pos) > 0 || this.getLightFor(EnumSkyBlock.BLOCK, pos) > 0))
-                    {
+                    if (j1 != k1 && (j1 < k1 || this.getLightFor(EnumSkyBlock.SKY, pos) > 0 || this.getLightFor(EnumSkyBlock.BLOCK, pos) > 0)) {
                         this.propagateSkylightOcclusion(i, k);
                     }
                 }
 
+                // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
                 // If capturing blocks, only run block physics for TE's. Non-TE's are handled in ForgeHooks.onPlaceItemIntoWorld
-                if (!this.world.isRemote && block1 != block && (!this.world.captureBlockSnapshots || block.hasTileEntity(state)))
-                {
+                if (!this.world.isRemote && block1 != block && (!this.world.captureBlockSnapshots || block.hasTileEntity(state))) {
                     block.onBlockAdded(this.world, pos, state);
                 }
 
-                if (block.hasTileEntity(state))
-                {
+                if (block.hasTileEntity(state)) {
                     TileEntity tileentity1 = this.getTileEntity(pos, Chunk.EnumCreateEntityType.CHECK);
 
-                    if (tileentity1 == null)
-                    {
+                    if (tileentity1 == null) {
                         tileentity1 = block.createTileEntity(this.world, state);
                         this.world.setTileEntity(pos, tileentity1);
                     }
 
-                    if (tileentity1 != null)
-                    {
+                    if (tileentity1 != null) {
                         tileentity1.updateContainingBlockInfo();
                     }
                 }
@@ -636,36 +568,28 @@
         }
     }
 
-    public int getLightFor(EnumSkyBlock type, BlockPos pos)
-    {
+    public int getLightFor(EnumSkyBlock type, BlockPos pos) {
         int i = pos.getX() & 15;
         int j = pos.getY();
         int k = pos.getZ() & 15;
         ExtendedBlockStorage extendedblockstorage = this.storageArrays[j >> 4];
 
-        if (extendedblockstorage == NULL_BLOCK_STORAGE)
-        {
+        if (extendedblockstorage == NULL_BLOCK_STORAGE) {
             return this.canSeeSky(pos) ? type.defaultLightValue : 0;
-        }
-        else if (type == EnumSkyBlock.SKY)
-        {
+        } else if (type == EnumSkyBlock.SKY) {
             return !this.world.provider.hasSkyLight() ? 0 : extendedblockstorage.getSkyLight(i, j & 15, k);
-        }
-        else
-        {
+        } else {
             return type == EnumSkyBlock.BLOCK ? extendedblockstorage.getBlockLight(i, j & 15, k) : type.defaultLightValue;
         }
     }
 
-    public void setLightFor(EnumSkyBlock type, BlockPos pos, int value)
-    {
+    public void setLightFor(EnumSkyBlock type, BlockPos pos, int value) {
         int i = pos.getX() & 15;
         int j = pos.getY();
         int k = pos.getZ() & 15;
         ExtendedBlockStorage extendedblockstorage = this.storageArrays[j >> 4];
 
-        if (extendedblockstorage == NULL_BLOCK_STORAGE)
-        {
+        if (extendedblockstorage == NULL_BLOCK_STORAGE) {
             extendedblockstorage = new ExtendedBlockStorage(j >> 4 << 4, this.world.provider.hasSkyLight());
             this.storageArrays[j >> 4] = extendedblockstorage;
             this.generateSkylightMap();
@@ -673,38 +597,29 @@
 
         this.dirty = true;
 
-        if (type == EnumSkyBlock.SKY)
-        {
-            if (this.world.provider.hasSkyLight())
-            {
+        if (type == EnumSkyBlock.SKY) {
+            if (this.world.provider.hasSkyLight()) {
                 extendedblockstorage.setSkyLight(i, j & 15, k, value);
             }
-        }
-        else if (type == EnumSkyBlock.BLOCK)
-        {
+        } else if (type == EnumSkyBlock.BLOCK) {
             extendedblockstorage.setBlockLight(i, j & 15, k, value);
         }
     }
 
-    public int getLightSubtracted(BlockPos pos, int amount)
-    {
+    public int getLightSubtracted(BlockPos pos, int amount) {
         int i = pos.getX() & 15;
         int j = pos.getY();
         int k = pos.getZ() & 15;
         ExtendedBlockStorage extendedblockstorage = this.storageArrays[j >> 4];
 
-        if (extendedblockstorage == NULL_BLOCK_STORAGE)
-        {
+        if (extendedblockstorage == NULL_BLOCK_STORAGE) {
             return this.world.provider.hasSkyLight() && amount < EnumSkyBlock.SKY.defaultLightValue ? EnumSkyBlock.SKY.defaultLightValue - amount : 0;
-        }
-        else
-        {
+        } else {
             int l = !this.world.provider.hasSkyLight() ? 0 : extendedblockstorage.getSkyLight(i, j & 15, k);
             l = l - amount;
             int i1 = extendedblockstorage.getBlockLight(i, j & 15, k);
 
-            if (i1 > l)
-            {
+            if (i1 > l) {
                 l = i1;
             }
 
@@ -712,27 +627,23 @@
         }
     }
 
-    public void addEntity(Entity entityIn)
-    {
+    public void addEntity(Entity entityIn) {
         this.hasEntities = true;
         int i = MathHelper.floor(entityIn.posX / 16.0D);
         int j = MathHelper.floor(entityIn.posZ / 16.0D);
 
-        if (i != this.x || j != this.z)
-        {
+        if (i != this.x || j != this.z) {
             LOGGER.warn("Wrong location! ({}, {}) should be ({}, {}), {}", Integer.valueOf(i), Integer.valueOf(j), Integer.valueOf(this.x), Integer.valueOf(this.z), entityIn);
             entityIn.setDead();
         }
 
         int k = MathHelper.floor(entityIn.posY / 16.0D);
 
-        if (k < 0)
-        {
+        if (k < 0) {
             k = 0;
         }
 
-        if (k >= this.entityLists.length)
-        {
+        if (k >= this.entityLists.length) {
             k = this.entityLists.length - 1;
         }
 
@@ -743,31 +654,54 @@
         entityIn.chunkCoordZ = this.z;
         this.entityLists[k].add(entityIn);
         this.markDirty(); // Forge - ensure chunks are marked to save after an entity add
+        // Spigot start - increment creature type count
+        // Keep this synced up with World.a(Class)
+        if (entityIn instanceof EntityLiving) {
+            EntityLiving entityinsentient = (EntityLiving) entityIn;
+            if (entityinsentient.canDespawn() && entityinsentient.isNoDespawnRequired()) {
+                return;
+            }
+        }
+        for (EnumCreatureType creatureType : EnumCreatureType.values()) {
+            if (creatureType.getCreatureClass().isAssignableFrom(entityIn.getClass())) {
+                this.entityCount.adjustOrPutValue(creatureType.getCreatureClass(), 1, 1);
+            }
+        }
+        // Spigot end
     }
 
-    public void removeEntity(Entity entityIn)
-    {
+    public void removeEntity(Entity entityIn) {
         this.removeEntityAtIndex(entityIn, entityIn.chunkCoordY);
     }
 
-    public void removeEntityAtIndex(Entity entityIn, int index)
-    {
-        if (index < 0)
-        {
+    public void removeEntityAtIndex(Entity entityIn, int index) {
+        if (index < 0) {
             index = 0;
         }
 
-        if (index >= this.entityLists.length)
-        {
+        if (index >= this.entityLists.length) {
             index = this.entityLists.length - 1;
         }
 
         this.entityLists[index].remove(entityIn);
         this.markDirty(); // Forge - ensure chunks are marked to save after entity removals
+        // Spigot start - decrement creature type count
+        // Keep this synced up with World.a(Class)
+        if (entityIn instanceof EntityLiving) {
+            EntityLiving entityinsentient = (EntityLiving) entityIn;
+            if (entityinsentient.canDespawn() && entityinsentient.isNoDespawnRequired()) {
+                return;
+            }
+        }
+        for (EnumCreatureType creatureType : EnumCreatureType.values()) {
+            if (creatureType.getCreatureClass().isAssignableFrom(entityIn.getClass())) {
+                this.entityCount.adjustValue(creatureType.getCreatureClass(), -1);
+            }
+        }
+        // Spigot end
     }
 
-    public boolean canSeeSky(BlockPos pos)
-    {
+    public boolean canSeeSky(BlockPos pos) {
         int i = pos.getX() & 15;
         int j = pos.getY();
         int k = pos.getZ() & 15;
@@ -775,33 +709,32 @@
     }
 
     @Nullable
-    private TileEntity createNewTileEntity(BlockPos pos)
-    {
+    private TileEntity createNewTileEntity(BlockPos pos) {
         IBlockState iblockstate = this.getBlockState(pos);
         Block block = iblockstate.getBlock();
         return !block.hasTileEntity(iblockstate) ? null : block.createTileEntity(this.world, iblockstate);
     }
 
     @Nullable
-    public TileEntity getTileEntity(BlockPos pos, Chunk.EnumCreateEntityType p_177424_2_)
-    {
-        TileEntity tileentity = this.tileEntities.get(pos);
+    public TileEntity getTileEntity(BlockPos pos, Chunk.EnumCreateEntityType p_177424_2_) {
+        TileEntity tileentity = null;
+        if (world.captureBlockStates) {
+            tileentity = world.capturedTileEntities.get(pos);
+        }
+        if (tileentity == null) {
+            tileentity = this.tileEntities.get(pos);
+        }
 
-        if (tileentity != null && tileentity.isInvalid())
-        {
+        if (tileentity != null && tileentity.isInvalid()) {
             tileEntities.remove(pos);
             tileentity = null;
         }
 
-        if (tileentity == null)
-        {
-            if (p_177424_2_ == Chunk.EnumCreateEntityType.IMMEDIATE)
-            {
+        if (tileentity == null) {
+            if (p_177424_2_ == Chunk.EnumCreateEntityType.IMMEDIATE) {
                 tileentity = this.createNewTileEntity(pos);
                 this.world.setTileEntity(pos, tileentity);
-            }
-            else if (p_177424_2_ == Chunk.EnumCreateEntityType.QUEUED)
-            {
+            } else if (p_177424_2_ == Chunk.EnumCreateEntityType.QUEUED) {
                 this.tileEntityPosQueue.add(pos.toImmutable());
             }
         }
@@ -809,109 +742,98 @@
         return tileentity;
     }
 
-    public void addTileEntity(TileEntity tileEntityIn)
-    {
+    public void addTileEntity(TileEntity tileEntityIn) {
         this.addTileEntity(tileEntityIn.getPos(), tileEntityIn);
 
-        if (this.loaded)
-        {
+        if (this.loaded) {
             this.world.addTileEntity(tileEntityIn);
         }
     }
 
-    public void addTileEntity(BlockPos pos, TileEntity tileEntityIn)
-    {
+    public void addTileEntity(BlockPos pos, TileEntity tileEntityIn) {
         if (tileEntityIn.getWorld() != this.world) //Forge don't call unless it's changed, could screw up bad mods.
-        tileEntityIn.setWorld(this.world);
+            tileEntityIn.setWorld(this.world);
         tileEntityIn.setPos(pos);
 
-        if (this.getBlockState(pos).getBlock().hasTileEntity(this.getBlockState(pos)))
-        {
-            if (this.tileEntities.containsKey(pos))
-            {
-                ((TileEntity)this.tileEntities.get(pos)).invalidate();
+        if (this.getBlockState(pos).getBlock().hasTileEntity(this.getBlockState(pos))) {
+            if (this.tileEntities.containsKey(pos)) {
+                ((TileEntity) this.tileEntities.get(pos)).invalidate();
             }
 
             tileEntityIn.validate();
             this.tileEntities.put(pos, tileEntityIn);
+        } else {
+            System.out.println("Attempted to place a tile entity (" + tileEntityIn + ") at " + tileEntityIn.getPos().getX() + "," + tileEntityIn.getPos().getY() + "," + tileEntityIn.getPos().getZ()
+                    + " (" + org.bukkit.craftbukkit.util.CraftMagicNumbers.getMaterial(getBlockState(pos).getBlock()) + ") where there was no entity tile!");
+            System.out.println("Chunk coordinates: " + (this.x * 16) + "," + (this.z * 16));
+            new Exception().printStackTrace();
         }
     }
 
-    public void removeTileEntity(BlockPos pos)
-    {
-        if (this.loaded)
-        {
+    public void removeTileEntity(BlockPos pos) {
+        if (this.loaded) {
             TileEntity tileentity = this.tileEntities.remove(pos);
 
-            if (tileentity != null)
-            {
+            if (tileentity != null) {
                 tileentity.invalidate();
             }
         }
     }
 
-    public void onLoad()
-    {
+    public void onLoad() {
         this.loaded = true;
         this.world.addTileEntities(this.tileEntities.values());
 
-        for (ClassInheritanceMultiMap<Entity> classinheritancemultimap : this.entityLists)
-        {
+        for (ClassInheritanceMultiMap<Entity> classinheritancemultimap : this.entityLists) {
             this.world.loadEntities(com.google.common.collect.ImmutableList.copyOf(classinheritancemultimap));
         }
         net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkEvent.Load(this));
     }
 
-    public void onUnload()
-    {
+    public void onUnload() {
         java.util.Arrays.stream(entityLists).forEach(multimap -> com.google.common.collect.Lists.newArrayList(multimap.getByClass(net.minecraft.entity.player.EntityPlayer.class)).forEach(player -> world.updateEntityWithOptionalForce(player, false))); // FORGE - Fix for MC-92916
         this.loaded = false;
 
-        for (TileEntity tileentity : this.tileEntities.values())
-        {
+        for (TileEntity tileentity : this.tileEntities.values()) {
             this.world.markTileEntityForRemoval(tileentity);
         }
 
-        for (ClassInheritanceMultiMap<Entity> classinheritancemultimap : this.entityLists)
-        {
-            this.world.unloadEntities(classinheritancemultimap);
+        for (ClassInheritanceMultiMap<Entity> classinheritancemultimap : this.entityLists) {
+            // Do not pass along players, as doing so can get them stuck outside of time.
+            // (which for example disables inventory icon updates and prevents block breaking)
+            this.world.unloadEntities(
+                    classinheritancemultimap
+                            .stream()
+                            .filter(entity -> !(entity instanceof EntityPlayerMP))
+                            .collect(Collectors.toCollection(() -> new ClassInheritanceMultiMap<>(Entity.class)))
+            );
         }
         net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkEvent.Unload(this));
     }
 
-    public void markDirty()
-    {
+    public void markDirty() {
         this.dirty = true;
     }
 
-    public void getEntitiesWithinAABBForEntity(@Nullable Entity entityIn, AxisAlignedBB aabb, List<Entity> listToFill, Predicate <? super Entity > filter)
-    {
+    public void getEntitiesWithinAABBForEntity(@Nullable Entity entityIn, AxisAlignedBB aabb, List<Entity> listToFill, Predicate<? super Entity> filter) {
         int i = MathHelper.floor((aabb.minY - World.MAX_ENTITY_RADIUS) / 16.0D);
         int j = MathHelper.floor((aabb.maxY + World.MAX_ENTITY_RADIUS) / 16.0D);
         i = MathHelper.clamp(i, 0, this.entityLists.length - 1);
         j = MathHelper.clamp(j, 0, this.entityLists.length - 1);
 
-        for (int k = i; k <= j; ++k)
-        {
-            if (!this.entityLists[k].isEmpty())
-            {
-                for (Entity entity : this.entityLists[k])
-                {
-                    if (entity.getEntityBoundingBox().intersects(aabb) && entity != entityIn)
-                    {
-                        if (filter == null || filter.apply(entity))
-                        {
+        for (int k = i; k <= j; ++k) {
+            if (!this.entityLists[k].isEmpty()) {
+                for (Entity entity : this.entityLists[k]) {
+                    if (entity.getEntityBoundingBox().intersects(aabb) && entity != entityIn) {
+                        if (filter == null || filter.apply(entity)) {
                             listToFill.add(entity);
                         }
 
                         Entity[] aentity = entity.getParts();
 
-                        if (aentity != null)
-                        {
-                            for (Entity entity1 : aentity)
-                            {
-                                if (entity1 != entityIn && entity1.getEntityBoundingBox().intersects(aabb) && (filter == null || filter.apply(entity1)))
-                                {
+                        if (aentity != null) {
+                            for (Entity entity1 : aentity) {
+                                if (entity1 != entityIn && entity1.getEntityBoundingBox().intersects(aabb) && (filter == null || filter.apply(entity1))) {
                                     listToFill.add(entity1);
                                 }
                             }
@@ -922,131 +844,176 @@
         }
     }
 
-    public <T extends Entity> void getEntitiesOfTypeWithinAABB(Class <? extends T > entityClass, AxisAlignedBB aabb, List<T> listToFill, Predicate <? super T > filter)
-    {
+    public <T extends Entity> void getEntitiesOfTypeWithinAABB(Class<? extends T> entityClass, AxisAlignedBB aabb, List<T> listToFill, Predicate<? super T> filter) {
         int i = MathHelper.floor((aabb.minY - World.MAX_ENTITY_RADIUS) / 16.0D);
         int j = MathHelper.floor((aabb.maxY + World.MAX_ENTITY_RADIUS) / 16.0D);
         i = MathHelper.clamp(i, 0, this.entityLists.length - 1);
         j = MathHelper.clamp(j, 0, this.entityLists.length - 1);
 
-        for (int k = i; k <= j; ++k)
-        {
-            for (T t : this.entityLists[k].getByClass(entityClass))
-            {
-                if (t.getEntityBoundingBox().intersects(aabb) && (filter == null || filter.apply(t)))
-                {
+        for (int k = i; k <= j; ++k) {
+            for (T t : this.entityLists[k].getByClass(entityClass)) {
+                if (t.getEntityBoundingBox().intersects(aabb) && (filter == null || filter.apply(t))) {
                     listToFill.add(t);
                 }
             }
         }
     }
 
-    public boolean needsSaving(boolean p_76601_1_)
-    {
-        if (p_76601_1_)
-        {
-            if (this.hasEntities && this.world.getTotalWorldTime() != this.lastSaveTime || this.dirty)
-            {
+    public boolean needsSaving(boolean p_76601_1_) {
+        if (p_76601_1_) {
+            if (this.hasEntities && this.world.getTotalWorldTime() != this.lastSaveTime || this.dirty) {
                 return true;
             }
-        }
-        else if (this.hasEntities && this.world.getTotalWorldTime() >= this.lastSaveTime + 600L)
-        {
+        } else if (this.hasEntities && this.world.getTotalWorldTime() >= this.lastSaveTime + 600L) {
             return true;
         }
 
         return this.dirty;
     }
 
-    public Random getRandomWithSeed(long seed)
-    {
-        return new Random(this.world.getSeed() + (long)(this.x * this.x * 4987142) + (long)(this.x * 5947611) + (long)(this.z * this.z) * 4392871L + (long)(this.z * 389711) ^ seed);
+    public Random getRandomWithSeed(long seed) {
+        return new Random(this.world.getSeed() + (long) (this.x * this.x * 4987142) + (long) (this.x * 5947611) + (long) (this.z * this.z) * 4392871L + (long) (this.z * 389711) ^ seed);
     }
 
-    public boolean isEmpty()
-    {
+    public boolean isEmpty() {
         return false;
     }
 
-    public void populate(IChunkProvider chunkProvider, IChunkGenerator chunkGenrator)
-    {
+    public void populateCB(IChunkProvider chunkProvider, IChunkGenerator chunkGenrator, boolean newChunk) {
+        Server server = world.getServer();
+        if (server != null) {
+            /*
+             * If it's a new world, the first few chunks are generated inside
+             * the World constructor. We can't reliably alter that, so we have
+             * no way of creating a CraftWorld/CraftServer at that point.
+             */
+            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(bukkitChunk, newChunk));
+        }
+
+        // Update neighbor counts
+        for (int x = -2; x < 3; x++) {
+            for (int z = -2; z < 3; z++) {
+                if (x == 0 && z == 0) {
+                    continue;
+                }
+
+                Chunk neighbor = getWorld().getChunkIfLoaded(this.x + x, this.z + z);
+                if (neighbor != null) {
+                    neighbor.setNeighborLoaded(-x, -z);
+                    setNeighborLoaded(x, z);
+                }
+            }
+        }
         Chunk chunk = chunkProvider.getLoadedChunk(this.x, this.z - 1);
         Chunk chunk1 = chunkProvider.getLoadedChunk(this.x + 1, this.z);
         Chunk chunk2 = chunkProvider.getLoadedChunk(this.x, this.z + 1);
         Chunk chunk3 = chunkProvider.getLoadedChunk(this.x - 1, this.z);
 
-        if (chunk1 != null && chunk2 != null && chunkProvider.getLoadedChunk(this.x + 1, this.z + 1) != null)
-        {
+        if (chunk1 != null && chunk2 != null && chunkProvider.getLoadedChunk(this.x + 1, this.z + 1) != null) {
             this.populate(chunkGenrator);
         }
 
-        if (chunk3 != null && chunk2 != null && chunkProvider.getLoadedChunk(this.x - 1, this.z + 1) != null)
-        {
+        if (chunk3 != null && chunk2 != null && chunkProvider.getLoadedChunk(this.x - 1, this.z + 1) != null) {
             chunk3.populate(chunkGenrator);
         }
 
-        if (chunk != null && chunk1 != null && chunkProvider.getLoadedChunk(this.x + 1, this.z - 1) != null)
-        {
+        if (chunk != null && chunk1 != null && chunkProvider.getLoadedChunk(this.x + 1, this.z - 1) != null) {
             chunk.populate(chunkGenrator);
         }
 
-        if (chunk != null && chunk3 != null)
-        {
+        if (chunk != null && chunk3 != null) {
             Chunk chunk4 = chunkProvider.getLoadedChunk(this.x - 1, this.z - 1);
 
-            if (chunk4 != null)
-            {
+            if (chunk4 != null) {
                 chunk4.populate(chunkGenrator);
             }
         }
     }
 
-    protected void populate(IChunkGenerator generator)
-    {
-        if (populating != null && net.minecraftforge.common.ForgeModContainer.logCascadingWorldGeneration) logCascadingWorldGeneration();
+    public void populate(IChunkProvider chunkProvider, IChunkGenerator chunkGenrator) {
+        Chunk chunk = chunkProvider.getLoadedChunk(this.x, this.z - 1);
+        Chunk chunk1 = chunkProvider.getLoadedChunk(this.x + 1, this.z);
+        Chunk chunk2 = chunkProvider.getLoadedChunk(this.x, this.z + 1);
+        Chunk chunk3 = chunkProvider.getLoadedChunk(this.x - 1, this.z);
+
+        if (chunk1 != null && chunk2 != null && chunkProvider.getLoadedChunk(this.x + 1, this.z + 1) != null) {
+            this.populate(chunkGenrator);
+        }
+
+        if (chunk3 != null && chunk2 != null && chunkProvider.getLoadedChunk(this.x - 1, this.z + 1) != null) {
+            chunk3.populate(chunkGenrator);
+        }
+
+        if (chunk != null && chunk1 != null && chunkProvider.getLoadedChunk(this.x + 1, this.z - 1) != null) {
+            chunk.populate(chunkGenrator);
+        }
+
+        if (chunk != null && chunk3 != null) {
+            Chunk chunk4 = chunkProvider.getLoadedChunk(this.x - 1, this.z - 1);
+
+            if (chunk4 != null) {
+                chunk4.populate(chunkGenrator);
+            }
+        }
+    }
+
+    protected void populate(IChunkGenerator generator) {
+        if (populating != null && net.minecraftforge.common.ForgeModContainer.logCascadingWorldGeneration)
+            logCascadingWorldGeneration();
         ChunkPos prev = populating;
         populating = this.getPos();
-        if (this.isTerrainPopulated())
-        {
-            if (generator.generateStructures(this, this.x, this.z))
-            {
+        if (this.isTerrainPopulated()) {
+            if (generator.generateStructures(this, this.x, this.z)) {
                 this.markDirty();
             }
-        }
-        else
-        {
+        } else {
             this.checkLight();
             generator.populate(this.x, this.z);
+            BlockSand.fallInstantly = true;
+            Random random = new Random();
+            random.setSeed(world.getSeed());
+            long xRand = random.nextLong() / 2L * 2L + 1L;
+            long zRand = random.nextLong() / 2L * 2L + 1L;
+            random.setSeed((long) this.x * xRand + (long) this.z * zRand ^ world.getSeed());
+
+            org.bukkit.World world = this.world.getWorld();
+            if (world != null) {
+                this.world.populating = true;
+                try {
+                    for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
+                        populator.populate(world, random, bukkitChunk);
+                    }
+                } finally {
+                    this.world.populating = false;
+                }
+            }
+            BlockSand.fallInstantly = false;
+            this.world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
+
             net.minecraftforge.fml.common.registry.GameRegistry.generateWorld(this.x, this.z, this.world, generator, this.world.getChunkProvider());
             this.markDirty();
         }
         populating = prev;
     }
 
-    public BlockPos getPrecipitationHeight(BlockPos pos)
-    {
+    public BlockPos getPrecipitationHeight(BlockPos pos) {
         int i = pos.getX() & 15;
         int j = pos.getZ() & 15;
         int k = i | j << 4;
         BlockPos blockpos = new BlockPos(pos.getX(), this.precipitationHeightMap[k], pos.getZ());
 
-        if (blockpos.getY() == -999)
-        {
+        if (blockpos.getY() == -999) {
             int l = this.getTopFilledSegment() + 15;
             blockpos = new BlockPos(pos.getX(), l, pos.getZ());
             int i1 = -1;
 
-            while (blockpos.getY() > 0 && i1 == -1)
-            {
+            while (blockpos.getY() > 0 && i1 == -1) {
                 IBlockState iblockstate = this.getBlockState(blockpos);
                 Material material = iblockstate.getMaterial();
 
-                if (!material.blocksMovement() && !material.isLiquid())
-                {
+                if (!material.blocksMovement() && !material.isLiquid()) {
                     blockpos = blockpos.down();
-                }
-                else
-                {
+                } else {
                     i1 = blockpos.getY() + 1;
                 }
             }
@@ -1057,26 +1024,21 @@
         return new BlockPos(pos.getX(), this.precipitationHeightMap[k], pos.getZ());
     }
 
-    public void onTick(boolean skipRecheckGaps)
-    {
-        if (this.isGapLightingUpdated && this.world.provider.hasSkyLight() && !skipRecheckGaps)
-        {
+    public void onTick(boolean skipRecheckGaps) {
+        if (this.isGapLightingUpdated && this.world.provider.hasSkyLight() && !skipRecheckGaps) {
             this.recheckGaps(this.world.isRemote);
         }
 
         this.ticked = true;
 
-        if (!this.isLightPopulated && this.isTerrainPopulated)
-        {
+        if (!this.isLightPopulated && this.isTerrainPopulated) {
             this.checkLight();
         }
 
-        while (!this.tileEntityPosQueue.isEmpty())
-        {
+        while (!this.tileEntityPosQueue.isEmpty()) {
             BlockPos blockpos = this.tileEntityPosQueue.poll();
 
-            if (this.getTileEntity(blockpos, Chunk.EnumCreateEntityType.CHECK) == null && this.getBlockState(blockpos).getBlock().hasTileEntity(this.getBlockState(blockpos)))
-            {
+            if (this.getTileEntity(blockpos, Chunk.EnumCreateEntityType.CHECK) == null && this.getBlockState(blockpos).getBlock().hasTileEntity(this.getBlockState(blockpos))) {
                 TileEntity tileentity = this.createNewTileEntity(blockpos);
                 this.world.setTileEntity(blockpos, tileentity);
                 this.world.markBlockRangeForRenderUpdate(blockpos, blockpos);
@@ -1084,39 +1046,31 @@
         }
     }
 
-    public boolean isPopulated()
-    {
-        return this.ticked && this.isTerrainPopulated && this.isLightPopulated;
+    public boolean isPopulated() {
+        return this.ticked && this.isTerrainPopulated;
     }
 
-    public boolean wasTicked()
-    {
+    public boolean wasTicked() {
         return this.ticked;
     }
 
-    public ChunkPos getPos()
-    {
+    public ChunkPos getPos() {
         return new ChunkPos(this.x, this.z);
     }
 
-    public boolean isEmptyBetween(int startY, int endY)
-    {
-        if (startY < 0)
-        {
+    public boolean isEmptyBetween(int startY, int endY) {
+        if (startY < 0) {
             startY = 0;
         }
 
-        if (endY >= 256)
-        {
+        if (endY >= 256) {
             endY = 255;
         }
 
-        for (int i = startY; i <= endY; i += 16)
-        {
+        for (int i = startY; i <= endY; i += 16) {
             ExtendedBlockStorage extendedblockstorage = this.storageArrays[i >> 4];
 
-            if (extendedblockstorage != NULL_BLOCK_STORAGE && !extendedblockstorage.isEmpty())
-            {
+            if (extendedblockstorage != NULL_BLOCK_STORAGE && !extendedblockstorage.isEmpty()) {
                 return false;
             }
         }
@@ -1148,21 +1102,15 @@
 
         boolean flag = this.world.provider.hasSkyLight();
 
-        for (int i = 0; i < this.storageArrays.length; ++i)
-        {
+        for (int i = 0; i < this.storageArrays.length; ++i) {
             ExtendedBlockStorage extendedblockstorage = this.storageArrays[i];
 
-            if ((availableSections & 1 << i) == 0)
-            {
-                if (groundUpContinuous && extendedblockstorage != NULL_BLOCK_STORAGE)
-                {
+            if ((availableSections & 1 << i) == 0) {
+                if (groundUpContinuous && extendedblockstorage != NULL_BLOCK_STORAGE) {
                     this.storageArrays[i] = NULL_BLOCK_STORAGE;
                 }
-            }
-            else
-            {
-                if (extendedblockstorage == NULL_BLOCK_STORAGE)
-                {
+            } else {
+                if (extendedblockstorage == NULL_BLOCK_STORAGE) {
                     extendedblockstorage = new ExtendedBlockStorage(i << 4, flag);
                     this.storageArrays[i] = extendedblockstorage;
                 }
@@ -1170,22 +1118,18 @@
                 extendedblockstorage.getData().read(buf);
                 buf.readBytes(extendedblockstorage.getBlockLight().getData());
 
-                if (flag)
-                {
+                if (flag) {
                     buf.readBytes(extendedblockstorage.getSkyLight().getData());
                 }
             }
         }
 
-        if (groundUpContinuous)
-        {
+        if (groundUpContinuous) {
             buf.readBytes(this.blockBiomeArray);
         }
 
-        for (int j = 0; j < this.storageArrays.length; ++j)
-        {
-            if (this.storageArrays[j] != NULL_BLOCK_STORAGE && (availableSections & 1 << j) != 0)
-            {
+        for (int j = 0; j < this.storageArrays.length; ++j) {
+            if (this.storageArrays[j] != NULL_BLOCK_STORAGE && (availableSections & 1 << j) != 0) {
                 this.storageArrays[j].recalculateRefCounts();
             }
         }
@@ -1196,8 +1140,7 @@
 
         List<TileEntity> invalidList = new java.util.ArrayList<TileEntity>();
 
-        for (TileEntity tileentity : this.tileEntities.values())
-        {
+        for (TileEntity tileentity : this.tileEntities.values()) {
             if (tileentity.shouldRefresh(this.world, tileentity.getPos(), tileentity.getBlockType().getStateFromMeta(tileentity.getBlockMetadata()), getBlockState(tileentity.getPos())))
                 invalidList.add(tileentity);
             tileentity.updateContainingBlockInfo();
@@ -1206,55 +1149,43 @@
         for (TileEntity te : invalidList) te.invalidate();
     }
 
-    public Biome getBiome(BlockPos pos, BiomeProvider provider)
-    {
+    public Biome getBiome(BlockPos pos, BiomeProvider provider) {
         int i = pos.getX() & 15;
         int j = pos.getZ() & 15;
         int k = this.blockBiomeArray[j << 4 | i] & 255;
 
-        if (k == 255)
-        {
+        if (k == 255) {
             Biome biome = provider.getBiome(pos, Biomes.PLAINS);
             k = Biome.getIdForBiome(biome);
-            this.blockBiomeArray[j << 4 | i] = (byte)(k & 255);
+            this.blockBiomeArray[j << 4 | i] = (byte) (k & 255);
         }
 
         Biome biome1 = Biome.getBiome(k);
         return biome1 == null ? Biomes.PLAINS : biome1;
     }
 
-    public byte[] getBiomeArray()
-    {
+    public byte[] getBiomeArray() {
         return this.blockBiomeArray;
     }
 
-    public void setBiomeArray(byte[] biomeArray)
-    {
-        if (this.blockBiomeArray.length != biomeArray.length)
-        {
+    public void setBiomeArray(byte[] biomeArray) {
+        if (this.blockBiomeArray.length != biomeArray.length) {
             LOGGER.warn("Could not set level chunk biomes, array length is {} instead of {}", Integer.valueOf(biomeArray.length), Integer.valueOf(this.blockBiomeArray.length));
-        }
-        else
-        {
+        } else {
             System.arraycopy(biomeArray, 0, this.blockBiomeArray, 0, this.blockBiomeArray.length);
         }
     }
 
-    public void resetRelightChecks()
-    {
+    public void resetRelightChecks() {
         this.queuedLightChecks = 0;
     }
 
-    public void enqueueRelightChecks()
-    {
-        if (this.queuedLightChecks < 4096)
-        {
+    public void enqueueRelightChecks() {
+        if (this.queuedLightChecks < 4096) {
             BlockPos blockpos = new BlockPos(this.x << 4, 0, this.z << 4);
 
-            for (int i = 0; i < 8; ++i)
-            {
-                if (this.queuedLightChecks >= 4096)
-                {
+            for (int i = 0; i < 8; ++i) {
+                if (this.queuedLightChecks >= 4096) {
                     return;
                 }
 
@@ -1263,19 +1194,15 @@
                 int l = this.queuedLightChecks / 256;
                 ++this.queuedLightChecks;
 
-                for (int i1 = 0; i1 < 16; ++i1)
-                {
+                for (int i1 = 0; i1 < 16; ++i1) {
                     BlockPos blockpos1 = blockpos.add(k, (j << 4) + i1, l);
                     boolean flag = i1 == 0 || i1 == 15 || k == 0 || k == 15 || l == 0 || l == 15;
 
-                    if (this.storageArrays[j] == NULL_BLOCK_STORAGE && flag || this.storageArrays[j] != NULL_BLOCK_STORAGE && this.storageArrays[j].get(k, i1, l).getBlock().isAir(this.storageArrays[j].get(k, i1, l), this.world, blockpos1))
-                    {
-                        for (EnumFacing enumfacing : EnumFacing.values())
-                        {
+                    if (this.storageArrays[j] == NULL_BLOCK_STORAGE && flag || this.storageArrays[j] != NULL_BLOCK_STORAGE && this.storageArrays[j].get(k, i1, l).getBlock().isAir(this.storageArrays[j].get(k, i1, l), this.world, blockpos1)) {
+                        for (EnumFacing enumfacing : EnumFacing.values()) {
                             BlockPos blockpos2 = blockpos1.offset(enumfacing);
 
-                            if (this.world.getBlockState(blockpos2).getLightValue(this.world, blockpos2) > 0)
-                            {
+                            if (this.world.getBlockState(blockpos2).getLightValue(this.world, blockpos2) > 0) {
                                 this.world.checkLight(blockpos2);
                             }
                         }
@@ -1287,126 +1214,93 @@
         }
     }
 
-    public void checkLight()
-    {
+    public void checkLight() {
         this.isTerrainPopulated = true;
         this.isLightPopulated = true;
         BlockPos blockpos = new BlockPos(this.x << 4, 0, this.z << 4);
 
-        if (this.world.provider.hasSkyLight())
-        {
-            if (this.world.isAreaLoaded(blockpos.add(-1, 0, -1), blockpos.add(16, this.world.getSeaLevel(), 16)))
-            {
+        if (this.world.provider.hasSkyLight()) {
+            if (this.world.isAreaLoaded(blockpos.add(-1, 0, -1), blockpos.add(16, this.world.getSeaLevel(), 16))) {
                 label44:
 
-                for (int i = 0; i < 16; ++i)
-                {
-                    for (int j = 0; j < 16; ++j)
-                    {
-                        if (!this.checkLight(i, j))
-                        {
+                for (int i = 0; i < 16; ++i) {
+                    for (int j = 0; j < 16; ++j) {
+                        if (!this.checkLight(i, j)) {
                             this.isLightPopulated = false;
                             break label44;
                         }
                     }
                 }
 
-                if (this.isLightPopulated)
-                {
-                    for (EnumFacing enumfacing : EnumFacing.Plane.HORIZONTAL)
-                    {
+                if (this.isLightPopulated) {
+                    for (EnumFacing enumfacing : EnumFacing.Plane.HORIZONTAL) {
                         int k = enumfacing.getAxisDirection() == EnumFacing.AxisDirection.POSITIVE ? 16 : 1;
                         this.world.getChunkFromBlockCoords(blockpos.offset(enumfacing, k)).checkLightSide(enumfacing.getOpposite());
                     }
 
                     this.setSkylightUpdated();
                 }
-            }
-            else
-            {
+            } else {
                 this.isLightPopulated = false;
             }
         }
     }
 
-    private void setSkylightUpdated()
-    {
-        for (int i = 0; i < this.updateSkylightColumns.length; ++i)
-        {
+    private void setSkylightUpdated() {
+        for (int i = 0; i < this.updateSkylightColumns.length; ++i) {
             this.updateSkylightColumns[i] = true;
         }
 
         this.recheckGaps(false);
     }
 
-    private void checkLightSide(EnumFacing facing)
-    {
-        if (this.isTerrainPopulated)
-        {
-            if (facing == EnumFacing.EAST)
-            {
-                for (int i = 0; i < 16; ++i)
-                {
+    private void checkLightSide(EnumFacing facing) {
+        if (this.isTerrainPopulated) {
+            if (facing == EnumFacing.EAST) {
+                for (int i = 0; i < 16; ++i) {
                     this.checkLight(15, i);
                 }
-            }
-            else if (facing == EnumFacing.WEST)
-            {
-                for (int j = 0; j < 16; ++j)
-                {
+            } else if (facing == EnumFacing.WEST) {
+                for (int j = 0; j < 16; ++j) {
                     this.checkLight(0, j);
                 }
-            }
-            else if (facing == EnumFacing.SOUTH)
-            {
-                for (int k = 0; k < 16; ++k)
-                {
+            } else if (facing == EnumFacing.SOUTH) {
+                for (int k = 0; k < 16; ++k) {
                     this.checkLight(k, 15);
                 }
-            }
-            else if (facing == EnumFacing.NORTH)
-            {
-                for (int l = 0; l < 16; ++l)
-                {
+            } else if (facing == EnumFacing.NORTH) {
+                for (int l = 0; l < 16; ++l) {
                     this.checkLight(l, 0);
                 }
             }
         }
     }
 
-    private boolean checkLight(int x, int z)
-    {
+    private boolean checkLight(int x, int z) {
         int i = this.getTopFilledSegment();
         boolean flag = false;
         boolean flag1 = false;
         BlockPos.MutableBlockPos blockpos$mutableblockpos = new BlockPos.MutableBlockPos((this.x << 4) + x, 0, (this.z << 4) + z);
 
-        for (int j = i + 16 - 1; j > this.world.getSeaLevel() || j > 0 && !flag1; --j)
-        {
+        for (int j = i + 16 - 1; j > this.world.getSeaLevel() || j > 0 && !flag1; --j) {
             blockpos$mutableblockpos.setPos(blockpos$mutableblockpos.getX(), j, blockpos$mutableblockpos.getZ());
             int k = this.getBlockLightOpacity(blockpos$mutableblockpos);
 
-            if (k == 255 && blockpos$mutableblockpos.getY() < this.world.getSeaLevel())
-            {
+            if (k == 255 && blockpos$mutableblockpos.getY() < this.world.getSeaLevel()) {
                 flag1 = true;
             }
 
-            if (!flag && k > 0)
-            {
+            if (!flag && k > 0) {
                 flag = true;
-            }
-            else if (flag && k == 0 && !this.world.checkLight(blockpos$mutableblockpos))
-            {
+            } else if (flag && k == 0 && !this.world.checkLight(blockpos$mutableblockpos)) {
                 return false;
             }
         }
 
-        for (int l = blockpos$mutableblockpos.getY(); l > 0; --l)
-        {
+        for (int l = blockpos$mutableblockpos.getY(); l > 0; --l) {
             blockpos$mutableblockpos.setPos(blockpos$mutableblockpos.getX(), l, blockpos$mutableblockpos.getZ());
 
-            if (this.getBlockState(blockpos$mutableblockpos).getLightValue(this.world, blockpos$mutableblockpos) > 0)
-            {
+            if (this.getBlockState(blockpos$mutableblockpos).getLightValue(this.world, blockpos$mutableblockpos) > 0) {
                 this.world.checkLight(blockpos$mutableblockpos);
             }
         }
@@ -1414,119 +1308,96 @@
         return true;
     }
 
-    public boolean isLoaded()
-    {
+    public boolean isLoaded() {
         return this.loaded;
     }
 
     @SideOnly(Side.CLIENT)
-    public void markLoaded(boolean loaded)
-    {
+    public void markLoaded(boolean loaded) {
         this.loaded = loaded;
     }
 
-    public World getWorld()
-    {
+    public World getWorld() {
         return this.world;
     }
 
-    public int[] getHeightMap()
-    {
+    public int[] getHeightMap() {
         return this.heightMap;
     }
 
-    public void setHeightMap(int[] newHeightMap)
-    {
-        if (this.heightMap.length != newHeightMap.length)
-        {
+    public void setHeightMap(int[] newHeightMap) {
+        if (this.heightMap.length != newHeightMap.length) {
             LOGGER.warn("Could not set level chunk heightmap, array length is {} instead of {}", Integer.valueOf(newHeightMap.length), Integer.valueOf(this.heightMap.length));
-        }
-        else
-        {
+        } else {
             System.arraycopy(newHeightMap, 0, this.heightMap, 0, this.heightMap.length);
             this.heightMapMinimum = com.google.common.primitives.Ints.min(this.heightMap); // Forge: fix MC-117412
         }
     }
 
-    public Map<BlockPos, TileEntity> getTileEntityMap()
-    {
+    public Map<BlockPos, TileEntity> getTileEntityMap() {
         return this.tileEntities;
     }
 
-    public ClassInheritanceMultiMap<Entity>[] getEntityLists()
-    {
+    public ClassInheritanceMultiMap<Entity>[] getEntityLists() {
         return this.entityLists;
     }
 
-    public boolean isTerrainPopulated()
-    {
+    public boolean isTerrainPopulated() {
         return this.isTerrainPopulated;
     }
 
-    public void setTerrainPopulated(boolean terrainPopulated)
-    {
+    public void setTerrainPopulated(boolean terrainPopulated) {
         this.isTerrainPopulated = terrainPopulated;
     }
 
-    public boolean isLightPopulated()
-    {
+    public boolean isLightPopulated() {
         return this.isLightPopulated;
     }
 
-    public void setLightPopulated(boolean lightPopulated)
-    {
+    public void setLightPopulated(boolean lightPopulated) {
         this.isLightPopulated = lightPopulated;
     }
 
-    public void setModified(boolean modified)
-    {
+    public void setModified(boolean modified) {
         this.dirty = modified;
     }
 
-    public void setHasEntities(boolean hasEntitiesIn)
-    {
+    public void setHasEntities(boolean hasEntitiesIn) {
         this.hasEntities = hasEntitiesIn;
     }
 
-    public void setLastSaveTime(long saveTime)
-    {
+    public void setLastSaveTime(long saveTime) {
         this.lastSaveTime = saveTime;
     }
 
-    public int getLowestHeight()
-    {
+    public int getLowestHeight() {
         return this.heightMapMinimum;
     }
 
-    public long getInhabitedTime()
-    {
+    public long getInhabitedTime() {
         return this.inhabitedTime;
     }
 
-    public void setInhabitedTime(long newInhabitedTime)
-    {
+    public void setInhabitedTime(long newInhabitedTime) {
         this.inhabitedTime = newInhabitedTime;
     }
 
-    public static enum EnumCreateEntityType
-    {
+    public static enum EnumCreateEntityType {
         IMMEDIATE,
         QUEUED,
         CHECK;
     }
 
     /* ======================================== FORGE START =====================================*/
+
     /**
      * Removes the tile entity at the specified position, only if it's
      * marked as invalid.
      */
-    public void removeInvalidTileEntity(BlockPos pos)
-    {
-        if (loaded)
-        {
-            TileEntity entity = (TileEntity)tileEntities.get(pos);
-            if (entity != null && entity.isInvalid())
-            {
+    public void removeInvalidTileEntity(BlockPos pos) {
+        if (loaded) {
+            TileEntity entity = (TileEntity) tileEntities.get(pos);
+            if (entity != null && entity.isInvalid()) {
                 tileEntities.remove(pos);
             }
         }
@@ -1534,8 +1405,7 @@
 
     private static ChunkPos populating = null; // keep track of cascading chunk generation during chunk population
 
-    private void logCascadingWorldGeneration()
-    {
+    private void logCascadingWorldGeneration() {
         net.minecraftforge.fml.common.ModContainer activeModContainer = net.minecraftforge.fml.common.Loader.instance().activeModContainer();
         String format = "{} loaded a new chunk {} in dimension {} ({}) while populating chunk {}, causing cascading worldgen lag.";
 
@@ -1549,20 +1419,20 @@
     }
 
     private final net.minecraftforge.common.capabilities.CapabilityDispatcher capabilities;
+
     @Nullable
-    public net.minecraftforge.common.capabilities.CapabilityDispatcher getCapabilities()
-    {
+    public net.minecraftforge.common.capabilities.CapabilityDispatcher getCapabilities() {
         return capabilities;
     }
+
     @Override
-    public boolean hasCapability(net.minecraftforge.common.capabilities.Capability<?> capability, @Nullable EnumFacing facing)
-    {
+    public boolean hasCapability(net.minecraftforge.common.capabilities.Capability<?> capability, @Nullable EnumFacing facing) {
         return capabilities == null ? false : capabilities.hasCapability(capability, facing);
     }
+
     @Override
     @Nullable
-    public <T> T getCapability(net.minecraftforge.common.capabilities.Capability<T> capability, @Nullable EnumFacing facing)
-    {
+    public <T> T getCapability(net.minecraftforge.common.capabilities.Capability<T> capability, @Nullable EnumFacing facing) {
         return capabilities == null ? null : capabilities.getCapability(capability, facing);
     }
 }
