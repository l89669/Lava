--- ../src-base/minecraft/net/minecraft/world/World.java
+++ ../src-work/minecraft/net/minecraft/world/World.java
@@ -3,21 +3,13 @@
 import com.google.common.base.Function;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Predicate;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
-import java.util.Calendar;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Random;
-import java.util.UUID;
-import java.util.function.Supplier;
-
-import javax.annotation.Nullable;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import net.minecraft.advancements.AdvancementManager;
 import net.minecraft.advancements.FunctionManager;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockLiquid;
-import net.minecraft.block.BlockObserver;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.crash.CrashReport;
@@ -25,47 +17,67 @@
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.item.EntityItem;
+import net.minecraft.entity.item.EntityXPOrb;
+import net.minecraft.entity.monster.EntityGhast;
+import net.minecraft.entity.monster.EntityGolem;
+import net.minecraft.entity.monster.EntityMob;
+import net.minecraft.entity.monster.EntitySlime;
+import net.minecraft.entity.passive.EntityAnimal;
+import net.minecraft.entity.passive.EntityWaterMob;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.init.Biomes;
 import net.minecraft.init.Blocks;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.network.Packet;
+import net.minecraft.network.play.server.SPacketWorldBorder;
 import net.minecraft.pathfinding.PathWorldListener;
 import net.minecraft.profiler.Profiler;
 import net.minecraft.scoreboard.Scoreboard;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.tileentity.TileEntity;
-import net.minecraft.util.EntitySelectors;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.EnumParticleTypes;
-import net.minecraft.util.ITickable;
-import net.minecraft.util.IntHashMap;
-import net.minecraft.util.ReportedException;
-import net.minecraft.util.SoundCategory;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.math.AxisAlignedBB;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.RayTraceResult;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.*;
+import net.minecraft.util.math.*;
 import net.minecraft.village.VillageCollection;
 import net.minecraft.world.biome.Biome;
 import net.minecraft.world.biome.BiomeProvider;
+import net.minecraft.world.border.IBorderListener;
 import net.minecraft.world.border.WorldBorder;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.gen.ChunkProviderServer;
 import net.minecraft.world.gen.structure.StructureBoundingBox;
 import net.minecraft.world.storage.ISaveHandler;
 import net.minecraft.world.storage.MapStorage;
 import net.minecraft.world.storage.WorldInfo;
 import net.minecraft.world.storage.WorldSavedData;
 import net.minecraft.world.storage.loot.LootTableManager;
+import net.minecraftforge.common.DimensionManager;
+import net.minecraftforge.common.ForgeChunkManager;
+import net.minecraftforge.common.ForgeChunkManager.Ticket;
+import net.minecraftforge.common.capabilities.Capability;
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.entity.NPC;
+import org.bukkit.event.block.BlockCanBuildEvent;
+import org.bukkit.event.block.BlockPhysicsEvent;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.generator.ChunkGenerator;
 
-public abstract class World implements IBlockAccess, net.minecraftforge.common.capabilities.ICapabilityProvider
-{
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+
+public abstract class World implements IBlockAccess, net.minecraftforge.common.capabilities.ICapabilityProvider {
     /**
      * Used in the getEntitiesWithinAABB functions to expand the search area for entities.
      * Modders should change this variable to a higher value if it is less then the radius
@@ -94,36 +106,72 @@
     public float thunderingStrength;
     private int lastLightningBolt;
     public final Random rand = new Random();
-    public final WorldProvider provider;
+    public WorldProvider provider;
     protected PathWorldListener pathListener = new PathWorldListener();
     protected List<IWorldEventListener> eventListeners;
     protected IChunkProvider chunkProvider;
     protected final ISaveHandler saveHandler;
-    protected WorldInfo worldInfo;
+    public WorldInfo worldInfo;
     protected boolean findingSpawnPoint;
-    protected MapStorage mapStorage;
+    public MapStorage mapStorage;
     public VillageCollection villageCollection;
     protected LootTableManager lootTable;
     protected AdvancementManager advancementManager;
     protected FunctionManager functionManager;
     public final Profiler profiler;
     private final Calendar calendar;
-    protected Scoreboard worldScoreboard;
+    public Scoreboard worldScoreboard;
     public final boolean isRemote;
-    protected boolean spawnHostileMobs;
-    protected boolean spawnPeacefulMobs;
+    public boolean spawnHostileMobs;
+    public boolean spawnPeacefulMobs;
     private boolean processingLoadedTiles;
     private final WorldBorder worldBorder;
     int[] lightUpdateBlockList;
 
     public boolean restoringBlockSnapshots = false;
     public boolean captureBlockSnapshots = false;
-    public java.util.ArrayList<net.minecraftforge.common.util.BlockSnapshot> capturedBlockSnapshots = new java.util.ArrayList<net.minecraftforge.common.util.BlockSnapshot>();
+    public ArrayList<net.minecraftforge.common.util.BlockSnapshot> capturedBlockSnapshots = new ArrayList<net.minecraftforge.common.util.BlockSnapshot>();
     private net.minecraftforge.common.capabilities.CapabilityDispatcher capabilities;
     private net.minecraftforge.common.util.WorldCapabilityData capabilityData;
 
-    protected World(ISaveHandler saveHandlerIn, WorldInfo info, WorldProvider providerIn, Profiler profilerIn, boolean client)
-    {
+    private final CraftWorld world;
+    public boolean pvpMode;
+    public boolean keepSpawnInMemory = true;
+    public ChunkGenerator generator;
+    public boolean captureTreeGeneration = false;
+    public List<EntityItem> captureDrops;
+    public long ticksPerAnimalSpawns;
+    public long ticksPerMonsterSpawns;
+    public boolean populating;
+    private int tickPosition;
+    public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
+    public static boolean haveWeSilencedAPhysicsCrash;
+    public static String blockLocation;
+    private org.spigotmc.TickLimiter entityLimiter;
+    private org.spigotmc.TickLimiter tileLimiter;
+    private int tileTickPosition;
+    public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<>(); // Paper - Optimize explosions
+    private ImmutableSetMultimap<ChunkPos, Ticket> forcedChunks = ImmutableSetMultimap.of();
+
+    public CraftWorld getWorld() {
+        return this.world;
+    }
+
+    public CraftServer getServer() {
+        return (CraftServer) Bukkit.getServer();
+    }
+
+    public Chunk getChunkIfLoaded(int x, int z) {
+        return ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x, z);
+    }
+
+    protected World(ISaveHandler saveHandlerIn, WorldInfo info, WorldProvider providerIn, Profiler profilerIn, boolean client, ChunkGenerator gen, org.bukkit.World.Environment env) {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig(info.getWorldName()); // Spigot
+        this.generator = gen;
+        this.world = new CraftWorld((WorldServer) this, gen, env);
+        this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
+        this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
+        // CraftBukkit end
         this.eventListeners = Lists.newArrayList(this.pathListener);
         this.calendar = Calendar.getInstance();
         this.worldScoreboard = new Scoreboard();
@@ -136,203 +184,245 @@
         this.provider = providerIn;
         this.isRemote = client;
         this.worldBorder = providerIn.createWorldBorder();
-        perWorldStorage = new MapStorage((ISaveHandler)null);
+        perWorldStorage = new MapStorage(null);
+        // Lava start
+        if (DimensionManager.getWorld(0) != null) { // if overworld has loaded, use its mapstorage
+            this.mapStorage = DimensionManager.getWorld(0).mapStorage;
+        } else {
+            this.mapStorage = new MapStorage(saveHandlerIn);
+        }
+
+        if (this.worldInfo != null) { // Use saved dimension from level.dat. Fixes issues with MultiVerse
+            if (this.worldInfo.getDimension() != 0)
+                this.provider.setDimension(this.worldInfo.getDimension());
+            else {
+                this.worldInfo.setDimension(this.provider.getDimension());
+            }
+        }
+
+        if (this.worldInfo.getDimension() == 0) {
+            generator = this.getServer().getGenerator(this.worldInfo.getWorldName());
+            getWorld().generator = generator;
+        }
+        // Lava end
+        // CraftBukkit start
+        getWorldBorder().world = (WorldServer) this;
+        // From PlayerList.setPlayerFileData
+        getWorldBorder().addListener(new IBorderListener() {
+            public void onSizeChanged(WorldBorder worldborder, double d0) {
+                getServer().getHandle().sendAll(new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.SET_SIZE), worldborder.world);
+            }
+
+            public void onTransitionStarted(WorldBorder worldborder, double d0, double d1, long i) {
+                getServer().getHandle().sendAll(new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.LERP_SIZE), worldborder.world);
+            }
+
+            public void onCenterChanged(WorldBorder worldborder, double d0, double d1) {
+                getServer().getHandle().sendAll(new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.SET_CENTER), worldborder.world);
+            }
+
+            public void onWarningTimeChanged(WorldBorder worldborder, int i) {
+                getServer().getHandle().sendAll(new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.SET_WARNING_TIME), worldborder.world);
+            }
+
+            public void onWarningDistanceChanged(WorldBorder worldborder, int i) {
+                getServer().getHandle().sendAll(new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.SET_WARNING_BLOCKS), worldborder.world);
+            }
+
+            public void onDamageAmountChanged(WorldBorder worldborder, double d0) {
+            }
+
+            public void onDamageBufferChanged(WorldBorder worldborder, double d0) {
+            }
+        });
+        this.getServer().addWorld(this.world);
+        // CraftBukkit end
+        this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
+        this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
     }
 
-    public World init()
-    {
+    protected World(ISaveHandler saveHandlerIn, WorldInfo info, WorldProvider providerIn, Profiler profilerIn, boolean client) {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig(info.getWorldName()); // Spigot
+        this.world = DimensionManager.getWorld(0) != null ? DimensionManager.getWorld(0).getWorld() : null;
+        this.eventListeners = Lists.newArrayList(this.pathListener);
+        this.calendar = Calendar.getInstance();
+        this.worldScoreboard = new Scoreboard();
+        this.spawnHostileMobs = true;
+        this.spawnPeacefulMobs = true;
+        this.lightUpdateBlockList = new int[32768];
+        this.saveHandler = saveHandlerIn;
+        this.profiler = profilerIn;
+        this.worldInfo = info;
+        this.provider = providerIn;
+        this.isRemote = client;
+        this.worldBorder = providerIn.createWorldBorder();
+        perWorldStorage = DimensionManager.getWorld(0) != null ? DimensionManager.getWorld(0).mapStorage : new MapStorage(null);
+        this.mapStorage = DimensionManager.getWorld(0) != null ? DimensionManager.getWorld(0).mapStorage : new MapStorage(null);
+        this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
+        this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
+    }
+
+    public World init() {
         return this;
     }
 
-    public Biome getBiome(final BlockPos pos)
-    {
+    public Biome getBiome(final BlockPos pos) {
         return this.provider.getBiomeForCoords(pos);
     }
 
-    public Biome getBiomeForCoordsBody(final BlockPos pos)
-    {
-        if (this.isBlockLoaded(pos))
-        {
+    public Biome getBiomeForCoordsBody(final BlockPos pos) {
+        if (this.isBlockLoaded(pos)) {
             Chunk chunk = this.getChunkFromBlockCoords(pos);
 
-            try
-            {
+            try {
                 return chunk.getBiome(pos, this.provider.getBiomeProvider());
-            }
-            catch (Throwable throwable)
-            {
+            } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Getting biome");
                 CrashReportCategory crashreportcategory = crashreport.makeCategory("Coordinates of biome request");
-                crashreportcategory.addDetail("Location", new ICrashReportDetail<String>()
-                {
-                    public String call() throws Exception
-                    {
-                        return CrashReportCategory.getCoordinateInfo(pos);
-                    }
-                });
+                crashreportcategory.addDetail("Location", () -> CrashReportCategory.getCoordinateInfo(pos));
                 throw new ReportedException(crashreport);
             }
-        }
-        else
-        {
+        } else {
             return this.provider.getBiomeProvider().getBiome(pos, Biomes.PLAINS);
         }
     }
 
-    public BiomeProvider getBiomeProvider()
-    {
+    public BiomeProvider getBiomeProvider() {
         return this.provider.getBiomeProvider();
     }
 
     protected abstract IChunkProvider createChunkProvider();
 
-    public void initialize(WorldSettings settings)
-    {
+    public void initialize(WorldSettings settings) {
         this.worldInfo.setServerInitialized(true);
     }
 
     @Nullable
-    public MinecraftServer getMinecraftServer()
-    {
+    public MinecraftServer getMinecraftServer() {
         return null;
     }
 
     @SideOnly(Side.CLIENT)
-    public void setInitialSpawnLocation()
-    {
+    public void setInitialSpawnLocation() {
         this.setSpawnPoint(new BlockPos(8, 64, 8));
     }
 
-    public IBlockState getGroundAboveSeaLevel(BlockPos pos)
-    {
+    public IBlockState getGroundAboveSeaLevel(BlockPos pos) {
         BlockPos blockpos;
 
-        for (blockpos = new BlockPos(pos.getX(), this.getSeaLevel(), pos.getZ()); !this.isAirBlock(blockpos.up()); blockpos = blockpos.up())
-        {
-            ;
+        for (blockpos = new BlockPos(pos.getX(), this.getSeaLevel(), pos.getZ()); !this.isAirBlock(blockpos.up()); blockpos = blockpos.up()) {
         }
 
         return this.getBlockState(blockpos);
     }
 
-    public boolean isValid(BlockPos pos)
-    {
+    public boolean isValid(BlockPos pos) {
         return !this.isOutsideBuildHeight(pos) && pos.getX() >= -30000000 && pos.getZ() >= -30000000 && pos.getX() < 30000000 && pos.getZ() < 30000000;
     }
 
-    public boolean isOutsideBuildHeight(BlockPos pos)
-    {
+    public boolean isOutsideBuildHeight(BlockPos pos) {
         return pos.getY() < 0 || pos.getY() >= 256;
     }
 
-    public boolean isAirBlock(BlockPos pos)
-    {
+    public boolean isAirBlock(BlockPos pos) {
         return this.getBlockState(pos).getBlock().isAir(this.getBlockState(pos), this, pos);
     }
 
-    public boolean isBlockLoaded(BlockPos pos)
-    {
+    public boolean isBlockLoaded(BlockPos pos) {
         return this.isBlockLoaded(pos, true);
     }
 
-    public boolean isBlockLoaded(BlockPos pos, boolean allowEmpty)
-    {
+    public boolean isBlockLoaded(BlockPos pos, boolean allowEmpty) {
         return this.isChunkLoaded(pos.getX() >> 4, pos.getZ() >> 4, allowEmpty);
     }
 
-    public boolean isAreaLoaded(BlockPos center, int radius)
-    {
+    public boolean isAreaLoaded(BlockPos center, int radius) {
         return this.isAreaLoaded(center, radius, true);
     }
 
-    public boolean isAreaLoaded(BlockPos center, int radius, boolean allowEmpty)
-    {
+    public boolean isAreaLoaded(BlockPos center, int radius, boolean allowEmpty) {
         return this.isAreaLoaded(center.getX() - radius, center.getY() - radius, center.getZ() - radius, center.getX() + radius, center.getY() + radius, center.getZ() + radius, allowEmpty);
     }
 
-    public boolean isAreaLoaded(BlockPos from, BlockPos to)
-    {
+    public boolean isAreaLoaded(BlockPos from, BlockPos to) {
         return this.isAreaLoaded(from, to, true);
     }
 
-    public boolean isAreaLoaded(BlockPos from, BlockPos to, boolean allowEmpty)
-    {
+    public boolean isAreaLoaded(BlockPos from, BlockPos to, boolean allowEmpty) {
         return this.isAreaLoaded(from.getX(), from.getY(), from.getZ(), to.getX(), to.getY(), to.getZ(), allowEmpty);
     }
 
-    public boolean isAreaLoaded(StructureBoundingBox box)
-    {
+    public boolean isAreaLoaded(StructureBoundingBox box) {
         return this.isAreaLoaded(box, true);
     }
 
-    public boolean isAreaLoaded(StructureBoundingBox box, boolean allowEmpty)
-    {
+    public boolean isAreaLoaded(StructureBoundingBox box, boolean allowEmpty) {
         return this.isAreaLoaded(box.minX, box.minY, box.minZ, box.maxX, box.maxY, box.maxZ, allowEmpty);
     }
 
-    private boolean isAreaLoaded(int xStart, int yStart, int zStart, int xEnd, int yEnd, int zEnd, boolean allowEmpty)
-    {
-        if (yEnd >= 0 && yStart < 256)
-        {
+    private boolean isAreaLoaded(int xStart, int yStart, int zStart, int xEnd, int yEnd, int zEnd, boolean allowEmpty) {
+        if (yEnd >= 0 && yStart < 256) {
             xStart = xStart >> 4;
             zStart = zStart >> 4;
             xEnd = xEnd >> 4;
             zEnd = zEnd >> 4;
 
-            for (int i = xStart; i <= xEnd; ++i)
-            {
-                for (int j = zStart; j <= zEnd; ++j)
-                {
-                    if (!this.isChunkLoaded(i, j, allowEmpty))
-                    {
+            for (int i = xStart; i <= xEnd; ++i) {
+                for (int j = zStart; j <= zEnd; ++j) {
+                    if (!this.isChunkLoaded(i, j, allowEmpty)) {
                         return false;
                     }
                 }
             }
 
             return true;
-        }
-        else
-        {
+        } else {
             return false;
         }
     }
 
-    protected abstract boolean isChunkLoaded(int x, int z, boolean allowEmpty);
+    public abstract boolean isChunkLoaded(int x, int z, boolean allowEmpty);
 
-    public Chunk getChunkFromBlockCoords(BlockPos pos)
-    {
+    public Chunk getChunkFromBlockCoords(BlockPos pos) {
         return this.getChunkFromChunkCoords(pos.getX() >> 4, pos.getZ() >> 4);
     }
 
-    public Chunk getChunkFromChunkCoords(int chunkX, int chunkZ)
-    {
+    public Chunk getChunkFromChunkCoords(int chunkX, int chunkZ) {
         return this.chunkProvider.provideChunk(chunkX, chunkZ);
     }
 
-    public boolean isChunkGeneratedAt(int x, int z)
-    {
+    public boolean isChunkGeneratedAt(int x, int z) {
         return this.isChunkLoaded(x, z, false) ? true : this.chunkProvider.isChunkGeneratedAt(x, z);
     }
 
-    public boolean setBlockState(BlockPos pos, IBlockState newState, int flags)
-    {
-        if (this.isOutsideBuildHeight(pos))
-        {
-            return false;
+    public boolean setBlockState(BlockPos pos, IBlockState newState, int flags) {
+        // CraftBukkit start - tree generation
+        if (this.captureTreeGeneration && Bukkit.isPrimaryThread()) {
+            net.minecraftforge.common.util.BlockSnapshot blocksnapshot = null;
+
+            for (net.minecraftforge.common.util.BlockSnapshot previous : this.capturedBlockSnapshots) {
+                if (previous.getPos().equals(pos)) {
+                    blocksnapshot = previous;
+                    break;
+                }
+            }
+            if (blocksnapshot != null) {
+                this.capturedBlockSnapshots.remove(blocksnapshot);
+            }
+            this.capturedBlockSnapshots.add(new net.minecraftforge.common.util.BlockSnapshot(this, pos, newState, flags));
+            return true;
         }
-        else if (!this.isRemote && this.worldInfo.getTerrainType() == WorldType.DEBUG_ALL_BLOCK_STATES)
-        {
+        // CraftBukkit end
+        if (this.isOutsideBuildHeight(pos)) {
             return false;
-        }
-        else
-        {
+        } else if (!this.isRemote && this.worldInfo.getTerrainType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
+            return false;
+        } else {
             Chunk chunk = this.getChunkFromBlockCoords(pos);
 
             pos = pos.toImmutable(); // Forge - prevent mutable BlockPos leaks
             net.minecraftforge.common.util.BlockSnapshot blockSnapshot = null;
-            if (this.captureBlockSnapshots && !this.isRemote)
-            {
+            if (this.captureBlockSnapshots && !this.isRemote) {
                 blockSnapshot = net.minecraftforge.common.util.BlockSnapshot.getBlockSnapshot(this, pos, flags);
                 this.capturedBlockSnapshots.add(blockSnapshot);
             }
@@ -342,15 +432,11 @@
 
             IBlockState iblockstate = chunk.setBlockState(pos, newState);
 
-            if (iblockstate == null)
-            {
+            if (iblockstate == null) {
                 if (blockSnapshot != null) this.capturedBlockSnapshots.remove(blockSnapshot);
                 return false;
-            }
-            else
-            {
-                if (newState.getLightOpacity(this, pos) != oldOpacity || newState.getLightValue(this, pos) != oldLight)
-                {
+            } else {
+                if (newState.getLightOpacity(this, pos) != oldOpacity || newState.getLightValue(this, pos) != oldLight) {
                     this.profiler.startSection("checkLight");
                     this.checkLight(pos);
                     this.profiler.endSection();
@@ -366,53 +452,41 @@
     }
 
     // Split off from original setBlockState(BlockPos, IBlockState, int) method in order to directly send client and physic updates
-    public void markAndNotifyBlock(BlockPos pos, @Nullable Chunk chunk, IBlockState iblockstate, IBlockState newState, int flags)
-    {
+    public void markAndNotifyBlock(BlockPos pos, @Nullable Chunk chunk, IBlockState iblockstate, IBlockState newState, int flags) {
         Block block = newState.getBlock();
         {
             {
-                if ((flags & 2) != 0 && (!this.isRemote || (flags & 4) == 0) && (chunk == null || chunk.isPopulated()))
-                {
+                if ((flags & 2) != 0 && (!this.isRemote || (flags & 4) == 0) && (chunk == null || chunk.isPopulated())) {
                     this.notifyBlockUpdate(pos, iblockstate, newState, flags);
                 }
 
-                if (!this.isRemote && (flags & 1) != 0)
-                {
+                if (!this.isRemote && (flags & 1) != 0) {
                     this.notifyNeighborsRespectDebug(pos, iblockstate.getBlock(), true);
 
-                    if (newState.hasComparatorInputOverride())
-                    {
+                    if (newState.hasComparatorInputOverride()) {
                         this.updateComparatorOutputLevel(pos, block);
                     }
-                }
-                else if (!this.isRemote && (flags & 16) == 0)
-                {
+                } else if (!this.isRemote && (flags & 16) == 0) {
                     this.updateObservingBlocksAt(pos, block);
                 }
             }
         }
     }
 
-    public boolean setBlockToAir(BlockPos pos)
-    {
+    public boolean setBlockToAir(BlockPos pos) {
         return this.setBlockState(pos, Blocks.AIR.getDefaultState(), 3);
     }
 
-    public boolean destroyBlock(BlockPos pos, boolean dropBlock)
-    {
+    public boolean destroyBlock(BlockPos pos, boolean dropBlock) {
         IBlockState iblockstate = this.getBlockState(pos);
         Block block = iblockstate.getBlock();
 
-        if (block.isAir(iblockstate, this, pos))
-        {
+        if (block.isAir(iblockstate, this, pos)) {
             return false;
-        }
-        else
-        {
+        } else {
             this.playEvent(2001, pos, Block.getStateId(iblockstate));
 
-            if (dropBlock)
-            {
+            if (dropBlock) {
                 block.dropBlockAsItem(this, pos, iblockstate, 0);
             }
 
@@ -420,40 +494,36 @@
         }
     }
 
-    public boolean setBlockState(BlockPos pos, IBlockState state)
-    {
+    public boolean setBlockState(BlockPos pos, IBlockState state) {
         return this.setBlockState(pos, state, 3);
     }
 
-    public void notifyBlockUpdate(BlockPos pos, IBlockState oldState, IBlockState newState, int flags)
-    {
-        for (int i = 0; i < this.eventListeners.size(); ++i)
-        {
-            ((IWorldEventListener)this.eventListeners.get(i)).notifyBlockUpdate(this, pos, oldState, newState, flags);
+    public void notifyBlockUpdate(BlockPos pos, IBlockState oldState, IBlockState newState, int flags) {
+        for (int i = 0; i < this.eventListeners.size(); ++i) {
+            ((IWorldEventListener) this.eventListeners.get(i)).notifyBlockUpdate(this, pos, oldState, newState, flags);
         }
     }
 
-    public void notifyNeighborsRespectDebug(BlockPos pos, Block blockType, boolean p_175722_3_)
-    {
-        if (this.worldInfo.getTerrainType() != WorldType.DEBUG_ALL_BLOCK_STATES)
-        {
+    public void notifyNeighborsRespectDebug(BlockPos pos, Block blockType, boolean p_175722_3_) {
+        if (this.worldInfo.getTerrainType() != WorldType.DEBUG_ALL_BLOCK_STATES) {
+            // CraftBukkit start
+            if (populating) {
+                return;
+            }
+            // CraftBukkit end
             this.notifyNeighborsOfStateChange(pos, blockType, p_175722_3_);
         }
     }
 
-    public void markBlocksDirtyVertical(int x, int z, int y1, int y2)
-    {
-        if (y1 > y2)
-        {
+    public void markBlocksDirtyVertical(int x, int z, int y1, int y2) {
+        if (y1 > y2) {
             int i = y2;
             y2 = y1;
             y1 = i;
         }
 
-        if (this.provider.hasSkyLight())
-        {
-            for (int j = y1; j <= y2; ++j)
-            {
+        if (this.provider.hasSkyLight()) {
+            for (int j = y1; j <= y2; ++j) {
                 this.checkLightFor(EnumSkyBlock.SKY, new BlockPos(x, j, z));
             }
         }
@@ -461,21 +531,17 @@
         this.markBlockRangeForRenderUpdate(x, y1, z, x, y2, z);
     }
 
-    public void markBlockRangeForRenderUpdate(BlockPos rangeMin, BlockPos rangeMax)
-    {
+    public void markBlockRangeForRenderUpdate(BlockPos rangeMin, BlockPos rangeMax) {
         this.markBlockRangeForRenderUpdate(rangeMin.getX(), rangeMin.getY(), rangeMin.getZ(), rangeMax.getX(), rangeMax.getY(), rangeMax.getZ());
     }
 
-    public void markBlockRangeForRenderUpdate(int x1, int y1, int z1, int x2, int y2, int z2)
-    {
-        for (int i = 0; i < this.eventListeners.size(); ++i)
-        {
-            ((IWorldEventListener)this.eventListeners.get(i)).markBlockRangeForRenderUpdate(x1, y1, z1, x2, y2, z2);
+    public void markBlockRangeForRenderUpdate(int x1, int y1, int z1, int x2, int y2, int z2) {
+        for (int i = 0; i < this.eventListeners.size(); ++i) {
+            ((IWorldEventListener) this.eventListeners.get(i)).markBlockRangeForRenderUpdate(x1, y1, z1, x2, y2, z2);
         }
     }
 
-    public void updateObservingBlocksAt(BlockPos pos, Block blockType)
-    {
+    public void updateObservingBlocksAt(BlockPos pos, Block blockType) {
         this.observedNeighborChanged(pos.west(), blockType, pos);
         this.observedNeighborChanged(pos.east(), blockType, pos);
         this.observedNeighborChanged(pos.down(), blockType, pos);
@@ -484,9 +550,8 @@
         this.observedNeighborChanged(pos.south(), blockType, pos);
     }
 
-    public void notifyNeighborsOfStateChange(BlockPos pos, Block blockType, boolean updateObservers)
-    {
-        if(net.minecraftforge.event.ForgeEventFactory.onNeighborNotify(this, pos, this.getBlockState(pos), java.util.EnumSet.allOf(EnumFacing.class), updateObservers).isCanceled())
+    public void notifyNeighborsOfStateChange(BlockPos pos, Block blockType, boolean updateObservers) {
+        if (net.minecraftforge.event.ForgeEventFactory.onNeighborNotify(this, pos, this.getBlockState(pos), java.util.EnumSet.allOf(EnumFacing.class), updateObservers).isCanceled())
             return;
 
         this.neighborChanged(pos.west(), blockType, pos);
@@ -496,74 +561,67 @@
         this.neighborChanged(pos.north(), blockType, pos);
         this.neighborChanged(pos.south(), blockType, pos);
 
-        if (updateObservers)
-        {
+        if (updateObservers) {
             this.updateObservingBlocksAt(pos, blockType);
         }
     }
 
-    public void notifyNeighborsOfStateExcept(BlockPos pos, Block blockType, EnumFacing skipSide)
-    {
+    public void notifyNeighborsOfStateExcept(BlockPos pos, Block blockType, EnumFacing skipSide) {
         java.util.EnumSet<EnumFacing> directions = java.util.EnumSet.allOf(EnumFacing.class);
         directions.remove(skipSide);
-        if(net.minecraftforge.event.ForgeEventFactory.onNeighborNotify(this, pos, this.getBlockState(pos), directions, false).isCanceled())
+        if (net.minecraftforge.event.ForgeEventFactory.onNeighborNotify(this, pos, this.getBlockState(pos), directions, false).isCanceled())
             return;
 
-        if (skipSide != EnumFacing.WEST)
-        {
+        if (skipSide != EnumFacing.WEST) {
             this.neighborChanged(pos.west(), blockType, pos);
         }
 
-        if (skipSide != EnumFacing.EAST)
-        {
+        if (skipSide != EnumFacing.EAST) {
             this.neighborChanged(pos.east(), blockType, pos);
         }
 
-        if (skipSide != EnumFacing.DOWN)
-        {
+        if (skipSide != EnumFacing.DOWN) {
             this.neighborChanged(pos.down(), blockType, pos);
         }
 
-        if (skipSide != EnumFacing.UP)
-        {
+        if (skipSide != EnumFacing.UP) {
             this.neighborChanged(pos.up(), blockType, pos);
         }
 
-        if (skipSide != EnumFacing.NORTH)
-        {
+        if (skipSide != EnumFacing.NORTH) {
             this.neighborChanged(pos.north(), blockType, pos);
         }
 
-        if (skipSide != EnumFacing.SOUTH)
-        {
+        if (skipSide != EnumFacing.SOUTH) {
             this.neighborChanged(pos.south(), blockType, pos);
         }
     }
 
-    public void neighborChanged(BlockPos pos, final Block blockIn, BlockPos fromPos)
-    {
-        if (!this.isRemote)
-        {
+    public void neighborChanged(BlockPos pos, final Block blockIn, BlockPos fromPos) {
+        if (!this.isRemote) {
             IBlockState iblockstate = this.getBlockState(pos);
 
-            try
-            {
+            try {
+                // CraftBukkit start
+                CraftWorld world = ((WorldServer) this).getWorld();
+                if (world != null) {
+                    BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(pos.getX(), pos.getY(), pos.getZ()), CraftMagicNumbers.getId(blockIn));
+                    this.getServer().getPluginManager().callEvent(event);
+
+                    if (event.isCancelled()) {
+                        return;
+                    }
+                }
+                // CraftBukkit end
                 iblockstate.neighborChanged(this, pos, blockIn, fromPos);
-            }
-            catch (Throwable throwable)
-            {
+            } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception while updating neighbours");
                 CrashReportCategory crashreportcategory = crashreport.makeCategory("Block being updated");
-                crashreportcategory.addDetail("Source block type", new ICrashReportDetail<String>()
-                {
-                    public String call() throws Exception
-                    {
-                        try
-                        {
+                crashreportcategory.addDetail("Source block type", new ICrashReportDetail<String>() {
+                    public String call() throws Exception {
+                        try {
                             return String.format("ID #%d (%s // %s // %s)", Block.getIdFromBlock(blockIn), blockIn.getUnlocalizedName(), blockIn.getClass().getName(), blockIn.getRegistryName());
-                        }
-                        catch (Throwable var2)
-                        {
+                        } catch (Throwable var2) {
                             return "ID #" + Block.getIdFromBlock(blockIn);
                         }
                     }
@@ -574,32 +632,25 @@
         }
     }
 
-    public void observedNeighborChanged(BlockPos pos, final Block p_190529_2_, BlockPos p_190529_3_)
-    {
-        if (!this.isRemote)
-        {
+    public void observedNeighborChanged(BlockPos pos, final Block p_190529_2_, BlockPos p_190529_3_) {
+        if (!this.isRemote) {
             IBlockState iblockstate = this.getBlockState(pos);
 
-            if (true)
-            {
-                try
-                {
+            if (true) {
+                try {
                     iblockstate.getBlock().observedNeighborChange(iblockstate, this, pos, p_190529_2_, p_190529_3_);
-                }
-                catch (Throwable throwable)
-                {
+                } catch (StackOverflowError stackoverflowerror) { // Spigot Start
+                    haveWeSilencedAPhysicsCrash = true;
+                    blockLocation = pos.getX() + ", " + pos.getY() + ", " + pos.getZ();
+                    // Spigot End
+                } catch (Throwable throwable) {
                     CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception while updating neighbours");
                     CrashReportCategory crashreportcategory = crashreport.makeCategory("Block being updated");
-                    crashreportcategory.addDetail("Source block type", new ICrashReportDetail<String>()
-                    {
-                        public String call() throws Exception
-                        {
-                            try
-                            {
+                    crashreportcategory.addDetail("Source block type", new ICrashReportDetail<String>() {
+                        public String call() throws Exception {
+                            try {
                                 return String.format("ID #%d (%s // %s // %s)", Block.getIdFromBlock(p_190529_2_), p_190529_2_.getUnlocalizedName(), p_190529_2_.getClass().getName(), p_190529_2_.getRegistryName());
-                            }
-                            catch (Throwable var2)
-                            {
+                            } catch (Throwable var2) {
                                 return "ID #" + Block.getIdFromBlock(p_190529_2_);
                             }
                         }
@@ -611,38 +662,27 @@
         }
     }
 
-    public boolean isBlockTickPending(BlockPos pos, Block blockType)
-    {
+    public boolean isBlockTickPending(BlockPos pos, Block blockType) {
         return false;
     }
 
-    public boolean canSeeSky(BlockPos pos)
-    {
+    public boolean canSeeSky(BlockPos pos) {
         return this.getChunkFromBlockCoords(pos).canSeeSky(pos);
     }
 
-    public boolean canBlockSeeSky(BlockPos pos)
-    {
-        if (pos.getY() >= this.getSeaLevel())
-        {
+    public boolean canBlockSeeSky(BlockPos pos) {
+        if (pos.getY() >= this.getSeaLevel()) {
             return this.canSeeSky(pos);
-        }
-        else
-        {
+        } else {
             BlockPos blockpos = new BlockPos(pos.getX(), this.getSeaLevel(), pos.getZ());
 
-            if (!this.canSeeSky(blockpos))
-            {
+            if (!this.canSeeSky(blockpos)) {
                 return false;
-            }
-            else
-            {
-                for (BlockPos blockpos1 = blockpos.down(); blockpos1.getY() > pos.getY(); blockpos1 = blockpos1.down())
-                {
+            } else {
+                for (BlockPos blockpos1 = blockpos.down(); blockpos1.getY() > pos.getY(); blockpos1 = blockpos1.down()) {
                     IBlockState iblockstate = this.getBlockState(blockpos1);
 
-                    if (iblockstate.getBlock().getLightOpacity(iblockstate, this, blockpos) > 0 && !iblockstate.getMaterial().isLiquid())
-                    {
+                    if (iblockstate.getBlock().getLightOpacity(iblockstate, this, blockpos) > 0 && !iblockstate.getMaterial().isLiquid()) {
                         return false;
                     }
                 }
@@ -652,16 +692,11 @@
         }
     }
 
-    public int getLight(BlockPos pos)
-    {
-        if (pos.getY() < 0)
-        {
+    public int getLight(BlockPos pos) {
+        if (pos.getY() < 0) {
             return 0;
-        }
-        else
-        {
-            if (pos.getY() >= 256)
-            {
+        } else {
+            if (pos.getY() >= 256) {
                 pos = new BlockPos(pos.getX(), 255, pos.getZ());
             }
 
@@ -669,88 +704,100 @@
         }
     }
 
-    public int getLightFromNeighbors(BlockPos pos)
-    {
+    // Paper start - test if meets light level, return faster
+    // logic copied from below
+    public boolean isLightLevel(BlockPos blockposition, int level) {
+        if (blockposition.isValidLocation()) {
+            if (this.getBlockState(blockposition).useNeighborBrightness()) {
+                if (this.getLight(blockposition.up(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(blockposition.east(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(blockposition.west(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(blockposition.south(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(blockposition.north(), false) >= level) {
+                    return true;
+                }
+                return false;
+            } else {
+                if (blockposition.getY() >= 256) {
+                    blockposition = new BlockPos(blockposition.getX(), 255, blockposition.getZ());
+                }
+
+                Chunk chunk = this.getChunkFromBlockCoords(blockposition);
+                return chunk.getLightSubtracted(blockposition, this.getSkylightSubtracted()) >= level;
+            }
+        } else {
+            return true;
+        }
+    }
+    // Paper end
+
+    public int getLightFromNeighbors(BlockPos pos) {
         return this.getLight(pos, true);
     }
 
-    public int getLight(BlockPos pos, boolean checkNeighbors)
-    {
-        if (pos.getX() >= -30000000 && pos.getZ() >= -30000000 && pos.getX() < 30000000 && pos.getZ() < 30000000)
-        {
-            if (checkNeighbors && this.getBlockState(pos).useNeighborBrightness())
-            {
+    public int getLight(BlockPos pos, boolean checkNeighbors) {
+        if (pos.getX() >= -30000000 && pos.getZ() >= -30000000 && pos.getX() < 30000000 && pos.getZ() < 30000000) {
+            if (checkNeighbors && this.getBlockState(pos).useNeighborBrightness()) {
                 int i1 = this.getLight(pos.up(), false);
                 int i = this.getLight(pos.east(), false);
                 int j = this.getLight(pos.west(), false);
                 int k = this.getLight(pos.south(), false);
                 int l = this.getLight(pos.north(), false);
 
-                if (i > i1)
-                {
+                if (i > i1) {
                     i1 = i;
                 }
 
-                if (j > i1)
-                {
+                if (j > i1) {
                     i1 = j;
                 }
 
-                if (k > i1)
-                {
+                if (k > i1) {
                     i1 = k;
                 }
 
-                if (l > i1)
-                {
+                if (l > i1) {
                     i1 = l;
                 }
 
                 return i1;
-            }
-            else if (pos.getY() < 0)
-            {
+            } else if (pos.getY() < 0) {
                 return 0;
-            }
-            else
-            {
-                if (pos.getY() >= 256)
-                {
+            } else {
+                if (pos.getY() >= 256) {
                     pos = new BlockPos(pos.getX(), 255, pos.getZ());
                 }
 
                 Chunk chunk = this.getChunkFromBlockCoords(pos);
                 return chunk.getLightSubtracted(pos, this.skylightSubtracted);
             }
-        }
-        else
-        {
+        } else {
             return 15;
         }
     }
 
-    public BlockPos getHeight(BlockPos pos)
-    {
+    public BlockPos getHeight(BlockPos pos) {
         return new BlockPos(pos.getX(), this.getHeight(pos.getX(), pos.getZ()), pos.getZ());
     }
 
-    public int getHeight(int x, int z)
-    {
+    public int getHeight(int x, int z) {
         int i;
 
-        if (x >= -30000000 && z >= -30000000 && x < 30000000 && z < 30000000)
-        {
-            if (this.isChunkLoaded(x >> 4, z >> 4, true))
-            {
+        if (x >= -30000000 && z >= -30000000 && x < 30000000 && z < 30000000) {
+            if (this.isChunkLoaded(x >> 4, z >> 4, true)) {
                 i = this.getChunkFromChunkCoords(x >> 4, z >> 4).getHeightValue(x & 15, z & 15);
-            }
-            else
-            {
+            } else {
                 i = 0;
             }
-        }
-        else
-        {
+        } else {
             i = this.getSeaLevel() + 1;
         }
 
@@ -758,114 +805,81 @@
     }
 
     @Deprecated
-    public int getChunksLowestHorizon(int x, int z)
-    {
-        if (x >= -30000000 && z >= -30000000 && x < 30000000 && z < 30000000)
-        {
-            if (!this.isChunkLoaded(x >> 4, z >> 4, true))
-            {
+    public int getChunksLowestHorizon(int x, int z) {
+        if (x >= -30000000 && z >= -30000000 && x < 30000000 && z < 30000000) {
+            if (!this.isChunkLoaded(x >> 4, z >> 4, true)) {
                 return 0;
-            }
-            else
-            {
+            } else {
                 Chunk chunk = this.getChunkFromChunkCoords(x >> 4, z >> 4);
                 return chunk.getLowestHeight();
             }
-        }
-        else
-        {
+        } else {
             return this.getSeaLevel() + 1;
         }
     }
 
     @SideOnly(Side.CLIENT)
-    public int getLightFromNeighborsFor(EnumSkyBlock type, BlockPos pos)
-    {
-        if (!this.provider.hasSkyLight() && type == EnumSkyBlock.SKY)
-        {
+    public int getLightFromNeighborsFor(EnumSkyBlock type, BlockPos pos) {
+        if (!this.provider.hasSkyLight() && type == EnumSkyBlock.SKY) {
             return 0;
-        }
-        else
-        {
-            if (pos.getY() < 0)
-            {
+        } else {
+            if (pos.getY() < 0) {
                 pos = new BlockPos(pos.getX(), 0, pos.getZ());
             }
 
-            if (!this.isValid(pos))
-            {
+            if (!this.isValid(pos)) {
                 return type.defaultLightValue;
-            }
-            else if (!this.isBlockLoaded(pos))
-            {
+            } else if (!this.isBlockLoaded(pos)) {
                 return type.defaultLightValue;
-            }
-            else if (this.getBlockState(pos).useNeighborBrightness())
-            {
+            } else if (this.getBlockState(pos).useNeighborBrightness()) {
                 int i1 = this.getLightFor(type, pos.up());
                 int i = this.getLightFor(type, pos.east());
                 int j = this.getLightFor(type, pos.west());
                 int k = this.getLightFor(type, pos.south());
                 int l = this.getLightFor(type, pos.north());
 
-                if (i > i1)
-                {
+                if (i > i1) {
                     i1 = i;
                 }
 
-                if (j > i1)
-                {
+                if (j > i1) {
                     i1 = j;
                 }
 
-                if (k > i1)
-                {
+                if (k > i1) {
                     i1 = k;
                 }
 
-                if (l > i1)
-                {
+                if (l > i1) {
                     i1 = l;
                 }
 
                 return i1;
-            }
-            else
-            {
+            } else {
                 Chunk chunk = this.getChunkFromBlockCoords(pos);
                 return chunk.getLightFor(type, pos);
             }
         }
     }
 
-    public int getLightFor(EnumSkyBlock type, BlockPos pos)
-    {
-        if (pos.getY() < 0)
-        {
+    public int getLightFor(EnumSkyBlock type, BlockPos pos) {
+        if (pos.getY() < 0) {
             pos = new BlockPos(pos.getX(), 0, pos.getZ());
         }
 
-        if (!this.isValid(pos))
-        {
+        if (!this.isValid(pos)) {
             return type.defaultLightValue;
-        }
-        else if (!this.isBlockLoaded(pos))
-        {
+        } else if (!this.isBlockLoaded(pos)) {
             return type.defaultLightValue;
-        }
-        else
-        {
+        } else {
             Chunk chunk = this.getChunkFromBlockCoords(pos);
             return chunk.getLightFor(type, pos);
         }
     }
 
-    public void setLightFor(EnumSkyBlock type, BlockPos pos, int lightValue)
-    {
-        if (this.isValid(pos))
-        {
-            if (this.isBlockLoaded(pos))
-            {
+    public void setLightFor(EnumSkyBlock type, BlockPos pos, int lightValue) {
+        if (this.isValid(pos)) {
+            if (this.isBlockLoaded(pos)) {
                 Chunk chunk = this.getChunkFromBlockCoords(pos);
                 chunk.setLightFor(type, pos, lightValue);
                 this.notifyLightSet(pos);
@@ -873,70 +887,64 @@
         }
     }
 
-    public void notifyLightSet(BlockPos pos)
-    {
-        for (int i = 0; i < this.eventListeners.size(); ++i)
-        {
-            ((IWorldEventListener)this.eventListeners.get(i)).notifyLightSet(pos);
+    public void notifyLightSet(BlockPos pos) {
+        for (int i = 0; i < this.eventListeners.size(); ++i) {
+            ((IWorldEventListener) this.eventListeners.get(i)).notifyLightSet(pos);
         }
     }
 
     @SideOnly(Side.CLIENT)
-    public int getCombinedLight(BlockPos pos, int lightValue)
-    {
+    public int getCombinedLight(BlockPos pos, int lightValue) {
         int i = this.getLightFromNeighborsFor(EnumSkyBlock.SKY, pos);
         int j = this.getLightFromNeighborsFor(EnumSkyBlock.BLOCK, pos);
 
-        if (j < lightValue)
-        {
+        if (j < lightValue) {
             j = lightValue;
         }
 
         return i << 20 | j << 4;
     }
 
-    public float getLightBrightness(BlockPos pos)
-    {
+    public float getLightBrightness(BlockPos pos) {
         return this.provider.getLightBrightnessTable()[this.getLightFromNeighbors(pos)];
     }
 
-    public IBlockState getBlockState(BlockPos pos)
-    {
-        if (this.isOutsideBuildHeight(pos))
-        {
-            return Blocks.AIR.getDefaultState();
+    public IBlockState getBlockState(BlockPos pos) {
+        // CraftBukkit start - tree generation
+        if (captureTreeGeneration) {
+            for (net.minecraftforge.common.util.BlockSnapshot blocksnapshot : this.capturedBlockSnapshots) {
+                if (blocksnapshot.getPos().equals(pos)) {
+                    return blocksnapshot.getReplacedBlock();
+                }
+            }
         }
-        else
-        {
+        // CraftBukkit end
+        if (this.isOutsideBuildHeight(pos)) {
+            return Blocks.AIR.getDefaultState();
+        } else {
             Chunk chunk = this.getChunkFromBlockCoords(pos);
             return chunk.getBlockState(pos);
         }
     }
 
-    public boolean isDaytime()
-    {
+    public boolean isDaytime() {
         return this.provider.isDaytime();
     }
 
     @Nullable
-    public RayTraceResult rayTraceBlocks(Vec3d start, Vec3d end)
-    {
+    public RayTraceResult rayTraceBlocks(Vec3d start, Vec3d end) {
         return this.rayTraceBlocks(start, end, false, false, false);
     }
 
     @Nullable
-    public RayTraceResult rayTraceBlocks(Vec3d start, Vec3d end, boolean stopOnLiquid)
-    {
+    public RayTraceResult rayTraceBlocks(Vec3d start, Vec3d end, boolean stopOnLiquid) {
         return this.rayTraceBlocks(start, end, stopOnLiquid, false, false);
     }
 
     @Nullable
-    public RayTraceResult rayTraceBlocks(Vec3d vec31, Vec3d vec32, boolean stopOnLiquid, boolean ignoreBlockWithoutBoundingBox, boolean returnLastUncollidableBlock)
-    {
-        if (!Double.isNaN(vec31.x) && !Double.isNaN(vec31.y) && !Double.isNaN(vec31.z))
-        {
-            if (!Double.isNaN(vec32.x) && !Double.isNaN(vec32.y) && !Double.isNaN(vec32.z))
-            {
+    public RayTraceResult rayTraceBlocks(Vec3d vec31, Vec3d vec32, boolean stopOnLiquid, boolean ignoreBlockWithoutBoundingBox, boolean returnLastUncollidableBlock) {
+        if (!Double.isNaN(vec31.x) && !Double.isNaN(vec31.y) && !Double.isNaN(vec31.z)) {
+            if (!Double.isNaN(vec32.x) && !Double.isNaN(vec32.y) && !Double.isNaN(vec32.z)) {
                 int i = MathHelper.floor(vec32.x);
                 int j = MathHelper.floor(vec32.y);
                 int k = MathHelper.floor(vec32.z);
@@ -947,12 +955,10 @@
                 IBlockState iblockstate = this.getBlockState(blockpos);
                 Block block = iblockstate.getBlock();
 
-                if ((!ignoreBlockWithoutBoundingBox || iblockstate.getCollisionBoundingBox(this, blockpos) != Block.NULL_AABB) && block.canCollideCheck(iblockstate, stopOnLiquid))
-                {
+                if ((!ignoreBlockWithoutBoundingBox || iblockstate.getCollisionBoundingBox(this, blockpos) != Block.NULL_AABB) && block.canCollideCheck(iblockstate, stopOnLiquid)) {
                     RayTraceResult raytraceresult = iblockstate.collisionRayTrace(this, blockpos, vec31, vec32);
 
-                    if (raytraceresult != null)
-                    {
+                    if (raytraceresult != null) {
                         return raytraceresult;
                     }
                 }
@@ -960,15 +966,12 @@
                 RayTraceResult raytraceresult2 = null;
                 int k1 = 200;
 
-                while (k1-- >= 0)
-                {
-                    if (Double.isNaN(vec31.x) || Double.isNaN(vec31.y) || Double.isNaN(vec31.z))
-                    {
+                while (k1-- >= 0) {
+                    if (Double.isNaN(vec31.x) || Double.isNaN(vec31.y) || Double.isNaN(vec31.z)) {
                         return null;
                     }
 
-                    if (l == i && i1 == j && j1 == k)
-                    {
+                    if (l == i && i1 == j && j1 == k) {
                         return returnLastUncollidableBlock ? raytraceresult2 : null;
                     }
 
@@ -979,42 +982,27 @@
                     double d1 = 999.0D;
                     double d2 = 999.0D;
 
-                    if (i > l)
-                    {
-                        d0 = (double)l + 1.0D;
-                    }
-                    else if (i < l)
-                    {
-                        d0 = (double)l + 0.0D;
-                    }
-                    else
-                    {
+                    if (i > l) {
+                        d0 = (double) l + 1.0D;
+                    } else if (i < l) {
+                        d0 = (double) l + 0.0D;
+                    } else {
                         flag2 = false;
                     }
 
-                    if (j > i1)
-                    {
-                        d1 = (double)i1 + 1.0D;
-                    }
-                    else if (j < i1)
-                    {
-                        d1 = (double)i1 + 0.0D;
-                    }
-                    else
-                    {
+                    if (j > i1) {
+                        d1 = (double) i1 + 1.0D;
+                    } else if (j < i1) {
+                        d1 = (double) i1 + 0.0D;
+                    } else {
                         flag = false;
                     }
 
-                    if (k > j1)
-                    {
-                        d2 = (double)j1 + 1.0D;
-                    }
-                    else if (k < j1)
-                    {
-                        d2 = (double)j1 + 0.0D;
-                    }
-                    else
-                    {
+                    if (k > j1) {
+                        d2 = (double) j1 + 1.0D;
+                    } else if (k < j1) {
+                        d2 = (double) j1 + 0.0D;
+                    } else {
                         flag1 = false;
                     }
 
@@ -1025,50 +1013,39 @@
                     double d7 = vec32.y - vec31.y;
                     double d8 = vec32.z - vec31.z;
 
-                    if (flag2)
-                    {
+                    if (flag2) {
                         d3 = (d0 - vec31.x) / d6;
                     }
 
-                    if (flag)
-                    {
+                    if (flag) {
                         d4 = (d1 - vec31.y) / d7;
                     }
 
-                    if (flag1)
-                    {
+                    if (flag1) {
                         d5 = (d2 - vec31.z) / d8;
                     }
 
-                    if (d3 == -0.0D)
-                    {
+                    if (d3 == -0.0D) {
                         d3 = -1.0E-4D;
                     }
 
-                    if (d4 == -0.0D)
-                    {
+                    if (d4 == -0.0D) {
                         d4 = -1.0E-4D;
                     }
 
-                    if (d5 == -0.0D)
-                    {
+                    if (d5 == -0.0D) {
                         d5 = -1.0E-4D;
                     }
 
                     EnumFacing enumfacing;
 
-                    if (d3 < d4 && d3 < d5)
-                    {
+                    if (d3 < d4 && d3 < d5) {
                         enumfacing = i > l ? EnumFacing.WEST : EnumFacing.EAST;
                         vec31 = new Vec3d(d0, vec31.y + d7 * d3, vec31.z + d8 * d3);
-                    }
-                    else if (d4 < d5)
-                    {
+                    } else if (d4 < d5) {
                         enumfacing = j > i1 ? EnumFacing.DOWN : EnumFacing.UP;
                         vec31 = new Vec3d(vec31.x + d6 * d4, d1, vec31.z + d8 * d4);
-                    }
-                    else
-                    {
+                    } else {
                         enumfacing = k > j1 ? EnumFacing.NORTH : EnumFacing.SOUTH;
                         vec31 = new Vec3d(vec31.x + d6 * d5, vec31.y + d7 * d5, d2);
                     }
@@ -1080,44 +1057,33 @@
                     IBlockState iblockstate1 = this.getBlockState(blockpos);
                     Block block1 = iblockstate1.getBlock();
 
-                    if (!ignoreBlockWithoutBoundingBox || iblockstate1.getMaterial() == Material.PORTAL || iblockstate1.getCollisionBoundingBox(this, blockpos) != Block.NULL_AABB)
-                    {
-                        if (block1.canCollideCheck(iblockstate1, stopOnLiquid))
-                        {
+                    if (!ignoreBlockWithoutBoundingBox || iblockstate1.getMaterial() == Material.PORTAL || iblockstate1.getCollisionBoundingBox(this, blockpos) != Block.NULL_AABB) {
+                        if (block1.canCollideCheck(iblockstate1, stopOnLiquid)) {
                             RayTraceResult raytraceresult1 = iblockstate1.collisionRayTrace(this, blockpos, vec31, vec32);
 
-                            if (raytraceresult1 != null)
-                            {
+                            if (raytraceresult1 != null) {
                                 return raytraceresult1;
                             }
-                        }
-                        else
-                        {
+                        } else {
                             raytraceresult2 = new RayTraceResult(RayTraceResult.Type.MISS, vec31, enumfacing, blockpos);
                         }
                     }
                 }
 
                 return returnLastUncollidableBlock ? raytraceresult2 : null;
-            }
-            else
-            {
+            } else {
                 return null;
             }
-        }
-        else
-        {
+        } else {
             return null;
         }
     }
 
-    public void playSound(@Nullable EntityPlayer player, BlockPos pos, SoundEvent soundIn, SoundCategory category, float volume, float pitch)
-    {
-        this.playSound(player, (double)pos.getX() + 0.5D, (double)pos.getY() + 0.5D, (double)pos.getZ() + 0.5D, soundIn, category, volume, pitch);
+    public void playSound(@Nullable EntityPlayer player, BlockPos pos, SoundEvent soundIn, SoundCategory category, float volume, float pitch) {
+        this.playSound(player, (double) pos.getX() + 0.5D, (double) pos.getY() + 0.5D, (double) pos.getZ() + 0.5D, soundIn, category, volume, pitch);
     }
 
-    public void playSound(@Nullable EntityPlayer player, double x, double y, double z, SoundEvent soundIn, SoundCategory category, float volume, float pitch)
-    {
+    public void playSound(@Nullable EntityPlayer player, double x, double y, double z, SoundEvent soundIn, SoundCategory category, float volume, float pitch) {
         net.minecraftforge.event.entity.PlaySoundAtEntityEvent event = net.minecraftforge.event.ForgeEventFactory.onPlaySoundAtEntity(player, soundIn, category, volume, pitch);
         if (event.isCanceled() || event.getSound() == null) return;
         soundIn = event.getSound();
@@ -1125,140 +1091,173 @@
         volume = event.getVolume();
         pitch = event.getPitch();
 
-        for (int i = 0; i < this.eventListeners.size(); ++i)
-        {
-            ((IWorldEventListener)this.eventListeners.get(i)).playSoundToAllNearExcept(player, soundIn, category, x, y, z, volume, pitch);
+        for (int i = 0; i < this.eventListeners.size(); ++i) {
+            ((IWorldEventListener) this.eventListeners.get(i)).playSoundToAllNearExcept(player, soundIn, category, x, y, z, volume, pitch);
         }
     }
 
-    public void playSound(double x, double y, double z, SoundEvent soundIn, SoundCategory category, float volume, float pitch, boolean distanceDelay)
-    {
+    public void playSound(double x, double y, double z, SoundEvent soundIn, SoundCategory category, float volume, float pitch, boolean distanceDelay) {
     }
 
-    public void playRecord(BlockPos blockPositionIn, @Nullable SoundEvent soundEventIn)
-    {
-        for (int i = 0; i < this.eventListeners.size(); ++i)
-        {
-            ((IWorldEventListener)this.eventListeners.get(i)).playRecord(soundEventIn, blockPositionIn);
+    public void playRecord(BlockPos blockPositionIn, @Nullable SoundEvent soundEventIn) {
+        for (int i = 0; i < this.eventListeners.size(); ++i) {
+            ((IWorldEventListener) this.eventListeners.get(i)).playRecord(soundEventIn, blockPositionIn);
         }
     }
 
-    public void spawnParticle(EnumParticleTypes particleType, double xCoord, double yCoord, double zCoord, double xSpeed, double ySpeed, double zSpeed, int... parameters)
-    {
+    public void spawnParticle(EnumParticleTypes particleType, double xCoord, double yCoord, double zCoord, double xSpeed, double ySpeed, double zSpeed, int... parameters) {
         this.spawnParticle(particleType.getParticleID(), particleType.getShouldIgnoreRange(), xCoord, yCoord, zCoord, xSpeed, ySpeed, zSpeed, parameters);
     }
 
-    public void spawnAlwaysVisibleParticle(int p_190523_1_, double p_190523_2_, double p_190523_4_, double p_190523_6_, double p_190523_8_, double p_190523_10_, double p_190523_12_, int... p_190523_14_)
-    {
-        for (int i = 0; i < this.eventListeners.size(); ++i)
-        {
-            ((IWorldEventListener)this.eventListeners.get(i)).spawnParticle(p_190523_1_, false, true, p_190523_2_, p_190523_4_, p_190523_6_, p_190523_8_, p_190523_10_, p_190523_12_, p_190523_14_);
+    public void spawnAlwaysVisibleParticle(int p_190523_1_, double p_190523_2_, double p_190523_4_, double p_190523_6_, double p_190523_8_, double p_190523_10_, double p_190523_12_, int... p_190523_14_) {
+        for (int i = 0; i < this.eventListeners.size(); ++i) {
+            ((IWorldEventListener) this.eventListeners.get(i)).spawnParticle(p_190523_1_, false, true, p_190523_2_, p_190523_4_, p_190523_6_, p_190523_8_, p_190523_10_, p_190523_12_, p_190523_14_);
         }
     }
 
     @SideOnly(Side.CLIENT)
-    public void spawnParticle(EnumParticleTypes particleType, boolean ignoreRange, double xCoord, double yCoord, double zCoord, double xSpeed, double ySpeed, double zSpeed, int... parameters)
-    {
+    public void spawnParticle(EnumParticleTypes particleType, boolean ignoreRange, double xCoord, double yCoord, double zCoord, double xSpeed, double ySpeed, double zSpeed, int... parameters) {
         this.spawnParticle(particleType.getParticleID(), particleType.getShouldIgnoreRange() || ignoreRange, xCoord, yCoord, zCoord, xSpeed, ySpeed, zSpeed, parameters);
     }
 
-    private void spawnParticle(int particleID, boolean ignoreRange, double xCood, double yCoord, double zCoord, double xSpeed, double ySpeed, double zSpeed, int... parameters)
-    {
-        for (int i = 0; i < this.eventListeners.size(); ++i)
-        {
-            ((IWorldEventListener)this.eventListeners.get(i)).spawnParticle(particleID, ignoreRange, xCood, yCoord, zCoord, xSpeed, ySpeed, zSpeed, parameters);
+    private void spawnParticle(int particleID, boolean ignoreRange, double xCood, double yCoord, double zCoord, double xSpeed, double ySpeed, double zSpeed, int... parameters) {
+        for (int i = 0; i < this.eventListeners.size(); ++i) {
+            ((IWorldEventListener) this.eventListeners.get(i)).spawnParticle(particleID, ignoreRange, xCood, yCoord, zCoord, xSpeed, ySpeed, zSpeed, parameters);
         }
     }
 
-    public boolean addWeatherEffect(Entity entityIn)
-    {
+    public boolean addWeatherEffect(Entity entityIn) {
         this.weatherEffects.add(entityIn);
         return true;
     }
 
-    public boolean spawnEntity(Entity entityIn)
-    {
+    public boolean spawnEntity(Entity entityIn) {
+        // CraftBukkit start - Used for entities other than creatures
+        return spawnEntity(entityIn, CreatureSpawnEvent.SpawnReason.DEFAULT);
+    }
+
+    public boolean spawnEntity(Entity entity, CreatureSpawnEvent.SpawnReason spawnReason) {
+        if (entity == null) return false;
+
+        org.bukkit.event.Cancellable event = null;
+        if (entity instanceof EntityLivingBase && !(entity instanceof EntityPlayerMP)) {
+            boolean isAnimal = entity instanceof EntityAnimal || entity instanceof EntityWaterMob || entity instanceof EntityGolem;
+            boolean isMonster = entity instanceof EntityMob || entity instanceof EntityGhast || entity instanceof EntitySlime;
+            boolean isNpc = entity instanceof NPC;
+
+            if (spawnReason != CreatureSpawnEvent.SpawnReason.CUSTOM) {
+                if (isAnimal && !spawnPeacefulMobs || isMonster && !spawnHostileMobs || isNpc && !getServer().getServer().getCanSpawnNPCs()) {
+                    entity.isDead = true;
+                    return false;
+                }
+            }
+
+            event = CraftEventFactory.callCreatureSpawnEvent((EntityLivingBase) entity, spawnReason);
+        } else if (entity instanceof EntityItem) {
+            event = CraftEventFactory.callItemSpawnEvent((EntityItem) entity);
+        } else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Projectile) {
+            // Not all projectiles extend EntityProjectile, so check for Bukkit interface instead
+            event = CraftEventFactory.callProjectileLaunchEvent(entity);
+        } else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Vehicle) {
+            event = CraftEventFactory.callVehicleCreateEvent(entity);
+        }
+
+        // Spigot start
+        else if (entity instanceof EntityXPOrb) {
+            EntityXPOrb xp = (EntityXPOrb) entity;
+            double radius = spigotConfig.expMerge;
+            if (radius > 0) {
+                List<Entity> entities = this.getEntitiesWithinAABBExcludingEntity(entity, entity.getEntityBoundingBox().grow(radius, radius, radius));
+                for (Entity e : entities) {
+                    if (e instanceof EntityXPOrb) {
+                        EntityXPOrb loopItem = (EntityXPOrb) e;
+                        if (!loopItem.isDead) {
+                            xp.xpValue += loopItem.xpValue;
+                            loopItem.setDead();
+                        }
+                    }
+                }
+            }
+        } // Spigot end
+
+        if (event != null && (event.isCancelled() || entity.isDead)) {
+            entity.isDead = true;
+            return false;
+        }
+        // CraftBukkit end
         // do not drop any items while restoring blocksnapshots. Prevents dupes
-        if (!this.isRemote && (entityIn == null || (entityIn instanceof net.minecraft.entity.item.EntityItem && this.restoringBlockSnapshots))) return false;
+        if (!this.isRemote && (entity == null || (entity instanceof net.minecraft.entity.item.EntityItem && this.restoringBlockSnapshots)))
+            return false;
 
-        int i = MathHelper.floor(entityIn.posX / 16.0D);
-        int j = MathHelper.floor(entityIn.posZ / 16.0D);
-        boolean flag = entityIn.forceSpawn;
+        int i = MathHelper.floor(entity.posX / 16.0D);
+        int j = MathHelper.floor(entity.posZ / 16.0D);
+        boolean flag = entity.forceSpawn;
 
-        if (entityIn instanceof EntityPlayer)
-        {
+        if (entity instanceof EntityPlayer) {
             flag = true;
         }
 
-        if (!flag && !this.isChunkLoaded(i, j, false))
-        {
+        if (!flag && !this.isChunkLoaded(i, j, false)) {
             return false;
-        }
-        else
-        {
-            if (entityIn instanceof EntityPlayer)
-            {
-                EntityPlayer entityplayer = (EntityPlayer)entityIn;
+        } else {
+            if (entity instanceof EntityPlayer) {
+                EntityPlayer entityplayer = (EntityPlayer) entity;
                 this.playerEntities.add(entityplayer);
                 this.updateAllPlayersSleepingFlag();
             }
 
-            if (net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entityIn, this)) && !flag) return false;
+            if (net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entity, this)) && !flag)
+                return false;
 
-            this.getChunkFromChunkCoords(i, j).addEntity(entityIn);
-            this.loadedEntityList.add(entityIn);
-            this.onEntityAdded(entityIn);
+            this.getChunkFromChunkCoords(i, j).addEntity(entity);
+            if (entity.isDead) return false; // Paper - don't add dead entities, chunk registration may of killed it
+            this.loadedEntityList.add(entity);
+            this.onEntityAdded(entity);
             return true;
         }
     }
 
-    public void onEntityAdded(Entity entityIn)
-    {
-        for (int i = 0; i < this.eventListeners.size(); ++i)
-        {
-            ((IWorldEventListener)this.eventListeners.get(i)).onEntityAdded(entityIn);
+    public void onEntityAdded(Entity entityIn) {
+        for (int i = 0; i < this.eventListeners.size(); ++i) {
+            ((IWorldEventListener) this.eventListeners.get(i)).onEntityAdded(entityIn);
         }
         entityIn.onAddedToWorld();
+        entityIn.valid = true; // CraftBukkit
+        new com.destroystokyo.paper.event.entity.EntityAddToWorldEvent(entityIn.getBukkitEntity()).callEvent(); // Paper - fire while valid
     }
 
-    public void onEntityRemoved(Entity entityIn)
-    {
-        for (int i = 0; i < this.eventListeners.size(); ++i)
-        {
-            ((IWorldEventListener)this.eventListeners.get(i)).onEntityRemoved(entityIn);
+    public void onEntityRemoved(Entity entityIn) {
+        for (int i = 0; i < this.eventListeners.size(); ++i) {
+            ((IWorldEventListener) this.eventListeners.get(i)).onEntityRemoved(entityIn);
         }
         entityIn.onRemovedFromWorld();
+        new com.destroystokyo.paper.event.entity.EntityRemoveFromWorldEvent(entityIn.getBukkitEntity()).callEvent(); // Paper - fire while valid
+        entityIn.valid = false; // CraftBukkit
     }
 
-    public void removeEntity(Entity entityIn)
-    {
-        if (entityIn.isBeingRidden())
-        {
+    public void removeEntity(Entity entityIn) {
+        if (entityIn.isBeingRidden()) {
             entityIn.removePassengers();
         }
 
-        if (entityIn.isRiding())
-        {
+        if (entityIn.isRiding()) {
             entityIn.dismountRidingEntity();
         }
 
         entityIn.setDead();
 
-        if (entityIn instanceof EntityPlayer)
-        {
+        if (entityIn instanceof EntityPlayer) {
             this.playerEntities.remove(entityIn);
             this.updateAllPlayersSleepingFlag();
             this.onEntityRemoved(entityIn);
         }
     }
 
-    public void removeEntityDangerously(Entity entityIn)
-    {
+    public void removeEntityDangerously(Entity entityIn) {
         entityIn.setDropItemsWhenDead(false);
         entityIn.setDead();
 
-        if (entityIn instanceof EntityPlayer)
-        {
+        if (entityIn instanceof EntityPlayer) {
             this.playerEntities.remove(entityIn);
             this.updateAllPlayersSleepingFlag();
         }
@@ -1266,22 +1265,28 @@
         int i = entityIn.chunkCoordX;
         int j = entityIn.chunkCoordZ;
 
-        if (entityIn.addedToChunk && this.isChunkLoaded(i, j, true))
-        {
+        if (entityIn.addedToChunk && this.isChunkLoaded(i, j, true)) {
             this.getChunkFromChunkCoords(i, j).removeEntity(entityIn);
         }
 
-        this.loadedEntityList.remove(entityIn);
+        // this.loadedEntityList.remove(entityIn);
+        // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
+        int index = this.loadedEntityList.indexOf(entityIn);
+        if (index != -1) {
+            if (index <= this.tickPosition) {
+                this.tickPosition--;
+            }
+            this.loadedEntityList.remove(index);
+        }
+        // CraftBukkit end
         this.onEntityRemoved(entityIn);
     }
 
-    public void addEventListener(IWorldEventListener listener)
-    {
+    public void addEventListener(IWorldEventListener listener) {
         this.eventListeners.add(listener);
     }
 
-    private boolean getCollisionBoxes(@Nullable Entity entityIn, AxisAlignedBB aabb, boolean p_191504_3_, @Nullable List<AxisAlignedBB> outList)
-    {
+    private boolean getCollisionBoxes(@Nullable Entity entityIn, AxisAlignedBB aabb, boolean p_191504_3_, @Nullable List<AxisAlignedBB> outList) {
         int i = MathHelper.floor(aabb.minX) - 1;
         int j = MathHelper.ceil(aabb.maxX) + 1;
         int k = MathHelper.floor(aabb.minY) - 1;
@@ -1294,51 +1299,38 @@
         IBlockState iblockstate = Blocks.STONE.getDefaultState();
         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
-        if (p_191504_3_ && !net.minecraftforge.event.ForgeEventFactory.gatherCollisionBoxes(this, entityIn, aabb, outList)) return true;
-        try
-        {
-            for (int k1 = i; k1 < j; ++k1)
-            {
-                for (int l1 = i1; l1 < j1; ++l1)
-                {
+        if (p_191504_3_ && !net.minecraftforge.event.ForgeEventFactory.gatherCollisionBoxes(this, entityIn, aabb, outList))
+            return true;
+        try {
+            for (int k1 = i; k1 < j; ++k1) {
+                for (int l1 = i1; l1 < j1; ++l1) {
                     boolean flag2 = k1 == i || k1 == j - 1;
                     boolean flag3 = l1 == i1 || l1 == j1 - 1;
 
-                    if ((!flag2 || !flag3) && this.isBlockLoaded(blockpos$pooledmutableblockpos.setPos(k1, 64, l1)))
-                    {
-                        for (int i2 = k; i2 < l; ++i2)
-                        {
-                            if (!flag2 && !flag3 || i2 != l - 1)
-                            {
-                                if (p_191504_3_)
-                                {
-                                    if (k1 < -30000000 || k1 >= 30000000 || l1 < -30000000 || l1 >= 30000000)
-                                    {
+                    if ((!flag2 || !flag3) && this.isBlockLoaded(blockpos$pooledmutableblockpos.setPos(k1, 64, l1))) {
+                        for (int i2 = k; i2 < l; ++i2) {
+                            if (!flag2 && !flag3 || i2 != l - 1) {
+                                if (p_191504_3_) {
+                                    if (k1 < -30000000 || k1 >= 30000000 || l1 < -30000000 || l1 >= 30000000) {
                                         boolean lvt_21_2_ = true;
                                         return lvt_21_2_;
                                     }
-                                }
-                                else if (entityIn != null && flag == flag1)
-                                {
+                                } else if (entityIn != null && flag == flag1) {
                                     entityIn.setOutsideBorder(!flag1);
                                 }
 
                                 blockpos$pooledmutableblockpos.setPos(k1, i2, l1);
                                 IBlockState iblockstate1;
 
-                                if (!p_191504_3_ && !worldborder.contains(blockpos$pooledmutableblockpos) && flag1)
-                                {
+                                if (!p_191504_3_ && !worldborder.contains(blockpos$pooledmutableblockpos) && flag1) {
                                     iblockstate1 = iblockstate;
-                                }
-                                else
-                                {
+                                } else {
                                     iblockstate1 = this.getBlockState(blockpos$pooledmutableblockpos);
                                 }
 
                                 iblockstate1.addCollisionBoxToList(this, blockpos$pooledmutableblockpos, aabb, outList, entityIn, false);
 
-                                if (p_191504_3_ && !net.minecraftforge.event.ForgeEventFactory.gatherCollisionBoxes(this, entityIn, aabb, outList))
-                                {
+                                if (p_191504_3_ && !net.minecraftforge.event.ForgeEventFactory.gatherCollisionBoxes(this, entityIn, aabb, outList)) {
                                     boolean flag5 = true;
                                     return flag5;
                                 }
@@ -1347,41 +1339,33 @@
                     }
                 }
             }
-        }
-        finally
-        {
+        } finally {
             blockpos$pooledmutableblockpos.release();
         }
 
         return !outList.isEmpty();
     }
 
-    public List<AxisAlignedBB> getCollisionBoxes(@Nullable Entity entityIn, AxisAlignedBB aabb)
-    {
+    public List<AxisAlignedBB> getCollisionBoxes(@Nullable Entity entityIn, AxisAlignedBB aabb) {
         List<AxisAlignedBB> list = Lists.<AxisAlignedBB>newArrayList();
         this.getCollisionBoxes(entityIn, aabb, false, list);
 
-        if (entityIn != null)
-        {
+        if (entityIn != null) {
             List<Entity> list1 = this.getEntitiesWithinAABBExcludingEntity(entityIn, aabb.grow(0.25D));
 
-            for (int i = 0; i < list1.size(); ++i)
-            {
+            for (int i = 0; i < list1.size(); ++i) {
                 Entity entity = list1.get(i);
 
-                if (!entityIn.isRidingSameEntity(entity))
-                {
+                if (!entityIn.isRidingSameEntity(entity)) {
                     AxisAlignedBB axisalignedbb = entity.getCollisionBoundingBox();
 
-                    if (axisalignedbb != null && axisalignedbb.intersects(aabb))
-                    {
+                    if (axisalignedbb != null && axisalignedbb.intersects(aabb)) {
                         list.add(axisalignedbb);
                     }
 
                     axisalignedbb = entityIn.getCollisionBox(entity);
 
-                    if (axisalignedbb != null && axisalignedbb.intersects(aabb))
-                    {
+                    if (axisalignedbb != null && axisalignedbb.intersects(aabb)) {
                         list.add(axisalignedbb);
                     }
                 }
@@ -1391,27 +1375,22 @@
         return list;
     }
 
-    public void removeEventListener(IWorldEventListener listener)
-    {
+    public void removeEventListener(IWorldEventListener listener) {
         this.eventListeners.remove(listener);
     }
 
-    public boolean isInsideWorldBorder(Entity p_191503_1_)
-    {
+    public boolean isInsideWorldBorder(Entity p_191503_1_) {
         double d0 = this.worldBorder.minX();
         double d1 = this.worldBorder.minZ();
         double d2 = this.worldBorder.maxX();
         double d3 = this.worldBorder.maxZ();
 
-        if (p_191503_1_.isOutsideBorder())
-        {
+        if (p_191503_1_.isOutsideBorder()) {
             ++d0;
             ++d1;
             --d2;
             --d3;
-        }
-        else
-        {
+        } else {
             --d0;
             --d1;
             ++d2;
@@ -1421,16 +1400,14 @@
         return p_191503_1_.posX > d0 && p_191503_1_.posX < d2 && p_191503_1_.posZ > d1 && p_191503_1_.posZ < d3;
     }
 
-    public boolean collidesWithAnyBlock(AxisAlignedBB bbox)
-    {
-        return this.getCollisionBoxes((Entity)null, bbox, true, Lists.newArrayList());
+    public boolean collidesWithAnyBlock(AxisAlignedBB bbox) {
+        return this.getCollisionBoxes((Entity) null, bbox, true, Lists.newArrayList());
     }
 
-    public int calculateSkylightSubtracted(float partialTicks)
-    {
+    public int calculateSkylightSubtracted(float partialTicks) {
         float f = provider.getSunBrightnessFactor(partialTicks);
         f = 1 - f;
-        return (int)(f * 11);
+        return (int) (f * 11);
     }
 
     /**
@@ -1439,63 +1416,57 @@
      * Highly recommended for sunlight detection like solar panel.
      *
      * @return The current brightness factor
-     * */
-    public float getSunBrightnessFactor(float partialTicks)
-    {
+     */
+    public float getSunBrightnessFactor(float partialTicks) {
         float f = this.getCelestialAngle(partialTicks);
-        float f1 = 1.0F - (MathHelper.cos(f * ((float)Math.PI * 2F)) * 2.0F + 0.5F);
+        float f1 = 1.0F - (MathHelper.cos(f * ((float) Math.PI * 2F)) * 2.0F + 0.5F);
         f1 = MathHelper.clamp(f1, 0.0F, 1.0F);
         f1 = 1.0F - f1;
-        f1 = (float)((double)f1 * (1.0D - (double)(this.getRainStrength(partialTicks) * 5.0F) / 16.0D));
-        f1 = (float)((double)f1 * (1.0D - (double)(this.getThunderStrength(partialTicks) * 5.0F) / 16.0D));
+        f1 = (float) ((double) f1 * (1.0D - (double) (this.getRainStrength(partialTicks) * 5.0F) / 16.0D));
+        f1 = (float) ((double) f1 * (1.0D - (double) (this.getThunderStrength(partialTicks) * 5.0F) / 16.0D));
         return f1;
     }
 
     @SideOnly(Side.CLIENT)
-    public float getSunBrightness(float partialTicks)
-    {
+    public float getSunBrightness(float partialTicks) {
         return this.provider.getSunBrightness(partialTicks);
     }
 
     @SideOnly(Side.CLIENT)
-    public float getSunBrightnessBody(float partialTicks)
-    {
+    public float getSunBrightnessBody(float partialTicks) {
         float f = this.getCelestialAngle(partialTicks);
-        float f1 = 1.0F - (MathHelper.cos(f * ((float)Math.PI * 2F)) * 2.0F + 0.2F);
+        float f1 = 1.0F - (MathHelper.cos(f * ((float) Math.PI * 2F)) * 2.0F + 0.2F);
         f1 = MathHelper.clamp(f1, 0.0F, 1.0F);
         f1 = 1.0F - f1;
-        f1 = (float)((double)f1 * (1.0D - (double)(this.getRainStrength(partialTicks) * 5.0F) / 16.0D));
-        f1 = (float)((double)f1 * (1.0D - (double)(this.getThunderStrength(partialTicks) * 5.0F) / 16.0D));
+        f1 = (float) ((double) f1 * (1.0D - (double) (this.getRainStrength(partialTicks) * 5.0F) / 16.0D));
+        f1 = (float) ((double) f1 * (1.0D - (double) (this.getThunderStrength(partialTicks) * 5.0F) / 16.0D));
         return f1 * 0.8F + 0.2F;
     }
 
     @SideOnly(Side.CLIENT)
-    public Vec3d getSkyColor(Entity entityIn, float partialTicks)
-    {
+    public Vec3d getSkyColor(Entity entityIn, float partialTicks) {
         return this.provider.getSkyColor(entityIn, partialTicks);
     }
 
     @SideOnly(Side.CLIENT)
-    public Vec3d getSkyColorBody(Entity entityIn, float partialTicks)
-    {
+    public Vec3d getSkyColorBody(Entity entityIn, float partialTicks) {
         float f = this.getCelestialAngle(partialTicks);
-        float f1 = MathHelper.cos(f * ((float)Math.PI * 2F)) * 2.0F + 0.5F;
+        float f1 = MathHelper.cos(f * ((float) Math.PI * 2F)) * 2.0F + 0.5F;
         f1 = MathHelper.clamp(f1, 0.0F, 1.0F);
         int i = MathHelper.floor(entityIn.posX);
         int j = MathHelper.floor(entityIn.posY);
         int k = MathHelper.floor(entityIn.posZ);
         BlockPos blockpos = new BlockPos(i, j, k);
         int l = net.minecraftforge.client.ForgeHooksClient.getSkyBlendColour(this, blockpos);
-        float f3 = (float)(l >> 16 & 255) / 255.0F;
-        float f4 = (float)(l >> 8 & 255) / 255.0F;
-        float f5 = (float)(l & 255) / 255.0F;
+        float f3 = (float) (l >> 16 & 255) / 255.0F;
+        float f4 = (float) (l >> 8 & 255) / 255.0F;
+        float f5 = (float) (l & 255) / 255.0F;
         f3 = f3 * f1;
         f4 = f4 * f1;
         f5 = f5 * f1;
         float f6 = this.getRainStrength(partialTicks);
 
-        if (f6 > 0.0F)
-        {
+        if (f6 > 0.0F) {
             float f7 = (f3 * 0.3F + f4 * 0.59F + f5 * 0.11F) * 0.6F;
             float f8 = 1.0F - f6 * 0.75F;
             f3 = f3 * f8 + f7 * (1.0F - f8);
@@ -1505,8 +1476,7 @@
 
         float f10 = this.getThunderStrength(partialTicks);
 
-        if (f10 > 0.0F)
-        {
+        if (f10 > 0.0F) {
             float f11 = (f3 * 0.3F + f4 * 0.59F + f5 * 0.11F) * 0.2F;
             float f9 = 1.0F - f10 * 0.75F;
             f3 = f3 * f9 + f11 * (1.0F - f9);
@@ -1514,12 +1484,10 @@
             f5 = f5 * f9 + f11 * (1.0F - f9);
         }
 
-        if (this.lastLightningBolt > 0)
-        {
-            float f12 = (float)this.lastLightningBolt - partialTicks;
+        if (this.lastLightningBolt > 0) {
+            float f12 = (float) this.lastLightningBolt - partialTicks;
 
-            if (f12 > 1.0F)
-            {
+            if (f12 > 1.0F) {
                 f12 = 1.0F;
             }
 
@@ -1529,55 +1497,47 @@
             f5 = f5 * (1.0F - f12) + 1.0F * f12;
         }
 
-        return new Vec3d((double)f3, (double)f4, (double)f5);
+        return new Vec3d((double) f3, (double) f4, (double) f5);
     }
 
-    public float getCelestialAngle(float partialTicks)
-    {
+    public float getCelestialAngle(float partialTicks) {
         return this.provider.calculateCelestialAngle(this.getWorldTime(), partialTicks);
     }
 
     @SideOnly(Side.CLIENT)
-    public int getMoonPhase()
-    {
+    public int getMoonPhase() {
         return this.provider.getMoonPhase(this.getWorldTime());
     }
 
-    public float getCurrentMoonPhaseFactor()
-    {
+    public float getCurrentMoonPhaseFactor() {
         return provider.getCurrentMoonPhaseFactor();
     }
 
-    public float getCurrentMoonPhaseFactorBody()
-    {
+    public float getCurrentMoonPhaseFactorBody() {
         return WorldProvider.MOON_PHASE_FACTORS[this.provider.getMoonPhase(this.getWorldTime())];
     }
 
-    public float getCelestialAngleRadians(float partialTicks)
-    {
+    public float getCelestialAngleRadians(float partialTicks) {
         float f = this.getCelestialAngle(partialTicks);
-        return f * ((float)Math.PI * 2F);
+        return f * ((float) Math.PI * 2F);
     }
 
     @SideOnly(Side.CLIENT)
-    public Vec3d getCloudColour(float partialTicks)
-    {
+    public Vec3d getCloudColour(float partialTicks) {
         return this.provider.getCloudColor(partialTicks);
     }
 
     @SideOnly(Side.CLIENT)
-    public Vec3d getCloudColorBody(float partialTicks)
-    {
+    public Vec3d getCloudColorBody(float partialTicks) {
         float f = this.getCelestialAngle(partialTicks);
-        float f1 = MathHelper.cos(f * ((float)Math.PI * 2F)) * 2.0F + 0.5F;
+        float f1 = MathHelper.cos(f * ((float) Math.PI * 2F)) * 2.0F + 0.5F;
         f1 = MathHelper.clamp(f1, 0.0F, 1.0F);
         float f2 = 1.0F;
         float f3 = 1.0F;
         float f4 = 1.0F;
         float f5 = this.getRainStrength(partialTicks);
 
-        if (f5 > 0.0F)
-        {
+        if (f5 > 0.0F) {
             float f6 = (f2 * 0.3F + f3 * 0.59F + f4 * 0.11F) * 0.6F;
             float f7 = 1.0F - f5 * 0.95F;
             f2 = f2 * f7 + f6 * (1.0F - f7);
@@ -1590,8 +1550,7 @@
         f4 = f4 * (f1 * 0.85F + 0.15F);
         float f9 = this.getThunderStrength(partialTicks);
 
-        if (f9 > 0.0F)
-        {
+        if (f9 > 0.0F) {
             float f10 = (f2 * 0.3F + f3 * 0.59F + f4 * 0.11F) * 0.2F;
             float f8 = 1.0F - f9 * 0.95F;
             f2 = f2 * f8 + f10 * (1.0F - f8);
@@ -1599,34 +1558,29 @@
             f4 = f4 * f8 + f10 * (1.0F - f8);
         }
 
-        return new Vec3d((double)f2, (double)f3, (double)f4);
+        return new Vec3d((double) f2, (double) f3, (double) f4);
     }
 
     @SideOnly(Side.CLIENT)
-    public Vec3d getFogColor(float partialTicks)
-    {
+    public Vec3d getFogColor(float partialTicks) {
         float f = this.getCelestialAngle(partialTicks);
         return this.provider.getFogColor(f, partialTicks);
     }
 
-    public BlockPos getPrecipitationHeight(BlockPos pos)
-    {
+    public BlockPos getPrecipitationHeight(BlockPos pos) {
         return this.getChunkFromBlockCoords(pos).getPrecipitationHeight(pos);
     }
 
-    public BlockPos getTopSolidOrLiquidBlock(BlockPos pos)
-    {
+    public BlockPos getTopSolidOrLiquidBlock(BlockPos pos) {
         Chunk chunk = this.getChunkFromBlockCoords(pos);
         BlockPos blockpos;
         BlockPos blockpos1;
 
-        for (blockpos = new BlockPos(pos.getX(), chunk.getTopFilledSegment() + 16, pos.getZ()); blockpos.getY() >= 0; blockpos = blockpos1)
-        {
+        for (blockpos = new BlockPos(pos.getX(), chunk.getTopFilledSegment() + 16, pos.getZ()); blockpos.getY() >= 0; blockpos = blockpos1) {
             blockpos1 = blockpos.down();
             IBlockState state = chunk.getBlockState(blockpos1);
 
-            if (state.getMaterial().blocksMovement() && !state.getBlock().isLeaves(state, this, blockpos1) && !state.getBlock().isFoliage(this, blockpos1))
-            {
+            if (state.getMaterial().blocksMovement() && !state.getBlock().isLeaves(state, this, blockpos1) && !state.getBlock().isFoliage(this, blockpos1)) {
                 break;
             }
         }
@@ -1635,98 +1589,87 @@
     }
 
     @SideOnly(Side.CLIENT)
-    public float getStarBrightness(float partialTicks)
-    {
+    public float getStarBrightness(float partialTicks) {
         return this.provider.getStarBrightness(partialTicks);
     }
 
     @SideOnly(Side.CLIENT)
-    public float getStarBrightnessBody(float partialTicks)
-    {
+    public float getStarBrightnessBody(float partialTicks) {
         float f = this.getCelestialAngle(partialTicks);
-        float f1 = 1.0F - (MathHelper.cos(f * ((float)Math.PI * 2F)) * 2.0F + 0.25F);
+        float f1 = 1.0F - (MathHelper.cos(f * ((float) Math.PI * 2F)) * 2.0F + 0.25F);
         f1 = MathHelper.clamp(f1, 0.0F, 1.0F);
         return f1 * f1 * 0.5F;
     }
 
-    public boolean isUpdateScheduled(BlockPos pos, Block blk)
-    {
+    public boolean isUpdateScheduled(BlockPos pos, Block blk) {
         return true;
     }
 
-    public void scheduleUpdate(BlockPos pos, Block blockIn, int delay)
-    {
+    public void scheduleUpdate(BlockPos pos, Block blockIn, int delay) {
     }
 
-    public void updateBlockTick(BlockPos pos, Block blockIn, int delay, int priority)
-    {
+    public void updateBlockTick(BlockPos pos, Block blockIn, int delay, int priority) {
     }
 
-    public void scheduleBlockUpdate(BlockPos pos, Block blockIn, int delay, int priority)
-    {
+    public void scheduleBlockUpdate(BlockPos pos, Block blockIn, int delay, int priority) {
     }
 
-    public void updateEntities()
-    {
+    public void updateEntities() {
         this.profiler.startSection("entities");
         this.profiler.startSection("global");
 
-        for (int i = 0; i < this.weatherEffects.size(); ++i)
-        {
+        for (int i = 0; i < this.weatherEffects.size(); ++i) {
             Entity entity = this.weatherEffects.get(i);
-
-            try
-            {
-                if(entity.updateBlocked) continue;
+            // CraftBukkit start - Fixed an NPE
+            if (entity == null) {
+                continue;
+            }
+            // CraftBukkit end
+            try {
+                if (entity.updateBlocked) continue;
                 ++entity.ticksExisted;
                 entity.onUpdate();
-            }
-            catch (Throwable throwable2)
-            {
+            } catch (Throwable throwable2) {
                 CrashReport crashreport = CrashReport.makeCrashReport(throwable2, "Ticking entity");
                 CrashReportCategory crashreportcategory = crashreport.makeCategory("Entity being ticked");
 
-                if (entity == null)
-                {
+                if (entity == null) {
                     crashreportcategory.addCrashSection("Entity", "~~NULL~~");
-                }
-                else
-                {
+                } else {
                     entity.addEntityCrashInfo(crashreportcategory);
                 }
 
-                if (net.minecraftforge.common.ForgeModContainer.removeErroringEntities)
-                {
+                if (net.minecraftforge.common.ForgeModContainer.removeErroringEntities) {
                     net.minecraftforge.fml.common.FMLLog.log.fatal("{}", crashreport.getCompleteReport());
                     removeEntity(entity);
-                }
-                else
-                throw new ReportedException(crashreport);
+                } else
+                    throw new ReportedException(crashreport);
             }
 
-            if (entity.isDead)
-            {
+            if (entity.isDead) {
                 this.weatherEffects.remove(i--);
             }
         }
 
         this.profiler.endStartSection("remove");
-        this.loadedEntityList.removeAll(this.unloadedEntityList);
+        //this.loadedEntityList.removeAll(this.unloadedEntityList);
+        // Paper start - Use alternate implementation with faster contains
+        java.util.Set<Entity> toRemove = java.util.Collections.newSetFromMap(new java.util.IdentityHashMap<>());
+        toRemove.addAll(this.unloadedEntityList);
+        this.loadedEntityList.removeAll(toRemove);
+        // Paper end
 
-        for (int k = 0; k < this.unloadedEntityList.size(); ++k)
-        {
+        for (int k = 0; k < this.unloadedEntityList.size(); ++k) {
             Entity entity1 = this.unloadedEntityList.get(k);
             int j = entity1.chunkCoordX;
             int k1 = entity1.chunkCoordZ;
 
-            if (entity1.addedToChunk && this.isChunkLoaded(j, k1, true))
-            {
+            if (entity1.addedToChunk && this.isChunkLoaded(j, k1, true)) {
                 this.getChunkFromChunkCoords(j, k1).removeEntity(entity1);
             }
         }
 
-        for (int l = 0; l < this.unloadedEntityList.size(); ++l)
-        {
+        for (int l = 0; l < this.unloadedEntityList.size(); ++l) {
             this.onEntityRemoved(this.unloadedEntityList.get(l));
         }
 
@@ -1734,15 +1677,19 @@
         this.tickPlayers();
         this.profiler.endStartSection("regular");
 
-        for (int i1 = 0; i1 < this.loadedEntityList.size(); ++i1)
-        {
-            Entity entity2 = this.loadedEntityList.get(i1);
+        org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+        int entitiesThisCycle = 0;
+        if (tickPosition < 0) tickPosition = 0;
+        for (entityLimiter.initTick();
+             entitiesThisCycle < loadedEntityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
+             tickPosition++, entitiesThisCycle++) {
+            tickPosition = (tickPosition < loadedEntityList.size()) ? tickPosition : 0;
+            Entity entity2 = (Entity) this.loadedEntityList.get(this.tickPosition);
+            // CraftBukkit end
             Entity entity3 = entity2.getRidingEntity();
 
-            if (entity3 != null)
-            {
-                if (!entity3.isDead && entity3.isPassenger(entity2))
-                {
+            if (entity3 != null) {
+                if (!entity3.isDead && entity3.isPassenger(entity2)) {
                     continue;
                 }
 
@@ -1751,43 +1698,35 @@
 
             this.profiler.startSection("tick");
 
-            if (!entity2.isDead && !(entity2 instanceof EntityPlayerMP))
-            {
-                try
-                {
+            if (!entity2.isDead && !(entity2 instanceof EntityPlayerMP)) {
+                try {
                     net.minecraftforge.server.timings.TimeTracker.ENTITY_UPDATE.trackStart(entity2);
                     this.updateEntity(entity2);
                     net.minecraftforge.server.timings.TimeTracker.ENTITY_UPDATE.trackEnd(entity2);
-                }
-                catch (Throwable throwable1)
-                {
+                } catch (Throwable throwable1) {
                     CrashReport crashreport1 = CrashReport.makeCrashReport(throwable1, "Ticking entity");
                     CrashReportCategory crashreportcategory1 = crashreport1.makeCategory("Entity being ticked");
                     entity2.addEntityCrashInfo(crashreportcategory1);
-                    if (net.minecraftforge.common.ForgeModContainer.removeErroringEntities)
-                    {
+                    if (net.minecraftforge.common.ForgeModContainer.removeErroringEntities) {
                         net.minecraftforge.fml.common.FMLLog.log.fatal("{}", crashreport1.getCompleteReport());
                         removeEntity(entity2);
-                    }
-                    else
-                    throw new ReportedException(crashreport1);
+                    } else
+                        throw new ReportedException(crashreport1);
                 }
             }
 
             this.profiler.endSection();
             this.profiler.startSection("remove");
 
-            if (entity2.isDead)
-            {
+            if (entity2.isDead) {
                 int l1 = entity2.chunkCoordX;
                 int i2 = entity2.chunkCoordZ;
 
-                if (entity2.addedToChunk && this.isChunkLoaded(l1, i2, true))
-                {
+                if (entity2.addedToChunk && this.isChunkLoaded(l1, i2, true)) {
                     this.getChunkFromChunkCoords(l1, i2).removeEntity(entity2);
                 }
 
-                this.loadedEntityList.remove(i1--);
+                this.loadedEntityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
                 this.onEntityRemoved(entity2);
             }
 
@@ -1798,71 +1737,70 @@
 
         this.processingLoadedTiles = true; //FML Move above remove to prevent CMEs
 
-        if (!this.tileEntitiesToBeRemoved.isEmpty())
-        {
-            for (Object tile : tileEntitiesToBeRemoved)
-            {
-               ((TileEntity)tile).onChunkUnload();
+        if (!this.tileEntitiesToBeRemoved.isEmpty()) {
+            for (Object tile : tileEntitiesToBeRemoved) {
+                ((TileEntity) tile).onChunkUnload();
             }
 
             // forge: faster "contains" makes this removal much more efficient
+            // Paper start - Use alternate implementation with faster contains
             java.util.Set<TileEntity> remove = java.util.Collections.newSetFromMap(new java.util.IdentityHashMap<>());
             remove.addAll(tileEntitiesToBeRemoved);
             this.tickableTileEntities.removeAll(remove);
+            // Paper end
             this.loadedTileEntityList.removeAll(remove);
             this.tileEntitiesToBeRemoved.clear();
         }
 
-        Iterator<TileEntity> iterator = this.tickableTileEntities.iterator();
-
-        while (iterator.hasNext())
-        {
-            TileEntity tileentity = iterator.next();
-
-            if (!tileentity.isInvalid() && tileentity.hasWorld())
-            {
+        int tilesThisCycle = 0;
+        for (tileLimiter.initTick();
+             tilesThisCycle < this.tickableTileEntities.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
+             tileTickPosition++, tilesThisCycle++) {
+            tileTickPosition = (tileTickPosition < tickableTileEntities.size()) ? tileTickPosition : 0;
+            TileEntity tileentity = (TileEntity) this.tickableTileEntities.get(tileTickPosition);
+            // Spigot start
+            if (tileentity == null) {
+                tilesThisCycle--;
+                this.tickableTileEntities.remove(tileTickPosition--);
+                continue;
+            }
+            // Spigot end
+            if (!tileentity.isInvalid() && tileentity.hasWorld()) {
                 BlockPos blockpos = tileentity.getPos();
 
                 if (this.isBlockLoaded(blockpos, false) && this.worldBorder.contains(blockpos)) //Forge: Fix TE's getting an extra tick on the client side....
                 {
-                    try
-                    {
+                    try {
                         this.profiler.func_194340_a(() ->
                         {
-                            return String.valueOf((Object)TileEntity.getKey(tileentity.getClass()));
+                            return String.valueOf((Object) TileEntity.getKey(tileentity.getClass()));
                         });
                         net.minecraftforge.server.timings.TimeTracker.TILE_ENTITY_UPDATE.trackStart(tileentity);
-                        ((ITickable)tileentity).update();
+                        ((ITickable) tileentity).update();
                         net.minecraftforge.server.timings.TimeTracker.TILE_ENTITY_UPDATE.trackEnd(tileentity);
                         this.profiler.endSection();
-                    }
-                    catch (Throwable throwable)
-                    {
+                    } catch (Throwable throwable) {
                         CrashReport crashreport2 = CrashReport.makeCrashReport(throwable, "Ticking block entity");
                         CrashReportCategory crashreportcategory2 = crashreport2.makeCategory("Block entity being ticked");
                         tileentity.addInfoToCrashReport(crashreportcategory2);
-                        if (net.minecraftforge.common.ForgeModContainer.removeErroringTileEntities)
-                        {
-                            net.minecraftforge.fml.common.FMLLog.log.fatal("{}", crashreport2.getCompleteReport());
+                        if (net.minecraftforge.common.ForgeModContainer.removeErroringTileEntities) {
                             tileentity.invalidate();
                             this.removeTileEntity(tileentity.getPos());
-                        }
-                        else
-                        throw new ReportedException(crashreport2);
+                        } else
+                            throw new ReportedException(crashreport2);
                     }
                 }
             }
 
-            if (tileentity.isInvalid())
-            {
-                iterator.remove();
+            if (tileentity.isInvalid()) {
+                tilesThisCycle--;
+                this.tickableTileEntities.remove(tileTickPosition--);
                 this.loadedTileEntityList.remove(tileentity);
 
-                if (this.isBlockLoaded(tileentity.getPos()))
-                {
+                if (this.isBlockLoaded(tileentity.getPos())) {
                     //Forge: Bugfix: If we set the tile entity it immediately sets it in the chunk, so we could be desyned
                     Chunk chunk = this.getChunkFromBlockCoords(tileentity.getPos());
-                    if (chunk.getTileEntity(tileentity.getPos(), net.minecraft.world.chunk.Chunk.EnumCreateEntityType.CHECK) == tileentity)
+                    if (chunk.getTileEntity(tileentity.getPos(), Chunk.EnumCreateEntityType.CHECK) == tileentity)
                         chunk.removeTileEntity(tileentity.getPos());
                 }
             }
@@ -1871,25 +1809,29 @@
         this.processingLoadedTiles = false;
         this.profiler.endStartSection("pendingBlockEntities");
 
-        if (!this.addedTileEntityList.isEmpty())
-        {
-            for (int j1 = 0; j1 < this.addedTileEntityList.size(); ++j1)
-            {
+        if (!this.addedTileEntityList.isEmpty()) {
+            for (int j1 = 0; j1 < this.addedTileEntityList.size(); ++j1) {
                 TileEntity tileentity1 = this.addedTileEntityList.get(j1);
 
-                if (!tileentity1.isInvalid())
-                {
+                if (!tileentity1.isInvalid()) {
+                    /* CraftBukkit start - Order matters, moved down
                     if (!this.loadedTileEntityList.contains(tileentity1))
                     {
                         this.addTileEntity(tileentity1);
                     }
+                    // CraftBukkit end */
 
-                    if (this.isBlockLoaded(tileentity1.getPos()))
-                    {
+                    if (this.isBlockLoaded(tileentity1.getPos())) {
                         Chunk chunk = this.getChunkFromBlockCoords(tileentity1.getPos());
                         IBlockState iblockstate = chunk.getBlockState(tileentity1.getPos());
                         chunk.addTileEntity(tileentity1.getPos(), tileentity1);
                         this.notifyBlockUpdate(tileentity1.getPos(), iblockstate, iblockstate, 3);
+                        // CraftBukkit start
+                        // From above, don't screw this up - SPIGOT-1746
+                        if (!this.loadedTileEntityList.contains(tileentity1)) {
+                            this.addTileEntity(tileentity1);
+                        }
+                        // CraftBukkit end
                     }
                 }
             }
@@ -1901,12 +1843,10 @@
         this.profiler.endSection();
     }
 
-    protected void tickPlayers()
-    {
+    protected void tickPlayers() {
     }
 
-    public boolean addTileEntity(TileEntity tile)
-    {
+    public boolean addTileEntity(TileEntity tile) {
         // Forge - set the world early as vanilla doesn't set it until next tick
         if (tile.getWorld() != this) tile.setWorld(this);
         // Forge: wait to add new TE if we're currently processing existing ones
@@ -1914,14 +1854,12 @@
 
         boolean flag = this.loadedTileEntityList.add(tile);
 
-        if (flag && tile instanceof ITickable)
-        {
+        if (flag && tile instanceof ITickable) {
             this.tickableTileEntities.add(tile);
         }
         tile.onLoad();
 
-        if (this.isRemote)
-        {
+        if (this.isRemote) {
             BlockPos blockpos1 = tile.getPos();
             IBlockState iblockstate1 = this.getBlockState(blockpos1);
             this.notifyBlockUpdate(blockpos1, iblockstate1, iblockstate1, 2);
@@ -1930,35 +1868,26 @@
         return flag;
     }
 
-    public void addTileEntities(Collection<TileEntity> tileEntityCollection)
-    {
-        if (this.processingLoadedTiles)
-        {
-            for (TileEntity te : tileEntityCollection)
-            {
+    public void addTileEntities(Collection<TileEntity> tileEntityCollection) {
+        if (this.processingLoadedTiles) {
+            for (TileEntity te : tileEntityCollection) {
                 if (te.getWorld() != this) // Forge - set the world early as vanilla doesn't set it until next tick
                     te.setWorld(this);
             }
             this.addedTileEntityList.addAll(tileEntityCollection);
-        }
-        else
-        {
-            for (TileEntity tileentity2 : tileEntityCollection)
-            {
+        } else {
+            for (TileEntity tileentity2 : tileEntityCollection) {
                 this.addTileEntity(tileentity2);
             }
         }
     }
 
-    public void updateEntity(Entity ent)
-    {
+    public void updateEntity(Entity ent) {
         this.updateEntityWithOptionalForce(ent, true);
     }
 
-    public void updateEntityWithOptionalForce(Entity entityIn, boolean forceUpdate)
-    {
-        if (!(entityIn instanceof EntityPlayer))
-        {
+    public void updateEntityWithOptionalForce(Entity entityIn, boolean forceUpdate) {
+        if (!(entityIn instanceof EntityPlayer)) {
             int j2 = MathHelper.floor(entityIn.posX);
             int k2 = MathHelper.floor(entityIn.posZ);
 
@@ -1967,57 +1896,56 @@
             boolean canUpdate = !forceUpdate || this.isAreaLoaded(j2 - range, 0, k2 - range, j2 + range, 0, k2 + range, true);
             if (!canUpdate) canUpdate = net.minecraftforge.event.ForgeEventFactory.canEntityUpdate(entityIn);
 
-            if (!canUpdate)
-            {
+            if (!canUpdate) {
                 return;
             }
         }
 
+        // Spigot start
+        if (forceUpdate && !org.spigotmc.ActivationRange.checkIfActive(entityIn)) {
+            entityIn.ticksExisted++;
+            entityIn.inactiveTick();
+            return;
+        }
+        // Spigot end
+
         entityIn.lastTickPosX = entityIn.posX;
         entityIn.lastTickPosY = entityIn.posY;
         entityIn.lastTickPosZ = entityIn.posZ;
         entityIn.prevRotationYaw = entityIn.rotationYaw;
         entityIn.prevRotationPitch = entityIn.rotationPitch;
 
-        if (forceUpdate && entityIn.addedToChunk)
-        {
+        if (forceUpdate && entityIn.addedToChunk) {
             ++entityIn.ticksExisted;
 
-            if (entityIn.isRiding())
-            {
+            if (entityIn.isRiding()) {
                 entityIn.updateRidden();
+            } else {
+                if (!entityIn.updateBlocked)
+                    entityIn.onUpdate();
+                entityIn.postTick();
             }
-            else
-            {
-                if(!entityIn.updateBlocked)
-                entityIn.onUpdate();
-            }
         }
 
         this.profiler.startSection("chunkCheck");
 
-        if (Double.isNaN(entityIn.posX) || Double.isInfinite(entityIn.posX))
-        {
+        if (Double.isNaN(entityIn.posX) || Double.isInfinite(entityIn.posX)) {
             entityIn.posX = entityIn.lastTickPosX;
         }
 
-        if (Double.isNaN(entityIn.posY) || Double.isInfinite(entityIn.posY))
-        {
+        if (Double.isNaN(entityIn.posY) || Double.isInfinite(entityIn.posY)) {
             entityIn.posY = entityIn.lastTickPosY;
         }
 
-        if (Double.isNaN(entityIn.posZ) || Double.isInfinite(entityIn.posZ))
-        {
+        if (Double.isNaN(entityIn.posZ) || Double.isInfinite(entityIn.posZ)) {
             entityIn.posZ = entityIn.lastTickPosZ;
         }
 
-        if (Double.isNaN((double)entityIn.rotationPitch) || Double.isInfinite((double)entityIn.rotationPitch))
-        {
+        if (Double.isNaN((double) entityIn.rotationPitch) || Double.isInfinite((double) entityIn.rotationPitch)) {
             entityIn.rotationPitch = entityIn.prevRotationPitch;
         }
 
-        if (Double.isNaN((double)entityIn.rotationYaw) || Double.isInfinite((double)entityIn.rotationYaw))
-        {
+        if (Double.isNaN((double) entityIn.rotationYaw) || Double.isInfinite((double) entityIn.rotationYaw)) {
             entityIn.rotationYaw = entityIn.prevRotationYaw;
         }
 
@@ -2025,52 +1953,39 @@
         int j3 = MathHelper.floor(entityIn.posY / 16.0D);
         int k3 = MathHelper.floor(entityIn.posZ / 16.0D);
 
-        if (!entityIn.addedToChunk || entityIn.chunkCoordX != i3 || entityIn.chunkCoordY != j3 || entityIn.chunkCoordZ != k3)
-        {
-            if (entityIn.addedToChunk && this.isChunkLoaded(entityIn.chunkCoordX, entityIn.chunkCoordZ, true))
-            {
+        if (!entityIn.addedToChunk || entityIn.chunkCoordX != i3 || entityIn.chunkCoordY != j3 || entityIn.chunkCoordZ != k3) {
+            if (entityIn.addedToChunk && this.isChunkLoaded(entityIn.chunkCoordX, entityIn.chunkCoordZ, true)) {
                 this.getChunkFromChunkCoords(entityIn.chunkCoordX, entityIn.chunkCoordZ).removeEntityAtIndex(entityIn, entityIn.chunkCoordY);
             }
 
-            if (!entityIn.setPositionNonDirty() && !this.isChunkLoaded(i3, k3, true))
-            {
+            if (!entityIn.setPositionNonDirty() && !this.isChunkLoaded(i3, k3, true)) {
                 entityIn.addedToChunk = false;
-            }
-            else
-            {
+            } else {
                 this.getChunkFromChunkCoords(i3, k3).addEntity(entityIn);
             }
         }
 
         this.profiler.endSection();
 
-        if (forceUpdate && entityIn.addedToChunk)
-        {
-            for (Entity entity4 : entityIn.getPassengers())
-            {
-                if (!entity4.isDead && entity4.getRidingEntity() == entityIn)
-                {
+        if (forceUpdate && entityIn.addedToChunk) {
+            for (Entity entity4 : entityIn.getPassengers()) {
+                if (!entity4.isDead && entity4.getRidingEntity() == entityIn) {
                     this.updateEntity(entity4);
-                }
-                else
-                {
+                } else {
                     entity4.dismountRidingEntity();
                 }
             }
         }
     }
 
-    public boolean checkNoEntityCollision(AxisAlignedBB bb)
-    {
-        return this.checkNoEntityCollision(bb, (Entity)null);
+    public boolean checkNoEntityCollision(AxisAlignedBB bb) {
+        return this.checkNoEntityCollision(bb, (Entity) null);
     }
 
-    public boolean checkNoEntityCollision(AxisAlignedBB bb, @Nullable Entity entityIn)
-    {
-        List<Entity> list = this.getEntitiesWithinAABBExcludingEntity((Entity)null, bb);
+    public boolean checkNoEntityCollision(AxisAlignedBB bb, @Nullable Entity entityIn) {
+        List<Entity> list = this.getEntitiesWithinAABBExcludingEntity((Entity) null, bb);
 
-        for (int j2 = 0; j2 < list.size(); ++j2)
-        {
+        for (int j2 = 0; j2 < list.size(); ++j2) {
             Entity entity4 = list.get(j2);
 
             if (!entity4.isDead && entity4.preventEntitySpawning && entity4 != entityIn && (entityIn == null || !entity4.isRidingSameEntity(entityIn))) // Forge: fix MC-103516
@@ -2082,8 +1997,7 @@
         return true;
     }
 
-    public boolean checkBlockCollision(AxisAlignedBB bb)
-    {
+    public boolean checkBlockCollision(AxisAlignedBB bb) {
         int j2 = MathHelper.floor(bb.minX);
         int k2 = MathHelper.ceil(bb.maxX);
         int l2 = MathHelper.floor(bb.minY);
@@ -2092,16 +2006,12 @@
         int k3 = MathHelper.ceil(bb.maxZ);
         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
-        for (int l3 = j2; l3 < k2; ++l3)
-        {
-            for (int i4 = l2; i4 < i3; ++i4)
-            {
-                for (int j4 = j3; j4 < k3; ++j4)
-                {
+        for (int l3 = j2; l3 < k2; ++l3) {
+            for (int i4 = l2; i4 < i3; ++i4) {
+                for (int j4 = j3; j4 < k3; ++j4) {
                     IBlockState iblockstate1 = this.getBlockState(blockpos$pooledmutableblockpos.setPos(l3, i4, j4));
 
-                    if (iblockstate1.getMaterial() != Material.AIR)
-                    {
+                    if (iblockstate1.getMaterial() != Material.AIR) {
                         blockpos$pooledmutableblockpos.release();
                         return true;
                     }
@@ -2113,8 +2023,7 @@
         return false;
     }
 
-    public boolean containsAnyLiquid(AxisAlignedBB bb)
-    {
+    public boolean containsAnyLiquid(AxisAlignedBB bb) {
         int j2 = MathHelper.floor(bb.minX);
         int k2 = MathHelper.ceil(bb.maxX);
         int l2 = MathHelper.floor(bb.minY);
@@ -2123,12 +2032,9 @@
         int k3 = MathHelper.ceil(bb.maxZ);
         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
-        for (int l3 = j2; l3 < k2; ++l3)
-        {
-            for (int i4 = l2; i4 < i3; ++i4)
-            {
-                for (int j4 = j3; j4 < k3; ++j4)
-                {
+        for (int l3 = j2; l3 < k2; ++l3) {
+            for (int i4 = l2; i4 < i3; ++i4) {
+                for (int j4 = j3; j4 < k3; ++j4) {
                     IBlockState iblockstate1 = this.getBlockState(blockpos$pooledmutableblockpos.setPos(l3, i4, j4));
 
                     Boolean result = iblockstate1.getBlock().isAABBInsideLiquid(this, blockpos$pooledmutableblockpos, bb);
@@ -2137,8 +2043,7 @@
                         blockpos$pooledmutableblockpos.release();
                         return true;
                     }
-                    if (iblockstate1.getMaterial().isLiquid())
-                    {
+                    if (iblockstate1.getMaterial().isLiquid()) {
                         blockpos$pooledmutableblockpos.release();
                         return true;
                     }
@@ -2150,8 +2055,7 @@
         return false;
     }
 
-    public boolean isFlammableWithin(AxisAlignedBB bb)
-    {
+    public boolean isFlammableWithin(AxisAlignedBB bb) {
         int j2 = MathHelper.floor(bb.minX);
         int k2 = MathHelper.ceil(bb.maxX);
         int l2 = MathHelper.floor(bb.minY);
@@ -2159,25 +2063,18 @@
         int j3 = MathHelper.floor(bb.minZ);
         int k3 = MathHelper.ceil(bb.maxZ);
 
-        if (this.isAreaLoaded(j2, l2, j3, k2, i3, k3, true))
-        {
+        if (this.isAreaLoaded(j2, l2, j3, k2, i3, k3, true)) {
             BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
-            for (int l3 = j2; l3 < k2; ++l3)
-            {
-                for (int i4 = l2; i4 < i3; ++i4)
-                {
-                    for (int j4 = j3; j4 < k3; ++j4)
-                    {
+            for (int l3 = j2; l3 < k2; ++l3) {
+                for (int i4 = l2; i4 < i3; ++i4) {
+                    for (int j4 = j3; j4 < k3; ++j4) {
                         Block block = this.getBlockState(blockpos$pooledmutableblockpos.setPos(l3, i4, j4)).getBlock();
 
-                        if (block == Blocks.FIRE || block == Blocks.FLOWING_LAVA || block == Blocks.LAVA)
-                        {
+                        if (block == Blocks.FIRE || block == Blocks.FLOWING_LAVA || block == Blocks.LAVA) {
                             blockpos$pooledmutableblockpos.release();
                             return true;
-                        }
-                        else if (block.isBurning(this, new BlockPos(l3, i4, j4)))
-                        {
+                        } else if (block.isBurning(this, new BlockPos(l3, i4, j4))) {
                             blockpos$pooledmutableblockpos.release();
                             return true;
                         }
@@ -2191,8 +2088,7 @@
         return false;
     }
 
-    public boolean handleMaterialAcceleration(AxisAlignedBB bb, Material materialIn, Entity entityIn)
-    {
+    public boolean handleMaterialAcceleration(AxisAlignedBB bb, Material materialIn, Entity entityIn) {
         int j2 = MathHelper.floor(bb.minX);
         int k2 = MathHelper.ceil(bb.maxX);
         int l2 = MathHelper.floor(bb.minY);
@@ -2200,42 +2096,32 @@
         int j3 = MathHelper.floor(bb.minZ);
         int k3 = MathHelper.ceil(bb.maxZ);
 
-        if (!this.isAreaLoaded(j2, l2, j3, k2, i3, k3, true))
-        {
+        if (!this.isAreaLoaded(j2, l2, j3, k2, i3, k3, true)) {
             return false;
-        }
-        else
-        {
+        } else {
             boolean flag = false;
             Vec3d vec3d = Vec3d.ZERO;
             BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
-            for (int l3 = j2; l3 < k2; ++l3)
-            {
-                for (int i4 = l2; i4 < i3; ++i4)
-                {
-                    for (int j4 = j3; j4 < k3; ++j4)
-                    {
+            for (int l3 = j2; l3 < k2; ++l3) {
+                for (int i4 = l2; i4 < i3; ++i4) {
+                    for (int j4 = j3; j4 < k3; ++j4) {
                         blockpos$pooledmutableblockpos.setPos(l3, i4, j4);
                         IBlockState iblockstate1 = this.getBlockState(blockpos$pooledmutableblockpos);
                         Block block = iblockstate1.getBlock();
 
-                        Boolean result = block.isEntityInsideMaterial(this, blockpos$pooledmutableblockpos, iblockstate1, entityIn, (double)i3, materialIn, false);
-                        if (result != null && result == true)
-                        {
+                        Boolean result = block.isEntityInsideMaterial(this, blockpos$pooledmutableblockpos, iblockstate1, entityIn, (double) i3, materialIn, false);
+                        if (result != null && result == true) {
                             // Forge: When requested call blocks modifyAcceleration method, and more importantly cause this method to return true, which results in an entity being "inWater"
                             flag = true;
                             vec3d = block.modifyAcceleration(this, blockpos$pooledmutableblockpos, entityIn, vec3d);
                             continue;
-                        }
-                        else if (result != null && result == false) continue;
+                        } else if (result != null && result == false) continue;
 
-                        if (iblockstate1.getMaterial() == materialIn)
-                        {
-                            double d0 = (double)((float)(i4 + 1) - BlockLiquid.getLiquidHeightPercent(((Integer)iblockstate1.getValue(BlockLiquid.LEVEL)).intValue()));
+                        if (iblockstate1.getMaterial() == materialIn) {
+                            double d0 = (double) ((float) (i4 + 1) - BlockLiquid.getLiquidHeightPercent(((Integer) iblockstate1.getValue(BlockLiquid.LEVEL)).intValue()));
 
-                            if ((double)i3 >= d0)
-                            {
+                            if ((double) i3 >= d0) {
                                 flag = true;
                                 vec3d = block.modifyAcceleration(this, blockpos$pooledmutableblockpos, entityIn, vec3d);
                             }
@@ -2246,8 +2132,7 @@
 
             blockpos$pooledmutableblockpos.release();
 
-            if (vec3d.lengthVector() > 0.0D && entityIn.isPushedByWater())
-            {
+            if (vec3d.lengthVector() > 0.0D && entityIn.isPushedByWater()) {
                 vec3d = vec3d.normalize();
                 double d1 = 0.014D;
                 entityIn.motionX += vec3d.x * 0.014D;
@@ -2259,8 +2144,7 @@
         }
     }
 
-    public boolean isMaterialInBB(AxisAlignedBB bb, Material materialIn)
-    {
+    public boolean isMaterialInBB(AxisAlignedBB bb, Material materialIn) {
         int j2 = MathHelper.floor(bb.minX);
         int k2 = MathHelper.ceil(bb.maxX);
         int l2 = MathHelper.floor(bb.minY);
@@ -2269,12 +2153,9 @@
         int k3 = MathHelper.ceil(bb.maxZ);
         BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
-        for (int l3 = j2; l3 < k2; ++l3)
-        {
-            for (int i4 = l2; i4 < i3; ++i4)
-            {
-                for (int j4 = j3; j4 < k3; ++j4)
-                {
+        for (int l3 = j2; l3 < k2; ++l3) {
+            for (int i4 = l2; i4 < i3; ++i4) {
+                for (int j4 = j3; j4 < k3; ++j4) {
                     IBlockState iblockstate1 = this.getBlockState(blockpos$pooledmutableblockpos.setPos(l3, i4, j4));
                     Boolean result = iblockstate1.getBlock().isAABBInsideMaterial(this, blockpos$pooledmutableblockpos, bb, materialIn);
                     if (result != null) {
@@ -2282,8 +2163,7 @@
                         blockpos$pooledmutableblockpos.release();
                         return true;
                     }
-                    if (iblockstate1.getMaterial() == materialIn)
-                    {
+                    if (iblockstate1.getMaterial() == materialIn) {
                         blockpos$pooledmutableblockpos.release();
                         return true;
                     }
@@ -2295,13 +2175,11 @@
         return false;
     }
 
-    public Explosion createExplosion(@Nullable Entity entityIn, double x, double y, double z, float strength, boolean isSmoking)
-    {
+    public Explosion createExplosion(@Nullable Entity entityIn, double x, double y, double z, float strength, boolean isSmoking) {
         return this.newExplosion(entityIn, x, y, z, strength, false, isSmoking);
     }
 
-    public Explosion newExplosion(@Nullable Entity entityIn, double x, double y, double z, float strength, boolean isFlaming, boolean isSmoking)
-    {
+    public Explosion newExplosion(@Nullable Entity entityIn, double x, double y, double z, float strength, boolean isFlaming, boolean isSmoking) {
         Explosion explosion = new Explosion(this, entityIn, x, y, z, strength, isFlaming, isSmoking);
         if (net.minecraftforge.event.ForgeEventFactory.onExplosionStart(this, explosion)) return explosion;
         explosion.doExplosionA();
@@ -2309,31 +2187,25 @@
         return explosion;
     }
 
-    public float getBlockDensity(Vec3d vec, AxisAlignedBB bb)
-    {
+    public float getBlockDensity(Vec3d vec, AxisAlignedBB bb) {
         double d0 = 1.0D / ((bb.maxX - bb.minX) * 2.0D + 1.0D);
         double d1 = 1.0D / ((bb.maxY - bb.minY) * 2.0D + 1.0D);
         double d2 = 1.0D / ((bb.maxZ - bb.minZ) * 2.0D + 1.0D);
         double d3 = (1.0D - Math.floor(1.0D / d0) * d0) / 2.0D;
         double d4 = (1.0D - Math.floor(1.0D / d2) * d2) / 2.0D;
 
-        if (d0 >= 0.0D && d1 >= 0.0D && d2 >= 0.0D)
-        {
+        if (d0 >= 0.0D && d1 >= 0.0D && d2 >= 0.0D) {
             int j2 = 0;
             int k2 = 0;
 
-            for (float f = 0.0F; f <= 1.0F; f = (float)((double)f + d0))
-            {
-                for (float f1 = 0.0F; f1 <= 1.0F; f1 = (float)((double)f1 + d1))
-                {
-                    for (float f2 = 0.0F; f2 <= 1.0F; f2 = (float)((double)f2 + d2))
-                    {
-                        double d5 = bb.minX + (bb.maxX - bb.minX) * (double)f;
-                        double d6 = bb.minY + (bb.maxY - bb.minY) * (double)f1;
-                        double d7 = bb.minZ + (bb.maxZ - bb.minZ) * (double)f2;
+            for (float f = 0.0F; f <= 1.0F; f = (float) ((double) f + d0)) {
+                for (float f1 = 0.0F; f1 <= 1.0F; f1 = (float) ((double) f1 + d1)) {
+                    for (float f2 = 0.0F; f2 <= 1.0F; f2 = (float) ((double) f2 + d2)) {
+                        double d5 = bb.minX + (bb.maxX - bb.minX) * (double) f;
+                        double d6 = bb.minY + (bb.maxY - bb.minY) * (double) f1;
+                        double d7 = bb.minZ + (bb.maxZ - bb.minZ) * (double) f2;
 
-                        if (this.rayTraceBlocks(new Vec3d(d5 + d3, d6, d7 + d4), vec) == null)
-                        {
+                        if (this.rayTraceBlocks(new Vec3d(d5 + d3, d6, d7 + d4), vec) == null) {
                             ++j2;
                         }
 
@@ -2342,65 +2214,50 @@
                 }
             }
 
-            return (float)j2 / (float)k2;
-        }
-        else
-        {
+            return (float) j2 / (float) k2;
+        } else {
             return 0.0F;
         }
     }
 
-    public boolean extinguishFire(@Nullable EntityPlayer player, BlockPos pos, EnumFacing side)
-    {
+    public boolean extinguishFire(@Nullable EntityPlayer player, BlockPos pos, EnumFacing side) {
         pos = pos.offset(side);
 
-        if (this.getBlockState(pos).getBlock() == Blocks.FIRE)
-        {
+        if (this.getBlockState(pos).getBlock() == Blocks.FIRE) {
             this.playEvent(player, 1009, pos, 0);
             this.setBlockToAir(pos);
             return true;
-        }
-        else
-        {
+        } else {
             return false;
         }
     }
 
     @SideOnly(Side.CLIENT)
-    public String getDebugLoadedEntities()
-    {
+    public String getDebugLoadedEntities() {
         return "All: " + this.loadedEntityList.size();
     }
 
     @SideOnly(Side.CLIENT)
-    public String getProviderName()
-    {
+    public String getProviderName() {
         return this.chunkProvider.makeString();
     }
 
     @Nullable
-    public TileEntity getTileEntity(BlockPos pos)
-    {
-        if (this.isOutsideBuildHeight(pos))
-        {
+    public TileEntity getTileEntity(BlockPos pos) {
+        if (this.isOutsideBuildHeight(pos)) {
             return null;
-        }
-        else
-        {
+        } else {
             TileEntity tileentity2 = null;
 
-            if (this.processingLoadedTiles)
-            {
+            if (this.processingLoadedTiles) {
                 tileentity2 = this.getPendingTileEntityAt(pos);
             }
 
-            if (tileentity2 == null)
-            {
+            if (tileentity2 == null) {
                 tileentity2 = this.getChunkFromBlockCoords(pos).getTileEntity(pos, Chunk.EnumCreateEntityType.IMMEDIATE);
             }
 
-            if (tileentity2 == null)
-            {
+            if (tileentity2 == null) {
                 tileentity2 = this.getPendingTileEntityAt(pos);
             }
 
@@ -2409,14 +2266,11 @@
     }
 
     @Nullable
-    private TileEntity getPendingTileEntityAt(BlockPos pos)
-    {
-        for (int j2 = 0; j2 < this.addedTileEntityList.size(); ++j2)
-        {
+    private TileEntity getPendingTileEntityAt(BlockPos pos) {
+        for (int j2 = 0; j2 < this.addedTileEntityList.size(); ++j2) {
             TileEntity tileentity2 = this.addedTileEntityList.get(j2);
 
-            if (!tileentity2.isInvalid() && tileentity2.getPos().equals(pos))
-            {
+            if (!tileentity2.isInvalid() && tileentity2.getPos().equals(pos)) {
                 return tileentity2;
             }
         }
@@ -2424,35 +2278,28 @@
         return null;
     }
 
-    public void setTileEntity(BlockPos pos, @Nullable TileEntity tileEntityIn)
-    {
+    public void setTileEntity(BlockPos pos, @Nullable TileEntity tileEntityIn) {
         pos = pos.toImmutable(); // Forge - prevent mutable BlockPos leaks
-        if (!this.isOutsideBuildHeight(pos))
-        {
-            if (tileEntityIn != null && !tileEntityIn.isInvalid())
-            {
-                if (this.processingLoadedTiles)
-                {
+        if (!this.isOutsideBuildHeight(pos)) {
+            if (tileEntityIn != null && !tileEntityIn.isInvalid()) {
+                if (this.processingLoadedTiles) {
                     tileEntityIn.setPos(pos);
                     if (tileEntityIn.getWorld() != this)
                         tileEntityIn.setWorld(this); // Forge - set the world early as vanilla doesn't set it until next tick
                     Iterator<TileEntity> iterator1 = this.addedTileEntityList.iterator();
 
-                    while (iterator1.hasNext())
-                    {
+                    while (iterator1.hasNext()) {
                         TileEntity tileentity2 = iterator1.next();
 
-                        if (tileentity2.getPos().equals(pos))
-                        {
+                        if (tileentity2.getPos().equals(pos)) {
                             tileentity2.invalidate();
                             iterator1.remove();
                         }
                     }
 
+                    tileEntityIn.setWorld(this); // Spigot - No null worlds
                     this.addedTileEntityList.add(tileEntityIn);
-                }
-                else
-                {
+                } else {
                     Chunk chunk = this.getChunkFromBlockCoords(pos);
                     if (chunk != null) chunk.addTileEntity(pos, tileEntityIn);
                     this.addTileEntity(tileEntityIn);
@@ -2461,21 +2308,16 @@
         }
     }
 
-    public void removeTileEntity(BlockPos pos)
-    {
+    public void removeTileEntity(BlockPos pos) {
         TileEntity tileentity2 = this.getTileEntity(pos);
 
-        if (tileentity2 != null && this.processingLoadedTiles)
-        {
+        if (tileentity2 != null && this.processingLoadedTiles) {
             tileentity2.invalidate();
             this.addedTileEntityList.remove(tileentity2);
             if (!(tileentity2 instanceof ITickable)) //Forge: If they are not tickable they wont be removed in the update loop.
                 this.loadedTileEntityList.remove(tileentity2);
-        }
-        else
-        {
-            if (tileentity2 != null)
-            {
+        } else {
+            if (tileentity2 != null) {
                 this.addedTileEntityList.remove(tileentity2);
                 this.loadedTileEntityList.remove(tileentity2);
                 this.tickableTileEntities.remove(tileentity2);
@@ -2486,98 +2328,75 @@
         this.updateComparatorOutputLevel(pos, getBlockState(pos).getBlock()); //Notify neighbors of changes
     }
 
-    public void markTileEntityForRemoval(TileEntity tileEntityIn)
-    {
+    public void markTileEntityForRemoval(TileEntity tileEntityIn) {
         this.tileEntitiesToBeRemoved.add(tileEntityIn);
     }
 
-    public boolean isBlockFullCube(BlockPos pos)
-    {
+    public boolean isBlockFullCube(BlockPos pos) {
         AxisAlignedBB axisalignedbb = this.getBlockState(pos).getCollisionBoundingBox(this, pos);
         return axisalignedbb != Block.NULL_AABB && axisalignedbb.getAverageEdgeLength() >= 1.0D;
     }
 
-    public boolean isBlockNormalCube(BlockPos pos, boolean _default)
-    {
-        if (this.isOutsideBuildHeight(pos))
-        {
+    public boolean isBlockNormalCube(BlockPos pos, boolean _default) {
+        if (this.isOutsideBuildHeight(pos)) {
             return false;
-        }
-        else
-        {
+        } else {
             Chunk chunk1 = this.chunkProvider.getLoadedChunk(pos.getX() >> 4, pos.getZ() >> 4);
 
-            if (chunk1 != null && !chunk1.isEmpty())
-            {
+            if (chunk1 != null && !chunk1.isEmpty()) {
                 IBlockState iblockstate1 = this.getBlockState(pos);
                 return iblockstate1.getBlock().isNormalCube(iblockstate1, this, pos);
-            }
-            else
-            {
+            } else {
                 return _default;
             }
         }
     }
 
-    public void calculateInitialSkylight()
-    {
+    public void calculateInitialSkylight() {
         int j2 = this.calculateSkylightSubtracted(1.0F);
 
-        if (j2 != this.skylightSubtracted)
-        {
+        if (j2 != this.skylightSubtracted) {
             this.skylightSubtracted = j2;
         }
     }
 
-    public void setAllowedSpawnTypes(boolean hostile, boolean peaceful)
-    {
+    public void setAllowedSpawnTypes(boolean hostile, boolean peaceful) {
         this.spawnHostileMobs = hostile;
         this.spawnPeacefulMobs = peaceful;
         this.provider.setAllowedSpawnTypes(hostile, peaceful);
     }
 
-    public void tick()
-    {
+    public void tick() {
         this.updateWeather();
     }
 
-    protected void calculateInitialWeather()
-    {
+    protected void calculateInitialWeather() {
         this.provider.calculateInitialWeather();
     }
 
-    public void calculateInitialWeatherBody()
-    {
-        if (this.worldInfo.isRaining())
-        {
+    public void calculateInitialWeatherBody() {
+        if (this.worldInfo.isRaining()) {
             this.rainingStrength = 1.0F;
 
-            if (this.worldInfo.isThundering())
-            {
+            if (this.worldInfo.isThundering()) {
                 this.thunderingStrength = 1.0F;
             }
         }
     }
 
-    protected void updateWeather()
-    {
+    protected void updateWeather() {
         this.provider.updateWeather();
     }
 
-    public void updateWeatherBody()
-    {
-        if (this.provider.hasSkyLight())
-        {
-            if (!this.isRemote)
-            {
+    public void updateWeatherBody() {
+        if (this.provider.hasSkyLight()) {
+            if (!this.isRemote) {
                 boolean flag = this.getGameRules().getBoolean("doWeatherCycle");
 
-                if (flag)
-                {
+                if (flag) {
                     int j2 = this.worldInfo.getCleanWeatherTime();
 
-                    if (j2 > 0)
-                    {
+                    if (j2 > 0) {
                         --j2;
                         this.worldInfo.setCleanWeatherTime(j2);
                         this.worldInfo.setThunderTime(this.worldInfo.isThundering() ? 1 : 2);
@@ -2586,48 +2405,34 @@
 
                     int k2 = this.worldInfo.getThunderTime();
 
-                    if (k2 <= 0)
-                    {
-                        if (this.worldInfo.isThundering())
-                        {
+                    if (k2 <= 0) {
+                        if (this.worldInfo.isThundering()) {
                             this.worldInfo.setThunderTime(this.rand.nextInt(12000) + 3600);
-                        }
-                        else
-                        {
+                        } else {
                             this.worldInfo.setThunderTime(this.rand.nextInt(168000) + 12000);
                         }
-                    }
-                    else
-                    {
+                    } else {
                         --k2;
                         this.worldInfo.setThunderTime(k2);
 
-                        if (k2 <= 0)
-                        {
+                        if (k2 <= 0) {
                             this.worldInfo.setThundering(!this.worldInfo.isThundering());
                         }
                     }
 
                     int l2 = this.worldInfo.getRainTime();
 
-                    if (l2 <= 0)
-                    {
-                        if (this.worldInfo.isRaining())
-                        {
+                    if (l2 <= 0) {
+                        if (this.worldInfo.isRaining()) {
                             this.worldInfo.setRainTime(this.rand.nextInt(12000) + 12000);
-                        }
-                        else
-                        {
+                        } else {
                             this.worldInfo.setRainTime(this.rand.nextInt(168000) + 12000);
                         }
-                    }
-                    else
-                    {
+                    } else {
                         --l2;
                         this.worldInfo.setRainTime(l2);
 
-                        if (l2 <= 0)
-                        {
+                        if (l2 <= 0) {
                             this.worldInfo.setRaining(!this.worldInfo.isRaining());
                         }
                     }
@@ -2635,91 +2440,78 @@
 
                 this.prevThunderingStrength = this.thunderingStrength;
 
-                if (this.worldInfo.isThundering())
-                {
-                    this.thunderingStrength = (float)((double)this.thunderingStrength + 0.01D);
+                if (this.worldInfo.isThundering()) {
+                    this.thunderingStrength = (float) ((double) this.thunderingStrength + 0.01D);
+                } else {
+                    this.thunderingStrength = (float) ((double) this.thunderingStrength - 0.01D);
                 }
-                else
-                {
-                    this.thunderingStrength = (float)((double)this.thunderingStrength - 0.01D);
-                }
 
                 this.thunderingStrength = MathHelper.clamp(this.thunderingStrength, 0.0F, 1.0F);
                 this.prevRainingStrength = this.rainingStrength;
 
-                if (this.worldInfo.isRaining())
-                {
-                    this.rainingStrength = (float)((double)this.rainingStrength + 0.01D);
+                if (this.worldInfo.isRaining()) {
+                    this.rainingStrength = (float) ((double) this.rainingStrength + 0.01D);
+                } else {
+                    this.rainingStrength = (float) ((double) this.rainingStrength - 0.01D);
                 }
-                else
-                {
-                    this.rainingStrength = (float)((double)this.rainingStrength - 0.01D);
-                }
 
                 this.rainingStrength = MathHelper.clamp(this.rainingStrength, 0.0F, 1.0F);
+                // CraftBukkit start
+                for (int idx = 0; idx < this.playerEntities.size(); ++idx) {
+                    if (((EntityPlayerMP) this.playerEntities.get(idx)).world == this) {
+                        ((EntityPlayerMP) this.playerEntities.get(idx)).tickWeather();
+                    }
+                }
+                // CraftBukkit end
             }
         }
     }
 
     @SideOnly(Side.CLIENT)
-    protected void playMoodSoundAndCheckLight(int p_147467_1_, int p_147467_2_, Chunk chunkIn)
-    {
+    protected void playMoodSoundAndCheckLight(int p_147467_1_, int p_147467_2_, Chunk chunkIn) {
         chunkIn.enqueueRelightChecks();
     }
 
-    protected void updateBlocks()
-    {
+    protected void updateBlocks() {
     }
 
-    public void immediateBlockTick(BlockPos pos, IBlockState state, Random random)
-    {
+    public void immediateBlockTick(BlockPos pos, IBlockState state, Random random) {
         this.scheduledUpdatesAreImmediate = true;
         state.getBlock().updateTick(this, pos, state, random);
         this.scheduledUpdatesAreImmediate = false;
     }
 
-    public boolean canBlockFreezeWater(BlockPos pos)
-    {
+    public boolean canBlockFreezeWater(BlockPos pos) {
         return this.canBlockFreeze(pos, false);
     }
 
-    public boolean canBlockFreezeNoWater(BlockPos pos)
-    {
+    public boolean canBlockFreezeNoWater(BlockPos pos) {
         return this.canBlockFreeze(pos, true);
     }
 
-    public boolean canBlockFreeze(BlockPos pos, boolean noWaterAdj)
-    {
+    public boolean canBlockFreeze(BlockPos pos, boolean noWaterAdj) {
         return this.provider.canBlockFreeze(pos, noWaterAdj);
     }
 
-    public boolean canBlockFreezeBody(BlockPos pos, boolean noWaterAdj)
-    {
+    public boolean canBlockFreezeBody(BlockPos pos, boolean noWaterAdj) {
         Biome biome = this.getBiome(pos);
         float f = biome.getTemperature(pos);
 
-        if (f >= 0.15F)
-        {
+        if (f >= 0.15F) {
             return false;
-        }
-        else
-        {
-            if (pos.getY() >= 0 && pos.getY() < 256 && this.getLightFor(EnumSkyBlock.BLOCK, pos) < 10)
-            {
+        } else {
+            if (pos.getY() >= 0 && pos.getY() < 256 && this.getLightFor(EnumSkyBlock.BLOCK, pos) < 10) {
                 IBlockState iblockstate1 = this.getBlockState(pos);
                 Block block = iblockstate1.getBlock();
 
-                if ((block == Blocks.WATER || block == Blocks.FLOWING_WATER) && ((Integer)iblockstate1.getValue(BlockLiquid.LEVEL)).intValue() == 0)
-                {
-                    if (!noWaterAdj)
-                    {
+                if ((block == Blocks.WATER || block == Blocks.FLOWING_WATER) && ((Integer) iblockstate1.getValue(BlockLiquid.LEVEL)).intValue() == 0) {
+                    if (!noWaterAdj) {
                         return true;
                     }
 
                     boolean flag = this.isWater(pos.west()) && this.isWater(pos.east()) && this.isWater(pos.north()) && this.isWater(pos.south());
 
-                    if (!flag)
-                    {
+                    if (!flag) {
                         return true;
                     }
                 }
@@ -2729,37 +2521,27 @@
         }
     }
 
-    private boolean isWater(BlockPos pos)
-    {
+    private boolean isWater(BlockPos pos) {
         return this.getBlockState(pos).getMaterial() == Material.WATER;
     }
 
-    public boolean canSnowAt(BlockPos pos, boolean checkLight)
-    {
+    public boolean canSnowAt(BlockPos pos, boolean checkLight) {
         return this.provider.canSnowAt(pos, checkLight);
     }
 
-    public boolean canSnowAtBody(BlockPos pos, boolean checkLight)
-    {
+    public boolean canSnowAtBody(BlockPos pos, boolean checkLight) {
         Biome biome = this.getBiome(pos);
         float f = biome.getTemperature(pos);
 
-        if (f >= 0.15F)
-        {
+        if (f >= 0.15F) {
             return false;
-        }
-        else if (!checkLight)
-        {
+        } else if (!checkLight) {
             return true;
-        }
-        else
-        {
-            if (pos.getY() >= 0 && pos.getY() < 256 && this.getLightFor(EnumSkyBlock.BLOCK, pos) < 10)
-            {
+        } else {
+            if (pos.getY() >= 0 && pos.getY() < 256 && this.getLightFor(EnumSkyBlock.BLOCK, pos) < 10) {
                 IBlockState iblockstate1 = this.getBlockState(pos);
 
-                if (iblockstate1.getBlock().isAir(iblockstate1, this, pos) && Blocks.SNOW_LAYER.canPlaceBlockAt(this, pos))
-                {
+                if (iblockstate1.getBlock().isAir(iblockstate1, this, pos) && Blocks.SNOW_LAYER.canPlaceBlockAt(this, pos)) {
                     return true;
                 }
             }
@@ -2768,12 +2550,10 @@
         }
     }
 
-    public boolean checkLight(BlockPos pos)
-    {
+    public boolean checkLight(BlockPos pos) {
         boolean flag = false;
 
-        if (this.provider.hasSkyLight())
-        {
+        if (this.provider.hasSkyLight()) {
             flag |= this.checkLightFor(EnumSkyBlock.SKY, pos);
         }
 
@@ -2781,14 +2561,10 @@
         return flag;
     }
 
-    private int getRawLight(BlockPos pos, EnumSkyBlock lightType)
-    {
-        if (lightType == EnumSkyBlock.SKY && this.canSeeSky(pos))
-        {
+    private int getRawLight(BlockPos pos, EnumSkyBlock lightType) {
+        if (lightType == EnumSkyBlock.SKY && this.canSeeSky(pos)) {
             return 15;
-        }
-        else
-        {
+        } else {
             IBlockState iblockstate1 = this.getBlockState(pos);
             int j2 = lightType == EnumSkyBlock.SKY ? 0 : iblockstate1.getBlock().getLightValue(iblockstate1, this, pos);
             int k2 = iblockstate1.getBlock().getLightOpacity(iblockstate1, this, pos);
@@ -2798,80 +2574,64 @@
                 k2 = 1;
             }
 
-            if (k2 < 1)
-            {
+            if (k2 < 1) {
                 k2 = 1;
             }
 
-            if (k2 >= 15)
-            {
+            if (k2 >= 15) {
                 return j2; // Forge: fix MC-119932
-            }
-            else if (j2 >= 14)
-            {
+            } else if (j2 >= 14) {
                 return j2;
-            }
-            else
-            {
+            } else {
                 BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
-                try
-                {
-                    for (EnumFacing enumfacing : EnumFacing.values())
-                    {
+                try {
+                    for (EnumFacing enumfacing : EnumFacing.values()) {
                         blockpos$pooledmutableblockpos.setPos(pos).move(enumfacing);
                         int l2 = this.getLightFor(lightType, blockpos$pooledmutableblockpos) - k2;
 
-                        if (l2 > j2)
-                        {
+                        if (l2 > j2) {
                             j2 = l2;
                         }
 
-                        if (j2 >= 14)
-                        {
+                        if (j2 >= 14) {
                             int i3 = j2;
                             return i3;
                         }
                     }
 
                     return j2;
-                }
-                finally
-                {
+                } finally {
                     blockpos$pooledmutableblockpos.release();
                 }
             }
         }
     }
 
-    public boolean checkLightFor(EnumSkyBlock lightType, BlockPos pos)
-    {
-        if (!this.isAreaLoaded(pos, 16, false))
-        {
+    public boolean checkLightFor(EnumSkyBlock lightType, int x, int y, int z) {
+        // CraftBukkit start - Use neighbor cache instead of looking up
+        BlockPos pos = new BlockPos(x, y, z);
+        Chunk chunk = this.getChunkIfLoaded(x >> 4, z >> 4);
+        if (chunk == null || !this.isAreaLoaded(pos, 16, false)) {
+            // CraftBukkit end
             return false;
-        }
-        else
-        {
+        } else {
             int updateRange = this.isAreaLoaded(pos, 18, false) ? 17 : 15;
             int j2 = 0;
             int k2 = 0;
             this.profiler.startSection("getBrightness");
             int l2 = this.getLightFor(lightType, pos);
             int i3 = this.getRawLight(pos, lightType);
-            int j3 = pos.getX();
-            int k3 = pos.getY();
-            int l3 = pos.getZ();
+            int j3 = x;
+            int k3 = y;
+            int l3 = z;
 
-            if (i3 > l2)
-            {
+            if (i3 > l2) {
                 this.lightUpdateBlockList[k2++] = 133152;
-            }
-            else if (i3 < l2)
-            {
+            } else if (i3 < l2) {
                 this.lightUpdateBlockList[k2++] = 133152 | l2 << 18;
 
-                while (j2 < k2)
-                {
+                while (j2 < k2) {
                     int i4 = this.lightUpdateBlockList[j2++];
                     int j4 = (i4 & 63) - 32 + j3;
                     int k4 = (i4 >> 6 & 63) - 32 + k3;
@@ -2880,22 +2640,18 @@
                     BlockPos blockpos1 = new BlockPos(j4, k4, l4);
                     int j5 = this.getLightFor(lightType, blockpos1);
 
-                    if (j5 == i5)
-                    {
+                    if (j5 == i5) {
                         this.setLightFor(lightType, blockpos1, 0);
 
-                        if (i5 > 0)
-                        {
+                        if (i5 > 0) {
                             int k5 = MathHelper.abs(j4 - j3);
                             int l5 = MathHelper.abs(k4 - k3);
                             int i6 = MathHelper.abs(l4 - l3);
 
-                            if (k5 + l5 + i6 < updateRange)
-                            {
+                            if (k5 + l5 + i6 < updateRange) {
                                 BlockPos.PooledMutableBlockPos blockpos$pooledmutableblockpos = BlockPos.PooledMutableBlockPos.retain();
 
-                                for (EnumFacing enumfacing : EnumFacing.values())
-                                {
+                                for (EnumFacing enumfacing : EnumFacing.values()) {
                                     int j6 = j4 + enumfacing.getFrontOffsetX();
                                     int k6 = k4 + enumfacing.getFrontOffsetY();
                                     int l6 = l4 + enumfacing.getFrontOffsetZ();
@@ -2904,8 +2660,7 @@
                                     int i7 = Math.max(1, bs.getBlock().getLightOpacity(bs, this, blockpos$pooledmutableblockpos));
                                     j5 = this.getLightFor(lightType, blockpos$pooledmutableblockpos);
 
-                                    if (j5 == i5 - i7 && k2 < this.lightUpdateBlockList.length)
-                                    {
+                                    if (j5 == i5 - i7 && k2 < this.lightUpdateBlockList.length) {
                                         this.lightUpdateBlockList[k2++] = j6 - j3 + 32 | k6 - k3 + 32 << 6 | l6 - l3 + 32 << 12 | i5 - i7 << 18;
                                     }
                                 }
@@ -2922,8 +2677,7 @@
             this.profiler.endSection();
             this.profiler.startSection("checkedPosition < toCheckCount");
 
-            while (j2 < k2)
-            {
+            while (j2 < k2) {
                 int j7 = this.lightUpdateBlockList[j2++];
                 int k7 = (j7 & 63) - 32 + j3;
                 int l7 = (j7 >> 6 & 63) - 32 + k3;
@@ -2932,46 +2686,37 @@
                 int j8 = this.getLightFor(lightType, blockpos2);
                 int k8 = this.getRawLight(blockpos2, lightType);
 
-                if (k8 != j8)
-                {
+                if (k8 != j8) {
                     this.setLightFor(lightType, blockpos2, k8);
 
-                    if (k8 > j8)
-                    {
+                    if (k8 > j8) {
                         int l8 = Math.abs(k7 - j3);
                         int i9 = Math.abs(l7 - k3);
                         int j9 = Math.abs(i8 - l3);
                         boolean flag = k2 < this.lightUpdateBlockList.length - 6;
 
-                        if (l8 + i9 + j9 < updateRange && flag)
-                        {
-                            if (this.getLightFor(lightType, blockpos2.west()) < k8)
-                            {
+                        if (l8 + i9 + j9 < updateRange && flag) {
+                            if (this.getLightFor(lightType, blockpos2.west()) < k8) {
                                 this.lightUpdateBlockList[k2++] = k7 - 1 - j3 + 32 + (l7 - k3 + 32 << 6) + (i8 - l3 + 32 << 12);
                             }
 
-                            if (this.getLightFor(lightType, blockpos2.east()) < k8)
-                            {
+                            if (this.getLightFor(lightType, blockpos2.east()) < k8) {
                                 this.lightUpdateBlockList[k2++] = k7 + 1 - j3 + 32 + (l7 - k3 + 32 << 6) + (i8 - l3 + 32 << 12);
                             }
 
-                            if (this.getLightFor(lightType, blockpos2.down()) < k8)
-                            {
+                            if (this.getLightFor(lightType, blockpos2.down()) < k8) {
                                 this.lightUpdateBlockList[k2++] = k7 - j3 + 32 + (l7 - 1 - k3 + 32 << 6) + (i8 - l3 + 32 << 12);
                             }
 
-                            if (this.getLightFor(lightType, blockpos2.up()) < k8)
-                            {
+                            if (this.getLightFor(lightType, blockpos2.up()) < k8) {
                                 this.lightUpdateBlockList[k2++] = k7 - j3 + 32 + (l7 + 1 - k3 + 32 << 6) + (i8 - l3 + 32 << 12);
                             }
 
-                            if (this.getLightFor(lightType, blockpos2.north()) < k8)
-                            {
+                            if (this.getLightFor(lightType, blockpos2.north()) < k8) {
                                 this.lightUpdateBlockList[k2++] = k7 - j3 + 32 + (l7 - k3 + 32 << 6) + (i8 - 1 - l3 + 32 << 12);
                             }
 
-                            if (this.getLightFor(lightType, blockpos2.south()) < k8)
-                            {
+                            if (this.getLightFor(lightType, blockpos2.south()) < k8) {
                                 this.lightUpdateBlockList[k2++] = k7 - j3 + 32 + (l7 - k3 + 32 << 6) + (i8 + 1 - l3 + 32 << 12);
                             }
                         }
@@ -2984,42 +2729,34 @@
         }
     }
 
-    public boolean tickUpdates(boolean runAllPending)
-    {
+    public boolean tickUpdates(boolean runAllPending) {
         return false;
     }
 
     @Nullable
-    public List<NextTickListEntry> getPendingBlockUpdates(Chunk chunkIn, boolean remove)
-    {
+    public List<NextTickListEntry> getPendingBlockUpdates(Chunk chunkIn, boolean remove) {
         return null;
     }
 
     @Nullable
-    public List<NextTickListEntry> getPendingBlockUpdates(StructureBoundingBox structureBB, boolean remove)
-    {
+    public List<NextTickListEntry> getPendingBlockUpdates(StructureBoundingBox structureBB, boolean remove) {
         return null;
     }
 
-    public List<Entity> getEntitiesWithinAABBExcludingEntity(@Nullable Entity entityIn, AxisAlignedBB bb)
-    {
+    public List<Entity> getEntitiesWithinAABBExcludingEntity(@Nullable Entity entityIn, AxisAlignedBB bb) {
         return this.getEntitiesInAABBexcluding(entityIn, bb, EntitySelectors.NOT_SPECTATING);
     }
 
-    public List<Entity> getEntitiesInAABBexcluding(@Nullable Entity entityIn, AxisAlignedBB boundingBox, @Nullable Predicate <? super Entity > predicate)
-    {
+    public List<Entity> getEntitiesInAABBexcluding(@Nullable Entity entityIn, AxisAlignedBB boundingBox, @Nullable Predicate<? super Entity> predicate) {
         List<Entity> list = Lists.<Entity>newArrayList();
         int j2 = MathHelper.floor((boundingBox.minX - MAX_ENTITY_RADIUS) / 16.0D);
         int k2 = MathHelper.floor((boundingBox.maxX + MAX_ENTITY_RADIUS) / 16.0D);
         int l2 = MathHelper.floor((boundingBox.minZ - MAX_ENTITY_RADIUS) / 16.0D);
         int i3 = MathHelper.floor((boundingBox.maxZ + MAX_ENTITY_RADIUS) / 16.0D);
 
-        for (int j3 = j2; j3 <= k2; ++j3)
-        {
-            for (int k3 = l2; k3 <= i3; ++k3)
-            {
-                if (this.isChunkLoaded(j3, k3, true))
-                {
+        for (int j3 = j2; j3 <= k2; ++j3) {
+            for (int k3 = l2; k3 <= i3; ++k3) {
+                if (this.isChunkLoaded(j3, k3, true)) {
                     this.getChunkFromChunkCoords(j3, k3).getEntitiesWithinAABBForEntity(entityIn, boundingBox, list, predicate);
                 }
             }
@@ -3028,55 +2765,44 @@
         return list;
     }
 
-    public <T extends Entity> List<T> getEntities(Class <? extends T > entityType, Predicate <? super T > filter)
-    {
+    public <T extends Entity> List<T> getEntities(Class<? extends T> entityType, Predicate<? super T> filter) {
         List<T> list = Lists.<T>newArrayList();
 
-        for (Entity entity4 : this.loadedEntityList)
-        {
-            if (entityType.isAssignableFrom(entity4.getClass()) && filter.apply((T)entity4))
-            {
-                list.add((T)entity4);
+        for (Entity entity4 : this.loadedEntityList) {
+            if (entityType.isAssignableFrom(entity4.getClass()) && filter.apply((T) entity4)) {
+                list.add((T) entity4);
             }
         }
 
         return list;
     }
 
-    public <T extends Entity> List<T> getPlayers(Class <? extends T > playerType, Predicate <? super T > filter)
-    {
+    public <T extends Entity> List<T> getPlayers(Class<? extends T> playerType, Predicate<? super T> filter) {
         List<T> list = Lists.<T>newArrayList();
 
-        for (Entity entity4 : this.playerEntities)
-        {
-            if (playerType.isAssignableFrom(entity4.getClass()) && filter.apply((T)entity4))
-            {
-                list.add((T)entity4);
+        for (Entity entity4 : this.playerEntities) {
+            if (playerType.isAssignableFrom(entity4.getClass()) && filter.apply((T) entity4)) {
+                list.add((T) entity4);
             }
         }
 
         return list;
     }
 
-    public <T extends Entity> List<T> getEntitiesWithinAABB(Class <? extends T > classEntity, AxisAlignedBB bb)
-    {
+    public <T extends Entity> List<T> getEntitiesWithinAABB(Class<? extends T> classEntity, AxisAlignedBB bb) {
         return this.<T>getEntitiesWithinAABB(classEntity, bb, EntitySelectors.NOT_SPECTATING);
     }
 
-    public <T extends Entity> List<T> getEntitiesWithinAABB(Class <? extends T > clazz, AxisAlignedBB aabb, @Nullable Predicate <? super T > filter)
-    {
+    public <T extends Entity> List<T> getEntitiesWithinAABB(Class<? extends T> clazz, AxisAlignedBB aabb, @Nullable Predicate<? super T> filter) {
         int j2 = MathHelper.floor((aabb.minX - MAX_ENTITY_RADIUS) / 16.0D);
         int k2 = MathHelper.ceil((aabb.maxX + MAX_ENTITY_RADIUS) / 16.0D);
         int l2 = MathHelper.floor((aabb.minZ - MAX_ENTITY_RADIUS) / 16.0D);
         int i3 = MathHelper.ceil((aabb.maxZ + MAX_ENTITY_RADIUS) / 16.0D);
         List<T> list = Lists.<T>newArrayList();
 
-        for (int j3 = j2; j3 < k2; ++j3)
-        {
-            for (int k3 = l2; k3 < i3; ++k3)
-            {
-                if (this.isChunkLoaded(j3, k3, true))
-                {
+        for (int j3 = j2; j3 < k2; ++j3) {
+            for (int k3 = l2; k3 < i3; ++k3) {
+                if (this.isChunkLoaded(j3, k3, true)) {
                     this.getChunkFromChunkCoords(j3, k3).getEntitiesOfTypeWithinAABB(clazz, aabb, list, filter);
                 }
             }
@@ -3086,22 +2812,18 @@
     }
 
     @Nullable
-    public <T extends Entity> T findNearestEntityWithinAABB(Class <? extends T > entityType, AxisAlignedBB aabb, T closestTo)
-    {
+    public <T extends Entity> T findNearestEntityWithinAABB(Class<? extends T> entityType, AxisAlignedBB aabb, T closestTo) {
         List<T> list = this.<T>getEntitiesWithinAABB(entityType, aabb);
         T t = null;
         double d0 = Double.MAX_VALUE;
 
-        for (int j2 = 0; j2 < list.size(); ++j2)
-        {
+        for (int j2 = 0; j2 < list.size(); ++j2) {
             T t1 = list.get(j2);
 
-            if (t1 != closestTo && EntitySelectors.NOT_SPECTATING.apply(t1))
-            {
+            if (t1 != closestTo && EntitySelectors.NOT_SPECTATING.apply(t1)) {
                 double d1 = closestTo.getDistanceSq(t1);
 
-                if (d1 <= d0)
-                {
+                if (d1 <= d0) {
                     t = t1;
                     d0 = d1;
                 }
@@ -3112,33 +2834,35 @@
     }
 
     @Nullable
-    public Entity getEntityByID(int id)
-    {
+    public Entity getEntityByID(int id) {
         return this.entitiesById.lookup(id);
     }
 
     @SideOnly(Side.CLIENT)
-    public List<Entity> getLoadedEntityList()
-    {
+    public List<Entity> getLoadedEntityList() {
         return this.loadedEntityList;
     }
 
-    public void markChunkDirty(BlockPos pos, TileEntity unusedTileEntity)
-    {
-        if (this.isBlockLoaded(pos))
-        {
+    public void markChunkDirty(BlockPos pos, TileEntity unusedTileEntity) {
+        if (this.isBlockLoaded(pos)) {
             this.getChunkFromBlockCoords(pos).markDirty();
         }
     }
 
-    public int countEntities(Class<?> entityType)
-    {
+    public int countEntities(Class<?> entityType) {
         int j2 = 0;
 
-        for (Entity entity4 : this.loadedEntityList)
-        {
-            if ((!(entity4 instanceof EntityLiving) || !((EntityLiving)entity4).isNoDespawnRequired()) && entityType.isAssignableFrom(entity4.getClass()))
-            {
+        for (Entity entity4 : this.loadedEntityList) {
+            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
+            if (entity4 instanceof EntityLiving) {
+                EntityLiving entityinsentient = (EntityLiving) entity4;
+                if (entityinsentient.canDespawn() && entityinsentient.isNoDespawnRequired()) {
+                    continue;
+                }
+            }
+
+            // if ((!(entity4 instanceof EntityLiving) || !((EntityLiving)entity4).isNoDespawnRequired()) && entityType.isAssignableFrom(entity4.getClass()))
+            if (entityType.isAssignableFrom(entity4.getClass())) {
                 ++j2;
             }
         }
@@ -3146,106 +2870,88 @@
         return j2;
     }
 
-    public void loadEntities(Collection<Entity> entityCollection)
-    {
-        for (Entity entity4 : entityCollection)
-        {
-            if (!net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entity4, this)))
-            {
+    public void loadEntities(Collection<Entity> entityCollection) {
+        for (Entity entity4 : entityCollection) {
+            if (!net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entity4, this))) {
+                if (entity4 == null || entity4.isDead || entity4.valid) { // Paper - prevent adding already added or dead entities
+                    continue;
+                }
                 loadedEntityList.add(entity4);
                 this.onEntityAdded(entity4);
             }
         }
     }
 
-    public void unloadEntities(Collection<Entity> entityCollection)
-    {
+    public void unloadEntities(Collection<Entity> entityCollection) {
         this.unloadedEntityList.addAll(entityCollection);
     }
 
-    public boolean mayPlace(Block blockIn, BlockPos pos, boolean skipCollisionCheck, EnumFacing sidePlacedOn, @Nullable Entity placer)
-    {
+    public boolean mayPlace(Block blockIn, BlockPos pos, boolean skipCollisionCheck, EnumFacing sidePlacedOn, @Nullable Entity placer) {
         IBlockState iblockstate1 = this.getBlockState(pos);
         AxisAlignedBB axisalignedbb = skipCollisionCheck ? null : blockIn.getDefaultState().getCollisionBoundingBox(this, pos);
 
-        if (!((placer instanceof EntityPlayer) || !net.minecraftforge.event.ForgeEventFactory.onBlockPlace(placer, new net.minecraftforge.common.util.BlockSnapshot(this, pos, blockIn.getDefaultState()), sidePlacedOn).isCanceled())) return false;
+        boolean defaultReturn;
+        if (!((placer instanceof EntityPlayer) || !net.minecraftforge.event.ForgeEventFactory.onBlockPlace(placer, new net.minecraftforge.common.util.BlockSnapshot(this, pos, blockIn.getDefaultState()), sidePlacedOn).isCanceled()))
+            return false;
         if (axisalignedbb != Block.NULL_AABB && !this.checkNoEntityCollision(axisalignedbb.offset(pos))) // Forge: Remove second parameter, we patch placer to be non-null, passing it here skips collision checks for the placer
         {
-            return false;
+            defaultReturn = false;
+        } else if (iblockstate1.getMaterial() == Material.CIRCUITS && blockIn == Blocks.ANVIL) {
+            defaultReturn = true;
+        } else {
+            defaultReturn = iblockstate1.getBlock().isReplaceable(this, pos) && blockIn.canPlaceBlockOnSide(this, pos, sidePlacedOn);
         }
-        else if (iblockstate1.getMaterial() == Material.CIRCUITS && blockIn == Blocks.ANVIL)
-        {
-            return true;
-        }
-        else
-        {
-            return iblockstate1.getBlock().isReplaceable(this, pos) && blockIn.canPlaceBlockOnSide(this, pos, sidePlacedOn);
-        }
+
+        // CraftBukkit start - store default return
+        BlockCanBuildEvent event = new BlockCanBuildEvent(this.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ()), CraftMagicNumbers.getId(blockIn), defaultReturn);
+        this.getServer().getPluginManager().callEvent(event);
+        return event.isBuildable();
+        // CraftBukkit end
     }
 
-    public int getSeaLevel()
-    {
+    public int getSeaLevel() {
         return this.seaLevel;
     }
 
-    public void setSeaLevel(int seaLevelIn)
-    {
+    public void setSeaLevel(int seaLevelIn) {
         this.seaLevel = seaLevelIn;
     }
 
-    public int getStrongPower(BlockPos pos, EnumFacing direction)
-    {
+    public int getStrongPower(BlockPos pos, EnumFacing direction) {
         return this.getBlockState(pos).getStrongPower(this, pos, direction);
     }
 
-    public WorldType getWorldType()
-    {
+    public WorldType getWorldType() {
         return this.worldInfo.getTerrainType();
     }
 
-    public int getStrongPower(BlockPos pos)
-    {
+    public int getStrongPower(BlockPos pos) {
         int j2 = 0;
         j2 = Math.max(j2, this.getStrongPower(pos.down(), EnumFacing.DOWN));
 
-        if (j2 >= 15)
-        {
+        if (j2 >= 15) {
             return j2;
-        }
-        else
-        {
+        } else {
             j2 = Math.max(j2, this.getStrongPower(pos.up(), EnumFacing.UP));
 
-            if (j2 >= 15)
-            {
+            if (j2 >= 15) {
                 return j2;
-            }
-            else
-            {
+            } else {
                 j2 = Math.max(j2, this.getStrongPower(pos.north(), EnumFacing.NORTH));
 
-                if (j2 >= 15)
-                {
+                if (j2 >= 15) {
                     return j2;
-                }
-                else
-                {
+                } else {
                     j2 = Math.max(j2, this.getStrongPower(pos.south(), EnumFacing.SOUTH));
 
-                    if (j2 >= 15)
-                    {
+                    if (j2 >= 15) {
                         return j2;
-                    }
-                    else
-                    {
+                    } else {
                         j2 = Math.max(j2, this.getStrongPower(pos.west(), EnumFacing.WEST));
 
-                        if (j2 >= 15)
-                        {
+                        if (j2 >= 15) {
                             return j2;
-                        }
-                        else
-                        {
+                        } else {
                             j2 = Math.max(j2, this.getStrongPower(pos.east(), EnumFacing.EAST));
                             return j2 >= 15 ? j2 : j2;
                         }
@@ -3255,60 +2961,42 @@
         }
     }
 
-    public boolean isSidePowered(BlockPos pos, EnumFacing side)
-    {
+    public boolean isSidePowered(BlockPos pos, EnumFacing side) {
         return this.getRedstonePower(pos, side) > 0;
     }
 
-    public int getRedstonePower(BlockPos pos, EnumFacing facing)
-    {
+    public int getRedstonePower(BlockPos pos, EnumFacing facing) {
         IBlockState iblockstate1 = this.getBlockState(pos);
         return iblockstate1.getBlock().shouldCheckWeakPower(iblockstate1, this, pos, facing) ? this.getStrongPower(pos) : iblockstate1.getWeakPower(this, pos, facing);
     }
 
-    public boolean isBlockPowered(BlockPos pos)
-    {
-        if (this.getRedstonePower(pos.down(), EnumFacing.DOWN) > 0)
-        {
+    public boolean isBlockPowered(BlockPos pos) {
+        if (this.getRedstonePower(pos.down(), EnumFacing.DOWN) > 0) {
             return true;
-        }
-        else if (this.getRedstonePower(pos.up(), EnumFacing.UP) > 0)
-        {
+        } else if (this.getRedstonePower(pos.up(), EnumFacing.UP) > 0) {
             return true;
-        }
-        else if (this.getRedstonePower(pos.north(), EnumFacing.NORTH) > 0)
-        {
+        } else if (this.getRedstonePower(pos.north(), EnumFacing.NORTH) > 0) {
             return true;
-        }
-        else if (this.getRedstonePower(pos.south(), EnumFacing.SOUTH) > 0)
-        {
+        } else if (this.getRedstonePower(pos.south(), EnumFacing.SOUTH) > 0) {
             return true;
-        }
-        else if (this.getRedstonePower(pos.west(), EnumFacing.WEST) > 0)
-        {
+        } else if (this.getRedstonePower(pos.west(), EnumFacing.WEST) > 0) {
             return true;
-        }
-        else
-        {
+        } else {
             return this.getRedstonePower(pos.east(), EnumFacing.EAST) > 0;
         }
     }
 
-    public int isBlockIndirectlyGettingPowered(BlockPos pos)
-    {
+    public int isBlockIndirectlyGettingPowered(BlockPos pos) {
         int j2 = 0;
 
-        for (EnumFacing enumfacing : EnumFacing.values())
-        {
+        for (EnumFacing enumfacing : EnumFacing.values()) {
             int k2 = this.getRedstonePower(pos.offset(enumfacing), enumfacing);
 
-            if (k2 >= 15)
-            {
+            if (k2 >= 15) {
                 return 15;
             }
 
-            if (k2 > j2)
-            {
+            if (k2 > j2) {
                 j2 = k2;
             }
         }
@@ -3317,40 +3005,39 @@
     }
 
     @Nullable
-    public EntityPlayer getClosestPlayerToEntity(Entity entityIn, double distance)
-    {
+    public EntityPlayer getClosestPlayerToEntity(Entity entityIn, double distance) {
         return this.getClosestPlayer(entityIn.posX, entityIn.posY, entityIn.posZ, distance, false);
     }
 
     @Nullable
-    public EntityPlayer getNearestPlayerNotCreative(Entity entityIn, double distance)
-    {
+    public EntityPlayer getNearestPlayerNotCreative(Entity entityIn, double distance) {
         return this.getClosestPlayer(entityIn.posX, entityIn.posY, entityIn.posZ, distance, true);
     }
 
     @Nullable
-    public EntityPlayer getClosestPlayer(double posX, double posY, double posZ, double distance, boolean spectator)
-    {
+    public EntityPlayer getClosestPlayer(double posX, double posY, double posZ, double distance, boolean spectator) {
         Predicate<Entity> predicate = spectator ? EntitySelectors.CAN_AI_TARGET : EntitySelectors.NOT_SPECTATING;
         return this.getClosestPlayer(posX, posY, posZ, distance, predicate);
     }
 
     @Nullable
-    public EntityPlayer getClosestPlayer(double x, double y, double z, double p_190525_7_, Predicate<Entity> p_190525_9_)
-    {
+    public EntityPlayer getClosestPlayer(double x, double y, double z, double p_190525_7_, Predicate<Entity> p_190525_9_) {
         double d0 = -1.0D;
         EntityPlayer entityplayer = null;
 
-        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2)
-        {
+        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2) {
             EntityPlayer entityplayer1 = this.playerEntities.get(j2);
 
-            if (p_190525_9_.apply(entityplayer1))
-            {
+            // CraftBukkit start - Fixed an NPE
+            if (entityplayer1 == null || entityplayer1.isDead) {
+                continue;
+            }
+            // CraftBukkit end
+
+            if (p_190525_9_.apply(entityplayer1)) {
                 double d1 = entityplayer1.getDistanceSq(x, y, z);
 
-                if ((p_190525_7_ < 0.0D || d1 < p_190525_7_ * p_190525_7_) && (d0 == -1.0D || d1 < d0))
-                {
+                if ((p_190525_7_ < 0.0D || d1 < p_190525_7_ * p_190525_7_) && (d0 == -1.0D || d1 < d0)) {
                     d0 = d1;
                     entityplayer = entityplayer1;
                 }
@@ -3360,18 +3047,14 @@
         return entityplayer;
     }
 
-    public boolean isAnyPlayerWithinRangeAt(double x, double y, double z, double range)
-    {
-        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2)
-        {
+    public boolean isAnyPlayerWithinRangeAt(double x, double y, double z, double range) {
+        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2) {
             EntityPlayer entityplayer = this.playerEntities.get(j2);
 
-            if (EntitySelectors.NOT_SPECTATING.apply(entityplayer))
-            {
+            if (EntitySelectors.NOT_SPECTATING.apply(entityplayer)) {
                 double d0 = entityplayer.getDistanceSq(x, y, z);
 
-                if (range < 0.0D || d0 < range * range)
-                {
+                if (range < 0.0D || d0 < range * range) {
                     return true;
                 }
             }
@@ -3381,58 +3064,48 @@
     }
 
     @Nullable
-    public EntityPlayer getNearestAttackablePlayer(Entity entityIn, double maxXZDistance, double maxYDistance)
-    {
-        return this.getNearestAttackablePlayer(entityIn.posX, entityIn.posY, entityIn.posZ, maxXZDistance, maxYDistance, (Function)null, (Predicate)null);
+    public EntityPlayer getNearestAttackablePlayer(Entity entityIn, double maxXZDistance, double maxYDistance) {
+        return this.getNearestAttackablePlayer(entityIn.posX, entityIn.posY, entityIn.posZ, maxXZDistance, maxYDistance, (Function) null, (Predicate) null);
     }
 
     @Nullable
-    public EntityPlayer getNearestAttackablePlayer(BlockPos pos, double maxXZDistance, double maxYDistance)
-    {
-        return this.getNearestAttackablePlayer((double)((float)pos.getX() + 0.5F), (double)((float)pos.getY() + 0.5F), (double)((float)pos.getZ() + 0.5F), maxXZDistance, maxYDistance, (Function)null, (Predicate)null);
+    public EntityPlayer getNearestAttackablePlayer(BlockPos pos, double maxXZDistance, double maxYDistance) {
+        return this.getNearestAttackablePlayer((double) ((float) pos.getX() + 0.5F), (double) ((float) pos.getY() + 0.5F), (double) ((float) pos.getZ() + 0.5F), maxXZDistance, maxYDistance, (Function) null, (Predicate) null);
     }
 
     @Nullable
-    public EntityPlayer getNearestAttackablePlayer(double posX, double posY, double posZ, double maxXZDistance, double maxYDistance, @Nullable Function<EntityPlayer, Double> playerToDouble, @Nullable Predicate<EntityPlayer> p_184150_12_)
-    {
+    public EntityPlayer getNearestAttackablePlayer(double posX, double posY, double posZ, double maxXZDistance, double maxYDistance, @Nullable Function<EntityPlayer, Double> playerToDouble, @Nullable Predicate<EntityPlayer> p_184150_12_) {
         double d0 = -1.0D;
         EntityPlayer entityplayer = null;
 
-        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2)
-        {
+        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2) {
             EntityPlayer entityplayer1 = this.playerEntities.get(j2);
 
-            if (!entityplayer1.capabilities.disableDamage && entityplayer1.isEntityAlive() && !entityplayer1.isSpectator() && (p_184150_12_ == null || p_184150_12_.apply(entityplayer1)))
-            {
+            if (!entityplayer1.capabilities.disableDamage && entityplayer1.isEntityAlive() && !entityplayer1.isSpectator() && (p_184150_12_ == null || p_184150_12_.apply(entityplayer1))) {
                 double d1 = entityplayer1.getDistanceSq(posX, entityplayer1.posY, posZ);
                 double d2 = maxXZDistance;
 
-                if (entityplayer1.isSneaking())
-                {
+                if (entityplayer1.isSneaking()) {
                     d2 = maxXZDistance * 0.800000011920929D;
                 }
 
-                if (entityplayer1.isInvisible())
-                {
+                if (entityplayer1.isInvisible()) {
                     float f = entityplayer1.getArmorVisibility();
 
-                    if (f < 0.1F)
-                    {
+                    if (f < 0.1F) {
                         f = 0.1F;
                     }
 
-                    d2 *= (double)(0.7F * f);
+                    d2 *= (double) (0.7F * f);
                 }
 
-                if (playerToDouble != null)
-                {
-                    d2 *= ((Double)MoreObjects.firstNonNull(playerToDouble.apply(entityplayer1), Double.valueOf(1.0D))).doubleValue();
+                if (playerToDouble != null) {
+                    d2 *= ((Double) MoreObjects.firstNonNull(playerToDouble.apply(entityplayer1), Double.valueOf(1.0D))).doubleValue();
                 }
 
                 d2 = net.minecraftforge.common.ForgeHooks.getPlayerVisibilityDistance(entityplayer1, d2, maxYDistance);
 
-                if ((maxYDistance < 0.0D || Math.abs(entityplayer1.posY - posY) < maxYDistance * maxYDistance) && (maxXZDistance < 0.0D || d1 < d2 * d2) && (d0 == -1.0D || d1 < d0))
-                {
+                if ((maxYDistance < 0.0D || Math.abs(entityplayer1.posY - posY) < maxYDistance * maxYDistance) && (maxXZDistance < 0.0D || d1 < d2 * d2) && (d0 == -1.0D || d1 < d0)) {
                     d0 = d1;
                     entityplayer = entityplayer1;
                 }
@@ -3443,14 +3116,11 @@
     }
 
     @Nullable
-    public EntityPlayer getPlayerEntityByName(String name)
-    {
-        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2)
-        {
+    public EntityPlayer getPlayerEntityByName(String name) {
+        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2) {
             EntityPlayer entityplayer = this.playerEntities.get(j2);
 
-            if (name.equals(entityplayer.getName()))
-            {
+            if (name.equals(entityplayer.getName())) {
                 return entityplayer;
             }
         }
@@ -3459,14 +3129,11 @@
     }
 
     @Nullable
-    public EntityPlayer getPlayerEntityByUUID(UUID uuid)
-    {
-        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2)
-        {
+    public EntityPlayer getPlayerEntityByUUID(UUID uuid) {
+        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2) {
             EntityPlayer entityplayer = this.playerEntities.get(j2);
 
-            if (uuid.equals(entityplayer.getUniqueID()))
-            {
+            if (uuid.equals(entityplayer.getUniqueID())) {
                 return entityplayer;
             }
         }
@@ -3475,237 +3142,194 @@
     }
 
     @SideOnly(Side.CLIENT)
-    public void sendQuittingDisconnectingPacket()
-    {
+    public void sendQuittingDisconnectingPacket() {
     }
 
-    public void checkSessionLock() throws MinecraftException
-    {
+    public void checkSessionLock() throws MinecraftException {
         this.saveHandler.checkSessionLock();
     }
 
     @SideOnly(Side.CLIENT)
-    public void setTotalWorldTime(long worldTime)
-    {
+    public void setTotalWorldTime(long worldTime) {
         this.worldInfo.setWorldTotalTime(worldTime);
     }
 
-    public long getSeed()
-    {
+    public long getSeed() {
         return this.provider.getSeed();
     }
 
-    public long getTotalWorldTime()
-    {
+    public long getTotalWorldTime() {
         return this.worldInfo.getWorldTotalTime();
     }
 
-    public long getWorldTime()
-    {
+    public long getWorldTime() {
         return this.provider.getWorldTime();
     }
 
-    public void setWorldTime(long time)
-    {
+    public void setWorldTime(long time) {
         this.provider.setWorldTime(time);
     }
 
-    public BlockPos getSpawnPoint()
-    {
+    public BlockPos getSpawnPoint() {
         BlockPos blockpos1 = this.provider.getSpawnPoint();
 
-        if (!this.getWorldBorder().contains(blockpos1))
-        {
+        if (!this.getWorldBorder().contains(blockpos1)) {
             blockpos1 = this.getHeight(new BlockPos(this.getWorldBorder().getCenterX(), 0.0D, this.getWorldBorder().getCenterZ()));
         }
 
         return blockpos1;
     }
 
-    public void setSpawnPoint(BlockPos pos)
-    {
+    public void setSpawnPoint(BlockPos pos) {
         this.provider.setSpawnPoint(pos);
     }
 
     @SideOnly(Side.CLIENT)
-    public void joinEntityInSurroundings(Entity entityIn)
-    {
+    public void joinEntityInSurroundings(Entity entityIn) {
         int j2 = MathHelper.floor(entityIn.posX / 16.0D);
         int k2 = MathHelper.floor(entityIn.posZ / 16.0D);
         int l2 = 2;
 
-        for (int i3 = -2; i3 <= 2; ++i3)
-        {
-            for (int j3 = -2; j3 <= 2; ++j3)
-            {
+        for (int i3 = -2; i3 <= 2; ++i3) {
+            for (int j3 = -2; j3 <= 2; ++j3) {
                 this.getChunkFromChunkCoords(j2 + i3, k2 + j3);
             }
         }
 
-        if (!this.loadedEntityList.contains(entityIn))
-        {
+        if (!this.loadedEntityList.contains(entityIn)) {
             if (!net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entityIn, this)))
-            this.loadedEntityList.add(entityIn);
+                this.loadedEntityList.add(entityIn);
         }
     }
 
-    public boolean isBlockModifiable(EntityPlayer player, BlockPos pos)
-    {
+    public boolean isBlockModifiable(EntityPlayer player, BlockPos pos) {
         return this.provider.canMineBlock(player, pos);
     }
 
-    public boolean canMineBlockBody(EntityPlayer player, BlockPos pos)
-    {
+    public boolean canMineBlockBody(EntityPlayer player, BlockPos pos) {
         return true;
     }
 
-    public void setEntityState(Entity entityIn, byte state)
-    {
+    public void setEntityState(Entity entityIn, byte state) {
     }
 
-    public IChunkProvider getChunkProvider()
-    {
+    public IChunkProvider getChunkProvider() {
         return this.chunkProvider;
     }
 
-    public void addBlockEvent(BlockPos pos, Block blockIn, int eventID, int eventParam)
-    {
+    public void addBlockEvent(BlockPos pos, Block blockIn, int eventID, int eventParam) {
         this.getBlockState(pos).onBlockEventReceived(this, pos, eventID, eventParam);
     }
 
-    public ISaveHandler getSaveHandler()
-    {
+    public ISaveHandler getSaveHandler() {
         return this.saveHandler;
     }
 
-    public WorldInfo getWorldInfo()
-    {
+    public WorldInfo getWorldInfo() {
         return this.worldInfo;
     }
 
-    public GameRules getGameRules()
-    {
+    public GameRules getGameRules() {
         return this.worldInfo.getGameRulesInstance();
     }
 
-    public void updateAllPlayersSleepingFlag()
-    {
+    public void updateAllPlayersSleepingFlag() {
     }
 
-    public float getThunderStrength(float delta)
-    {
+    // CraftBukkit start
+    // Calls the method that checks to see if players are sleeping
+    // Called by CraftPlayer.setPermanentSleeping()
+    public void checkSleepStatus() {
+        if (!this.isRemote) {
+            this.updateAllPlayersSleepingFlag();
+        }
+    }
+    // CraftBukkit end
+
+    public float getThunderStrength(float delta) {
         return (this.prevThunderingStrength + (this.thunderingStrength - this.prevThunderingStrength) * delta) * this.getRainStrength(delta);
     }
 
     @SideOnly(Side.CLIENT)
-    public void setThunderStrength(float strength)
-    {
+    public void setThunderStrength(float strength) {
         this.prevThunderingStrength = strength;
         this.thunderingStrength = strength;
     }
 
-    public float getRainStrength(float delta)
-    {
+    public float getRainStrength(float delta) {
         return this.prevRainingStrength + (this.rainingStrength - this.prevRainingStrength) * delta;
     }
 
     @SideOnly(Side.CLIENT)
-    public void setRainStrength(float strength)
-    {
+    public void setRainStrength(float strength) {
         this.prevRainingStrength = strength;
         this.rainingStrength = strength;
     }
 
-    public boolean isThundering()
-    {
-        return (double)this.getThunderStrength(1.0F) > 0.9D;
+    public boolean isThundering() {
+        return (double) this.getThunderStrength(1.0F) > 0.9D;
     }
 
-    public boolean isRaining()
-    {
-        return (double)this.getRainStrength(1.0F) > 0.2D;
+    public boolean isRaining() {
+        return (double) this.getRainStrength(1.0F) > 0.2D;
     }
 
-    public boolean isRainingAt(BlockPos position)
-    {
-        if (!this.isRaining())
-        {
+    public boolean isRainingAt(BlockPos position) {
+        if (!this.isRaining()) {
             return false;
-        }
-        else if (!this.canSeeSky(position))
-        {
+        } else if (!this.canSeeSky(position)) {
             return false;
-        }
-        else if (this.getPrecipitationHeight(position).getY() > position.getY())
-        {
+        } else if (this.getPrecipitationHeight(position).getY() > position.getY()) {
             return false;
-        }
-        else
-        {
+        } else {
             Biome biome = this.getBiome(position);
 
-            if (biome.getEnableSnow())
-            {
+            if (biome.getEnableSnow()) {
                 return false;
-            }
-            else
-            {
+            } else {
                 return this.canSnowAt(position, false) ? false : biome.canRain();
             }
         }
     }
 
-    public boolean isBlockinHighHumidity(BlockPos pos)
-    {
+    public boolean isBlockinHighHumidity(BlockPos pos) {
         return this.provider.isBlockHighHumidity(pos);
     }
 
     @Nullable
-    public MapStorage getMapStorage()
-    {
+    public MapStorage getMapStorage() {
         return this.mapStorage;
     }
 
-    public void setData(String dataID, WorldSavedData worldSavedDataIn)
-    {
+    public void setData(String dataID, WorldSavedData worldSavedDataIn) {
         this.mapStorage.setData(dataID, worldSavedDataIn);
     }
 
     @Nullable
-    public WorldSavedData loadData(Class <? extends WorldSavedData > clazz, String dataID)
-    {
+    public WorldSavedData loadData(Class<? extends WorldSavedData> clazz, String dataID) {
         return this.mapStorage.getOrLoadData(clazz, dataID);
     }
 
-    public int getUniqueDataId(String key)
-    {
+    public int getUniqueDataId(String key) {
         return this.mapStorage.getUniqueDataId(key);
     }
 
-    public void playBroadcastSound(int id, BlockPos pos, int data)
-    {
-        for (int j2 = 0; j2 < this.eventListeners.size(); ++j2)
-        {
-            ((IWorldEventListener)this.eventListeners.get(j2)).broadcastSound(id, pos, data);
+    public void playBroadcastSound(int id, BlockPos pos, int data) {
+        for (int j2 = 0; j2 < this.eventListeners.size(); ++j2) {
+            ((IWorldEventListener) this.eventListeners.get(j2)).broadcastSound(id, pos, data);
         }
     }
 
-    public void playEvent(int type, BlockPos pos, int data)
-    {
-        this.playEvent((EntityPlayer)null, type, pos, data);
+    public void playEvent(int type, BlockPos pos, int data) {
+        this.playEvent((EntityPlayer) null, type, pos, data);
     }
 
-    public void playEvent(@Nullable EntityPlayer player, int type, BlockPos pos, int data)
-    {
-        try
-        {
-            for (int j2 = 0; j2 < this.eventListeners.size(); ++j2)
-            {
-                ((IWorldEventListener)this.eventListeners.get(j2)).playEvent(player, type, pos, data);
+    public void playEvent(@Nullable EntityPlayer player, int type, BlockPos pos, int data) {
+        try {
+            for (int j2 = 0; j2 < this.eventListeners.size(); ++j2) {
+                ((IWorldEventListener) this.eventListeners.get(j2)).playEvent(player, type, pos, data);
             }
-        }
-        catch (Throwable throwable3)
-        {
+        } catch (Throwable throwable3) {
             CrashReport crashreport3 = CrashReport.makeCrashReport(throwable3, "Playing level event");
             CrashReportCategory crashreportcategory3 = crashreport3.makeCategory("Level event being played");
             crashreportcategory3.addCrashSection("Block coordinates", CrashReportCategory.getCoordinateInfo(pos));
@@ -3716,48 +3340,37 @@
         }
     }
 
-    public int getHeight()
-    {
+    public int getHeight() {
         return this.provider.getHeight();
     }
 
-    public int getActualHeight()
-    {
+    public int getActualHeight() {
         return this.provider.getActualHeight();
     }
 
-    public Random setRandomSeed(int p_72843_1_, int p_72843_2_, int p_72843_3_)
-    {
-        long j2 = (long)p_72843_1_ * 341873128712L + (long)p_72843_2_ * 132897987541L + this.getWorldInfo().getSeed() + (long)p_72843_3_;
+    public Random setRandomSeed(int p_72843_1_, int p_72843_2_, int p_72843_3_) {
+        long j2 = (long) p_72843_1_ * 341873128712L + (long) p_72843_2_ * 132897987541L + this.getWorldInfo().getSeed() + (long) p_72843_3_;
         this.rand.setSeed(j2);
         return this.rand;
     }
 
-    public CrashReportCategory addWorldInfoToCrashReport(CrashReport report)
-    {
+    public CrashReportCategory addWorldInfoToCrashReport(CrashReport report) {
         CrashReportCategory crashreportcategory3 = report.makeCategoryDepth("Affected level", 1);
         crashreportcategory3.addCrashSection("Level name", this.worldInfo == null ? "????" : this.worldInfo.getWorldName());
-        crashreportcategory3.addDetail("All players", new ICrashReportDetail<String>()
-        {
-            public String call()
-            {
+        crashreportcategory3.addDetail("All players", new ICrashReportDetail<String>() {
+            public String call() {
                 return World.this.playerEntities.size() + " total; " + World.this.playerEntities;
             }
         });
-        crashreportcategory3.addDetail("Chunk stats", new ICrashReportDetail<String>()
-        {
-            public String call()
-            {
+        crashreportcategory3.addDetail("Chunk stats", new ICrashReportDetail<String>() {
+            public String call() {
                 return World.this.chunkProvider.makeString();
             }
         });
 
-        try
-        {
+        try {
             this.worldInfo.addToCrashReport(crashreportcategory3);
-        }
-        catch (Throwable throwable3)
-        {
+        } catch (Throwable throwable3) {
             crashreportcategory3.addCrashSectionThrowable("Level Data Unobtainable", throwable3);
         }
 
@@ -3765,24 +3378,19 @@
     }
 
     @SideOnly(Side.CLIENT)
-    public double getHorizon()
-    {
+    public double getHorizon() {
         return provider.getHorizon();
     }
 
-    public void sendBlockBreakProgress(int breakerId, BlockPos pos, int progress)
-    {
-        for (int j2 = 0; j2 < this.eventListeners.size(); ++j2)
-        {
+    public void sendBlockBreakProgress(int breakerId, BlockPos pos, int progress) {
+        for (int j2 = 0; j2 < this.eventListeners.size(); ++j2) {
             IWorldEventListener iworldeventlistener = this.eventListeners.get(j2);
             iworldeventlistener.sendBlockBreakProgress(breakerId, pos, progress);
         }
     }
 
-    public Calendar getCurrentDate()
-    {
-        if (this.getTotalWorldTime() % 600L == 0L)
-        {
+    public Calendar getCurrentDate() {
+        if (this.getTotalWorldTime() % 600L == 0L) {
             this.calendar.setTimeInMillis(MinecraftServer.getCurrentTimeMillis());
         }
 
@@ -3790,33 +3398,26 @@
     }
 
     @SideOnly(Side.CLIENT)
-    public void makeFireworks(double x, double y, double z, double motionX, double motionY, double motionZ, @Nullable NBTTagCompound compound)
-    {
+    public void makeFireworks(double x, double y, double z, double motionX, double motionY, double motionZ, @Nullable NBTTagCompound compound) {
     }
 
-    public Scoreboard getScoreboard()
-    {
+    public Scoreboard getScoreboard() {
         return this.worldScoreboard;
     }
 
-    public void updateComparatorOutputLevel(BlockPos pos, Block blockIn)
-    {
-        for (EnumFacing enumfacing : EnumFacing.VALUES)
-        {
+    public void updateComparatorOutputLevel(BlockPos pos, Block blockIn) {
+        for (EnumFacing enumfacing : EnumFacing.VALUES) {
             BlockPos blockpos1 = pos.offset(enumfacing);
 
-            if (this.isBlockLoaded(blockpos1))
-            {
+            if (this.isBlockLoaded(blockpos1)) {
                 IBlockState iblockstate1 = this.getBlockState(blockpos1);
 
                 iblockstate1.getBlock().onNeighborChange(this, blockpos1, pos);
-                if (iblockstate1.getBlock().isNormalCube(iblockstate1, this, blockpos1))
-                {
+                if (iblockstate1.getBlock().isNormalCube(iblockstate1, this, blockpos1)) {
                     blockpos1 = blockpos1.offset(enumfacing);
                     iblockstate1 = this.getBlockState(blockpos1);
 
-                    if (iblockstate1.getBlock().getWeakChanges(this, blockpos1))
-                    {
+                    if (iblockstate1.getBlock().getWeakChanges(this, blockpos1)) {
                         iblockstate1.getBlock().onNeighborChange(this, blockpos1, pos);
                     }
                 }
@@ -3824,13 +3425,11 @@
         }
     }
 
-    public DifficultyInstance getDifficultyForLocation(BlockPos pos)
-    {
+    public DifficultyInstance getDifficultyForLocation(BlockPos pos) {
         long j2 = 0L;
         float f = 0.0F;
 
-        if (this.isBlockLoaded(pos))
-        {
+        if (this.isBlockLoaded(pos)) {
             f = this.getCurrentMoonPhaseFactor();
             j2 = this.getChunkFromBlockCoords(pos).getInhabitedTime();
         }
@@ -3838,77 +3437,68 @@
         return new DifficultyInstance(this.getDifficulty(), this.getWorldTime(), j2, f);
     }
 
-    public EnumDifficulty getDifficulty()
-    {
+    public EnumDifficulty getDifficulty() {
         return this.getWorldInfo().getDifficulty();
     }
 
-    public int getSkylightSubtracted()
-    {
+    public int getSkylightSubtracted() {
         return this.skylightSubtracted;
     }
 
-    public void setSkylightSubtracted(int newSkylightSubtracted)
-    {
+    public void setSkylightSubtracted(int newSkylightSubtracted) {
         this.skylightSubtracted = newSkylightSubtracted;
     }
 
     @SideOnly(Side.CLIENT)
-    public int getLastLightningBolt()
-    {
+    public int getLastLightningBolt() {
         return this.lastLightningBolt;
     }
 
-    public void setLastLightningBolt(int lastLightningBoltIn)
-    {
+    public void setLastLightningBolt(int lastLightningBoltIn) {
         this.lastLightningBolt = lastLightningBoltIn;
     }
 
-    public VillageCollection getVillageCollection()
-    {
+    public VillageCollection getVillageCollection() {
         return this.villageCollection;
     }
 
-    public WorldBorder getWorldBorder()
-    {
+    public WorldBorder getWorldBorder() {
         return this.worldBorder;
     }
 
-    public boolean isSpawnChunk(int x, int z)
-    {
+    public boolean isSpawnChunk(int x, int z) {
         BlockPos blockpos1 = this.getSpawnPoint();
         int j2 = x * 16 + 8 - blockpos1.getX();
         int k2 = z * 16 + 8 - blockpos1.getZ();
         int l2 = 128;
-        return j2 >= -128 && j2 <= 128 && k2 >= -128 && k2 <= 128;
+        return j2 >= -128 && j2 <= 128 && k2 >= -128 && k2 <= 128 && this.keepSpawnInMemory;  // CraftBukkit - Added 'this.keepSpawnInMemory'
     }
 
     /* ======================================== FORGE START =====================================*/
+
     /**
      * Determine if the given block is considered solid on the
      * specified side.  Used by placement logic.
      *
-     * @param pos Block Position
+     * @param pos  Block Position
      * @param side The Side in question
      * @return True if the side is solid
-    */
-    public boolean isSideSolid(BlockPos pos, EnumFacing side)
-    {
-       return isSideSolid(pos, side, false);
+     */
+    public boolean isSideSolid(BlockPos pos, EnumFacing side) {
+        return isSideSolid(pos, side, false);
     }
 
     /**
      * Determine if the given block is considered solid on the
      * specified side.  Used by placement logic.
      *
-     * @param pos Block Position
-     * @param side The Side in question
+     * @param pos      Block Position
+     * @param side     The Side in question
      * @param _default The default to return if the block doesn't exist.
      * @return True if the side is solid
      */
     @Override
-    public boolean isSideSolid(BlockPos pos, EnumFacing side, boolean _default)
-    {
+    public boolean isSideSolid(BlockPos pos, EnumFacing side, boolean _default) {
         if (!this.isValid(pos)) return _default;
 
         Chunk chunk = getChunkFromBlockCoords(pos);
@@ -3921,23 +3511,21 @@
      *
      * @return
      */
-    public com.google.common.collect.ImmutableSetMultimap<net.minecraft.util.math.ChunkPos, net.minecraftforge.common.ForgeChunkManager.Ticket> getPersistentChunks()
-    {
+    public com.google.common.collect.ImmutableSetMultimap<net.minecraft.util.math.ChunkPos, net.minecraftforge.common.ForgeChunkManager.Ticket> getPersistentChunks() {
         return net.minecraftforge.common.ForgeChunkManager.getPersistentChunksFor(this);
     }
 
-    public Iterator<Chunk> getPersistentChunkIterable(Iterator<Chunk> chunkIterator)
-    {
+    public Iterator<Chunk> getPersistentChunkIterable(Iterator<Chunk> chunkIterator) {
         return net.minecraftforge.common.ForgeChunkManager.getPersistentChunksIterableFor(this, chunkIterator);
     }
+
     /**
      * Readded as it was removed, very useful helper function
      *
      * @param pos Block position
      * @return The blocks light opacity
      */
-    public int getBlockLightOpacity(BlockPos pos)
-    {
+    public int getBlockLightOpacity(BlockPos pos) {
         if (!this.isValid(pos)) return 0;
         return getChunkFromBlockCoords(pos).getBlockLightOpacity(pos);
     }
@@ -3945,13 +3533,10 @@
     /**
      * Returns a count of entities that classify themselves as the specified creature type.
      */
-    public int countEntities(net.minecraft.entity.EnumCreatureType type, boolean forSpawnCount)
-    {
+    public int countEntities(net.minecraft.entity.EnumCreatureType type, boolean forSpawnCount) {
         int count = 0;
-        for (int x = 0; x < loadedEntityList.size(); x++)
-        {
-            if (((Entity)loadedEntityList.get(x)).isCreatureType(type, forSpawnCount))
-            {
+        for (int x = 0; x < loadedEntityList.size(); x++) {
+            if (((Entity) loadedEntityList.get(x)).isCreatureType(type, forSpawnCount)) {
                 count++;
             }
         }
@@ -3959,61 +3544,93 @@
     }
 
     @Deprecated // remove in 1.13
-    public void markTileEntitiesInChunkForRemoval(Chunk chunk)
-    {
-        for (TileEntity tileentity : chunk.getTileEntityMap().values())
-        {
+    public void markTileEntitiesInChunkForRemoval(Chunk chunk) {
+        for (TileEntity tileentity : chunk.getTileEntityMap().values()) {
             markTileEntityForRemoval(tileentity);
         }
     }
 
-    protected void initCapabilities()
-    {
+    protected void initCapabilities() {
         net.minecraftforge.common.capabilities.ICapabilityProvider parent = provider.initCapabilities();
         capabilities = net.minecraftforge.event.ForgeEventFactory.gatherCapabilities(this, parent);
-        net.minecraftforge.common.util.WorldCapabilityData data = (net.minecraftforge.common.util.WorldCapabilityData)perWorldStorage.getOrLoadData(net.minecraftforge.common.util.WorldCapabilityData.class, net.minecraftforge.common.util.WorldCapabilityData.ID);
-        if (data == null)
-        {
+        net.minecraftforge.common.util.WorldCapabilityData data = (net.minecraftforge.common.util.WorldCapabilityData) perWorldStorage.getOrLoadData(net.minecraftforge.common.util.WorldCapabilityData.class, net.minecraftforge.common.util.WorldCapabilityData.ID);
+        if (data == null) {
             capabilityData = new net.minecraftforge.common.util.WorldCapabilityData(capabilities);
             perWorldStorage.setData(capabilityData.mapName, capabilityData);
-        }
-        else
-        {
+        } else {
             capabilityData = data;
             capabilityData.setCapabilities(provider, capabilities);
         }
     }
+
     @Override
-    public boolean hasCapability(net.minecraftforge.common.capabilities.Capability<?> capability, @Nullable EnumFacing facing)
-    {
+    public boolean hasCapability(Capability<?> capability, @Nullable EnumFacing facing) {
         return capabilities == null ? false : capabilities.hasCapability(capability, facing);
     }
+
     @Override
     @Nullable
-    public <T> T getCapability(net.minecraftforge.common.capabilities.Capability<T> capability, @Nullable EnumFacing facing)
-    {
+    public <T> T getCapability(Capability<T> capability, @Nullable EnumFacing facing) {
         return capabilities == null ? null : capabilities.getCapability(capability, facing);
     }
 
-    protected MapStorage perWorldStorage; //Moved to a getter to simulate final without being final so we can load in subclasses.
-    public MapStorage getPerWorldStorage()
-    {
+    protected MapStorage perWorldStorage; // Moved to a getter to simulate final without being final so we can load in subclasses.
+
+    public MapStorage getPerWorldStorage() {
         return perWorldStorage;
     }
 
-    public void sendPacketToServer(Packet<?> packetIn)
-    {
+    public void sendPacketToServer(Packet<?> packetIn) {
         throw new UnsupportedOperationException("Can't send packets to server unless you're on the client.");
     }
 
-    public LootTableManager getLootTableManager()
-    {
+    public LootTableManager getLootTableManager() {
         return this.lootTable;
     }
 
     @Nullable
-    public BlockPos findNearestStructure(String p_190528_1_, BlockPos p_190528_2_, boolean p_190528_3_)
-    {
+    public BlockPos findNearestStructure(String p_190528_1_, BlockPos p_190528_2_, boolean p_190528_3_) {
         return null;
     }
+
+    public ImmutableSetMultimap<ChunkPos, ForgeChunkManager.Ticket> getForcedChunks() {
+        return forcedChunks;
+    }
+
+    public void setForcedChunks(ImmutableSetMultimap<ChunkPos, ForgeChunkManager.Ticket> forcedChunks) {
+        this.forcedChunks = forcedChunks;
+    }
+
+    public ExecutorService lightingExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("Paper - Lighting Thread").build()); // Paper - Asynchronous lighting updates
+
+    /**
+     * Paper - Asynchronous lighting updates
+     */
+    public boolean checkLightFor(EnumSkyBlock enumskyblock, BlockPos pos) {
+        Chunk chunk = this.getChunkIfLoaded(pos.getX() >> 4, pos.getZ() >> 4);
+        if (chunk == null || !chunk.areNeighborsLoaded(1)) {
+            return false;
+        }
+
+        List<Chunk> neighbors = new ArrayList<>();
+        for (int cx = (pos.getX() >> 4) - 1; cx <= (pos.getX() >> 4) + 1; ++cx) {
+            for (int cz = (pos.getZ() >> 4) - 1; cz <= (pos.getZ() >> 4) + 1; ++cz) {
+                if (cx != pos.getX() >> 4 && cz != pos.getZ() >> 4) {
+                    Chunk neighbor = this.getChunkIfLoaded(cx, cz);
+                    if (neighbor != null) {
+                        neighbors.add(neighbor);
+                    }
+                }
+            }
+        }
+
+        if (!Bukkit.isPrimaryThread()) {
+            return this.checkLightFor(enumskyblock, pos.getX(), pos.getY(), pos.getZ());
+        }
+
+        lightingExecutor.submit(() -> {
+            World.this.checkLightFor(enumskyblock, pos.getX(), pos.getY(), pos.getZ());
+        });
+        return true;
+    }
 }
