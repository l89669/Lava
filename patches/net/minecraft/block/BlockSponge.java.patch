--- ../src-base/minecraft/net/minecraft/block/BlockSponge.java
+++ ../src-work/minecraft/net/minecraft/block/BlockSponge.java
@@ -1,9 +1,6 @@
 package net.minecraft.block;
 
 import com.google.common.collect.Lists;
-import java.util.List;
-import java.util.Queue;
-import java.util.Random;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.properties.IProperty;
 import net.minecraft.block.properties.PropertyBool;
@@ -22,158 +19,128 @@
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
 
-public class BlockSponge extends Block
-{
+import java.util.List;
+import java.util.Queue;
+import java.util.Random;
+
+public class BlockSponge extends Block {
     public static final PropertyBool WET = PropertyBool.create("wet");
 
-    protected BlockSponge()
-    {
+    protected BlockSponge() {
         super(Material.SPONGE);
         this.setDefaultState(this.blockState.getBaseState().withProperty(WET, Boolean.valueOf(false)));
         this.setCreativeTab(CreativeTabs.BUILDING_BLOCKS);
     }
 
-    public String getLocalizedName()
-    {
+    public String getLocalizedName() {
         return I18n.translateToLocal(this.getUnlocalizedName() + ".dry.name");
     }
 
-    public int damageDropped(IBlockState state)
-    {
-        return ((Boolean)state.getValue(WET)).booleanValue() ? 1 : 0;
+    public int damageDropped(IBlockState state) {
+        return ((Boolean) state.getValue(WET)).booleanValue() ? 1 : 0;
     }
 
-    public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state)
-    {
+    public void onBlockAdded(World worldIn, BlockPos pos, IBlockState state) {
         this.tryAbsorb(worldIn, pos, state);
     }
 
-    public void neighborChanged(IBlockState state, World worldIn, BlockPos pos, Block blockIn, BlockPos fromPos)
-    {
+    public void neighborChanged(IBlockState state, World worldIn, BlockPos pos, Block blockIn, BlockPos fromPos) {
         this.tryAbsorb(worldIn, pos, state);
         super.neighborChanged(state, worldIn, pos, blockIn, fromPos);
     }
 
-    protected void tryAbsorb(World worldIn, BlockPos pos, IBlockState state)
-    {
-        if (!((Boolean)state.getValue(WET)).booleanValue() && this.absorb(worldIn, pos))
-        {
+    protected void tryAbsorb(World worldIn, BlockPos pos, IBlockState state) {
+        if (!((Boolean) state.getValue(WET)).booleanValue() && this.absorb(worldIn, pos)) {
             worldIn.setBlockState(pos, state.withProperty(WET, Boolean.valueOf(true)), 2);
             worldIn.playEvent(2001, pos, Block.getIdFromBlock(Blocks.WATER));
         }
     }
 
-    private boolean absorb(World worldIn, BlockPos pos)
-    {
+    private boolean absorb(World worldIn, BlockPos pos) {
         Queue<Tuple<BlockPos, Integer>> queue = Lists.<Tuple<BlockPos, Integer>>newLinkedList();
         List<BlockPos> list = Lists.<BlockPos>newArrayList();
         queue.add(new Tuple(pos, Integer.valueOf(0)));
         int i = 0;
 
-        while (!queue.isEmpty())
-        {
-            Tuple<BlockPos, Integer> tuple = (Tuple)queue.poll();
+        while (!queue.isEmpty()) {
+            Tuple<BlockPos, Integer> tuple = (Tuple) queue.poll();
             BlockPos blockpos = tuple.getFirst();
-            int j = ((Integer)tuple.getSecond()).intValue();
+            int j = ((Integer) tuple.getSecond()).intValue();
 
-            for (EnumFacing enumfacing : EnumFacing.values())
-            {
+            for (EnumFacing enumfacing : EnumFacing.values()) {
                 BlockPos blockpos1 = blockpos.offset(enumfacing);
 
-                if (worldIn.getBlockState(blockpos1).getMaterial() == Material.WATER)
-                {
+                if (worldIn.getBlockState(blockpos1).getMaterial() == Material.WATER) {
                     worldIn.setBlockState(blockpos1, Blocks.AIR.getDefaultState(), 2);
                     list.add(blockpos1);
                     ++i;
 
-                    if (j < 6)
-                    {
+                    if (j < 6) {
                         queue.add(new Tuple(blockpos1, j + 1));
                     }
                 }
             }
 
-            if (i > 64)
-            {
+            if (i > 64) {
                 break;
             }
         }
 
-        for (BlockPos blockpos2 : list)
-        {
+        for (BlockPos blockpos2 : list) {
             worldIn.notifyNeighborsOfStateChange(blockpos2, Blocks.AIR, false);
         }
 
         return i > 0;
     }
 
-    public void getSubBlocks(CreativeTabs itemIn, NonNullList<ItemStack> items)
-    {
+    public void getSubBlocks(CreativeTabs itemIn, NonNullList<ItemStack> items) {
         items.add(new ItemStack(this, 1, 0));
         items.add(new ItemStack(this, 1, 1));
     }
 
-    public IBlockState getStateFromMeta(int meta)
-    {
+    public IBlockState getStateFromMeta(int meta) {
         return this.getDefaultState().withProperty(WET, Boolean.valueOf((meta & 1) == 1));
     }
 
-    public int getMetaFromState(IBlockState state)
-    {
-        return ((Boolean)state.getValue(WET)).booleanValue() ? 1 : 0;
+    public int getMetaFromState(IBlockState state) {
+        return ((Boolean) state.getValue(WET)).booleanValue() ? 1 : 0;
     }
 
-    protected BlockStateContainer createBlockState()
-    {
-        return new BlockStateContainer(this, new IProperty[] {WET});
+    protected BlockStateContainer createBlockState() {
+        return new BlockStateContainer(this, new IProperty[]{WET});
     }
 
     @SideOnly(Side.CLIENT)
-    public void randomDisplayTick(IBlockState stateIn, World worldIn, BlockPos pos, Random rand)
-    {
-        if (((Boolean)stateIn.getValue(WET)).booleanValue())
-        {
+    public void randomDisplayTick(IBlockState stateIn, World worldIn, BlockPos pos, Random rand) {
+        if (((Boolean) stateIn.getValue(WET)).booleanValue()) {
             EnumFacing enumfacing = EnumFacing.random(rand);
 
-            if (enumfacing != EnumFacing.UP && !worldIn.getBlockState(pos.offset(enumfacing)).isTopSolid())
-            {
-                double d0 = (double)pos.getX();
-                double d1 = (double)pos.getY();
-                double d2 = (double)pos.getZ();
+            if (enumfacing != EnumFacing.UP && !worldIn.getBlockState(pos.offset(enumfacing)).isTopSolid()) {
+                double d0 = (double) pos.getX();
+                double d1 = (double) pos.getY();
+                double d2 = (double) pos.getZ();
 
-                if (enumfacing == EnumFacing.DOWN)
-                {
+                if (enumfacing == EnumFacing.DOWN) {
                     d1 = d1 - 0.05D;
                     d0 += rand.nextDouble();
                     d2 += rand.nextDouble();
-                }
-                else
-                {
+                } else {
                     d1 = d1 + rand.nextDouble() * 0.8D;
 
-                    if (enumfacing.getAxis() == EnumFacing.Axis.X)
-                    {
+                    if (enumfacing.getAxis() == EnumFacing.Axis.X) {
                         d2 += rand.nextDouble();
 
-                        if (enumfacing == EnumFacing.EAST)
-                        {
+                        if (enumfacing == EnumFacing.EAST) {
                             ++d0;
-                        }
-                        else
-                        {
+                        } else {
                             d0 += 0.05D;
                         }
-                    }
-                    else
-                    {
+                    } else {
                         d0 += rand.nextDouble();
 
-                        if (enumfacing == EnumFacing.SOUTH)
-                        {
+                        if (enumfacing == EnumFacing.SOUTH) {
                             ++d2;
-                        }
-                        else
-                        {
+                        } else {
                             d2 += 0.05D;
                         }
                     }
