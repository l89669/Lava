--- ../src-base/minecraft/net/minecraft/item/Item.java
+++ ../src-work/minecraft/net/minecraft/item/Item.java
@@ -1,26 +1,8 @@
 package net.minecraft.item;
 
 import com.google.common.collect.HashMultimap;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.UUID;
-import javax.annotation.Nullable;
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockDirt;
-import net.minecraft.block.BlockDoublePlant;
-import net.minecraft.block.BlockFlower;
-import net.minecraft.block.BlockPlanks;
-import net.minecraft.block.BlockPrismarine;
-import net.minecraft.block.BlockRedSandstone;
-import net.minecraft.block.BlockSand;
-import net.minecraft.block.BlockSandStone;
-import net.minecraft.block.BlockSilverfish;
-import net.minecraft.block.BlockStone;
-import net.minecraft.block.BlockStoneBrick;
-import net.minecraft.block.BlockWall;
+import net.minecraft.block.*;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.util.ITooltipFlag;
 import net.minecraft.creativetab.CreativeTabs;
@@ -39,13 +21,7 @@
 import net.minecraft.inventory.EntityEquipmentSlot;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.potion.PotionEffect;
-import net.minecraft.util.ActionResult;
-import net.minecraft.util.EnumActionResult;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.EnumHand;
-import net.minecraft.util.EnumHandSide;
-import net.minecraft.util.NonNullList;
-import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.*;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.RayTraceResult;
@@ -58,40 +34,37 @@
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
 
-public class Item extends net.minecraftforge.registries.IForgeRegistryEntry.Impl<Item>
-{
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.UUID;
+
+public class Item extends net.minecraftforge.registries.IForgeRegistryEntry.Impl<Item> {
     public static final RegistryNamespaced<ResourceLocation, Item> REGISTRY = net.minecraftforge.registries.GameData.getWrapper(Item.class);
     private static final Map<Block, Item> BLOCK_TO_ITEM = net.minecraftforge.registries.GameData.getBlockItemMap();
-    private static final IItemPropertyGetter DAMAGED_GETTER = new IItemPropertyGetter()
-    {
+    private static final IItemPropertyGetter DAMAGED_GETTER = new IItemPropertyGetter() {
         @SideOnly(Side.CLIENT)
-        public float apply(ItemStack stack, @Nullable World worldIn, @Nullable EntityLivingBase entityIn)
-        {
+        public float apply(ItemStack stack, @Nullable World worldIn, @Nullable EntityLivingBase entityIn) {
             return stack.isItemDamaged() ? 1.0F : 0.0F;
         }
     };
-    private static final IItemPropertyGetter DAMAGE_GETTER = new IItemPropertyGetter()
-    {
+    private static final IItemPropertyGetter DAMAGE_GETTER = new IItemPropertyGetter() {
         @SideOnly(Side.CLIENT)
-        public float apply(ItemStack stack, @Nullable World worldIn, @Nullable EntityLivingBase entityIn)
-        {
-            return MathHelper.clamp((float)stack.getItemDamage() / (float)stack.getMaxDamage(), 0.0F, 1.0F);
+        public float apply(ItemStack stack, @Nullable World worldIn, @Nullable EntityLivingBase entityIn) {
+            return MathHelper.clamp((float) stack.getItemDamage() / (float) stack.getMaxDamage(), 0.0F, 1.0F);
         }
     };
-    private static final IItemPropertyGetter LEFTHANDED_GETTER = new IItemPropertyGetter()
-    {
+    private static final IItemPropertyGetter LEFTHANDED_GETTER = new IItemPropertyGetter() {
         @SideOnly(Side.CLIENT)
-        public float apply(ItemStack stack, @Nullable World worldIn, @Nullable EntityLivingBase entityIn)
-        {
+        public float apply(ItemStack stack, @Nullable World worldIn, @Nullable EntityLivingBase entityIn) {
             return entityIn != null && entityIn.getPrimaryHand() != EnumHandSide.RIGHT ? 1.0F : 0.0F;
         }
     };
-    private static final IItemPropertyGetter COOLDOWN_GETTER = new IItemPropertyGetter()
-    {
+    private static final IItemPropertyGetter COOLDOWN_GETTER = new IItemPropertyGetter() {
         @SideOnly(Side.CLIENT)
-        public float apply(ItemStack stack, @Nullable World worldIn, @Nullable EntityLivingBase entityIn)
-        {
-            return entityIn instanceof EntityPlayer ? ((EntityPlayer)entityIn).getCooldownTracker().getCooldown(stack.getItem(), 0.0F) : 0.0F;
+        public float apply(ItemStack stack, @Nullable World worldIn, @Nullable EntityLivingBase entityIn) {
+            return entityIn instanceof EntityPlayer ? ((EntityPlayer) entityIn).getCooldownTracker().getCooldown(stack.getItem(), 0.0F) : 0.0F;
         }
     };
     private final IRegistry<ResourceLocation, IItemPropertyGetter> properties = new RegistrySimple<ResourceLocation, IItemPropertyGetter>();
@@ -106,35 +79,27 @@
     private Item containerItem;
     private String unlocalizedName;
 
-    public static int getIdFromItem(Item itemIn)
-    {
+    public static int getIdFromItem(Item itemIn) {
         return itemIn == null ? 0 : REGISTRY.getIDForObject(itemIn);
     }
 
-    public static Item getItemById(int id)
-    {
+    public static Item getItemById(int id) {
         return REGISTRY.getObjectById(id);
     }
 
-    public static Item getItemFromBlock(Block blockIn)
-    {
+    public static Item getItemFromBlock(Block blockIn) {
         Item item = BLOCK_TO_ITEM.get(blockIn);
         return item == null ? Items.AIR : item;
     }
 
     @Nullable
-    public static Item getByNameOrId(String id)
-    {
+    public static Item getByNameOrId(String id) {
         Item item = REGISTRY.getObject(new ResourceLocation(id));
 
-        if (item == null)
-        {
-            try
-            {
+        if (item == null) {
+            try {
                 return getItemById(Integer.parseInt(id));
-            }
-            catch (NumberFormatException var3)
-            {
+            } catch (NumberFormatException var3) {
                 ;
             }
         }
@@ -142,95 +107,78 @@
         return item;
     }
 
-    public final void addPropertyOverride(ResourceLocation key, IItemPropertyGetter getter)
-    {
+    public final void addPropertyOverride(ResourceLocation key, IItemPropertyGetter getter) {
         this.properties.putObject(key, getter);
     }
 
     @Nullable
     @SideOnly(Side.CLIENT)
-    public IItemPropertyGetter getPropertyGetter(ResourceLocation key)
-    {
+    public IItemPropertyGetter getPropertyGetter(ResourceLocation key) {
         return this.properties.getObject(key);
     }
 
-    public boolean updateItemStackNBT(NBTTagCompound nbt)
-    {
+    public boolean updateItemStackNBT(NBTTagCompound nbt) {
         return false;
     }
 
     @SideOnly(Side.CLIENT)
-    public boolean hasCustomProperties()
-    {
+    public boolean hasCustomProperties() {
         return !this.properties.getKeys().isEmpty();
     }
 
-    public Item()
-    {
+    public Item() {
         this.addPropertyOverride(new ResourceLocation("lefthanded"), LEFTHANDED_GETTER);
         this.addPropertyOverride(new ResourceLocation("cooldown"), COOLDOWN_GETTER);
     }
 
-    public Item setMaxStackSize(int maxStackSize)
-    {
+    public Item setMaxStackSize(int maxStackSize) {
         this.maxStackSize = maxStackSize;
         return this;
     }
 
-    public EnumActionResult onItemUse(EntityPlayer player, World worldIn, BlockPos pos, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ)
-    {
+    public EnumActionResult onItemUse(EntityPlayer player, World worldIn, BlockPos pos, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ) {
         return EnumActionResult.PASS;
     }
 
-    public float getDestroySpeed(ItemStack stack, IBlockState state)
-    {
+    public float getDestroySpeed(ItemStack stack, IBlockState state) {
         return 1.0F;
     }
 
-    public ActionResult<ItemStack> onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn)
-    {
+    public ActionResult<ItemStack> onItemRightClick(World worldIn, EntityPlayer playerIn, EnumHand handIn) {
         return new ActionResult<ItemStack>(EnumActionResult.PASS, playerIn.getHeldItem(handIn));
     }
 
-    public ItemStack onItemUseFinish(ItemStack stack, World worldIn, EntityLivingBase entityLiving)
-    {
+    public ItemStack onItemUseFinish(ItemStack stack, World worldIn, EntityLivingBase entityLiving) {
         return stack;
     }
 
     @Deprecated // Use ItemStack sensitive version below.
-    public int getItemStackLimit()
-    {
+    public int getItemStackLimit() {
         return this.maxStackSize;
     }
 
-    public int getMetadata(int damage)
-    {
+    public int getMetadata(int damage) {
         return 0;
     }
 
-    public boolean getHasSubtypes()
-    {
+    public boolean getHasSubtypes() {
         return this.hasSubtypes;
     }
 
-    public Item setHasSubtypes(boolean hasSubtypes)
-    {
+    public Item setHasSubtypes(boolean hasSubtypes) {
         this.hasSubtypes = hasSubtypes;
         return this;
     }
 
     @Deprecated
-    public int getMaxDamage()
-    {
+    public int getMaxDamage() {
         return this.maxDamage;
     }
 
-    public Item setMaxDamage(int maxDamageIn)
-    {
+    public Item setMaxDamage(int maxDamageIn) {
         this.maxDamage = maxDamageIn;
 
-        if (maxDamageIn > 0)
-        {
+        if (maxDamageIn > 0) {
             this.addPropertyOverride(new ResourceLocation("damaged"), DAMAGED_GETTER);
             this.addPropertyOverride(new ResourceLocation("damage"), DAMAGE_GETTER);
         }
@@ -238,181 +186,149 @@
         return this;
     }
 
-    public boolean isDamageable()
-    {
+    public boolean isDamageable() {
         return this.maxDamage > 0 && (!this.hasSubtypes || this.maxStackSize == 1);
     }
 
-    public boolean hitEntity(ItemStack stack, EntityLivingBase target, EntityLivingBase attacker)
-    {
+    public boolean hitEntity(ItemStack stack, EntityLivingBase target, EntityLivingBase attacker) {
         return false;
     }
 
-    public boolean onBlockDestroyed(ItemStack stack, World worldIn, IBlockState state, BlockPos pos, EntityLivingBase entityLiving)
-    {
+    public boolean onBlockDestroyed(ItemStack stack, World worldIn, IBlockState state, BlockPos pos, EntityLivingBase entityLiving) {
         return false;
     }
 
-    public boolean canHarvestBlock(IBlockState blockIn)
-    {
+    public boolean canHarvestBlock(IBlockState blockIn) {
         return false;
     }
 
-    public boolean itemInteractionForEntity(ItemStack stack, EntityPlayer playerIn, EntityLivingBase target, EnumHand hand)
-    {
+    public boolean itemInteractionForEntity(ItemStack stack, EntityPlayer playerIn, EntityLivingBase target, EnumHand hand) {
         return false;
     }
 
-    public Item setFull3D()
-    {
+    public Item setFull3D() {
         this.bFull3D = true;
         return this;
     }
 
     @SideOnly(Side.CLIENT)
-    public boolean isFull3D()
-    {
+    public boolean isFull3D() {
         return this.bFull3D;
     }
 
     @SideOnly(Side.CLIENT)
-    public boolean shouldRotateAroundWhenRendering()
-    {
+    public boolean shouldRotateAroundWhenRendering() {
         return false;
     }
 
-    public Item setUnlocalizedName(String unlocalizedName)
-    {
+    public Item setUnlocalizedName(String unlocalizedName) {
         this.unlocalizedName = unlocalizedName;
         return this;
     }
 
-    public String getUnlocalizedNameInefficiently(ItemStack stack)
-    {
+    public String getUnlocalizedNameInefficiently(ItemStack stack) {
         return I18n.translateToLocal(this.getUnlocalizedName(stack));
     }
 
-    public String getUnlocalizedName()
-    {
+    public String getUnlocalizedName() {
         return "item." + this.unlocalizedName;
     }
 
-    public String getUnlocalizedName(ItemStack stack)
-    {
+    public String getUnlocalizedName(ItemStack stack) {
         return "item." + this.unlocalizedName;
     }
 
-    public Item setContainerItem(Item containerItem)
-    {
+    public Item setContainerItem(Item containerItem) {
         this.containerItem = containerItem;
         return this;
     }
 
-    public boolean getShareTag()
-    {
+    public boolean getShareTag() {
         return true;
     }
 
     @Nullable
-    public Item getContainerItem()
-    {
+    public Item getContainerItem() {
         return this.containerItem;
     }
 
     @Deprecated // Use ItemStack sensitive version below.
-    public boolean hasContainerItem()
-    {
+    public boolean hasContainerItem() {
         return this.containerItem != null;
     }
 
-    public void onUpdate(ItemStack stack, World worldIn, Entity entityIn, int itemSlot, boolean isSelected)
-    {
+    public void onUpdate(ItemStack stack, World worldIn, Entity entityIn, int itemSlot, boolean isSelected) {
     }
 
-    public void onCreated(ItemStack stack, World worldIn, EntityPlayer playerIn)
-    {
+    public void onCreated(ItemStack stack, World worldIn, EntityPlayer playerIn) {
     }
 
-    public boolean isMap()
-    {
+    public boolean isMap() {
         return false;
     }
 
-    public EnumAction getItemUseAction(ItemStack stack)
-    {
+    public EnumAction getItemUseAction(ItemStack stack) {
         return EnumAction.NONE;
     }
 
-    public int getMaxItemUseDuration(ItemStack stack)
-    {
+    public int getMaxItemUseDuration(ItemStack stack) {
         return 0;
     }
 
-    public void onPlayerStoppedUsing(ItemStack stack, World worldIn, EntityLivingBase entityLiving, int timeLeft)
-    {
+    public void onPlayerStoppedUsing(ItemStack stack, World worldIn, EntityLivingBase entityLiving, int timeLeft) {
     }
 
     @SideOnly(Side.CLIENT)
-    public void addInformation(ItemStack stack, @Nullable World worldIn, List<String> tooltip, ITooltipFlag flagIn)
-    {
+    public void addInformation(ItemStack stack, @Nullable World worldIn, List<String> tooltip, ITooltipFlag flagIn) {
     }
 
-    public String getItemStackDisplayName(ItemStack stack)
-    {
+    public String getItemStackDisplayName(ItemStack stack) {
         return I18n.translateToLocal(this.getUnlocalizedNameInefficiently(stack) + ".name").trim();
     }
 
     @SideOnly(Side.CLIENT)
-    public boolean hasEffect(ItemStack stack)
-    {
+    public boolean hasEffect(ItemStack stack) {
         return stack.isItemEnchanted();
     }
 
     @Deprecated // use Forge version
-    public EnumRarity getRarity(ItemStack stack)
-    {
+    public EnumRarity getRarity(ItemStack stack) {
         return stack.isItemEnchanted() ? EnumRarity.RARE : EnumRarity.COMMON;
     }
 
-    public boolean isEnchantable(ItemStack stack)
-    {
+    public boolean isEnchantable(ItemStack stack) {
         return this.getItemStackLimit(stack) == 1 && this.isDamageable();
     }
 
-    protected RayTraceResult rayTrace(World worldIn, EntityPlayer playerIn, boolean useLiquids)
-    {
+    protected RayTraceResult rayTrace(World worldIn, EntityPlayer playerIn, boolean useLiquids) {
         float f = playerIn.rotationPitch;
         float f1 = playerIn.rotationYaw;
         double d0 = playerIn.posX;
-        double d1 = playerIn.posY + (double)playerIn.getEyeHeight();
+        double d1 = playerIn.posY + (double) playerIn.getEyeHeight();
         double d2 = playerIn.posZ;
         Vec3d vec3d = new Vec3d(d0, d1, d2);
-        float f2 = MathHelper.cos(-f1 * 0.017453292F - (float)Math.PI);
-        float f3 = MathHelper.sin(-f1 * 0.017453292F - (float)Math.PI);
+        float f2 = MathHelper.cos(-f1 * 0.017453292F - (float) Math.PI);
+        float f3 = MathHelper.sin(-f1 * 0.017453292F - (float) Math.PI);
         float f4 = -MathHelper.cos(-f * 0.017453292F);
         float f5 = MathHelper.sin(-f * 0.017453292F);
         float f6 = f3 * f4;
         float f7 = f2 * f4;
         double d3 = playerIn.getEntityAttribute(EntityPlayer.REACH_DISTANCE).getAttributeValue();
-        Vec3d vec3d1 = vec3d.addVector((double)f6 * d3, (double)f5 * d3, (double)f7 * d3);
+        Vec3d vec3d1 = vec3d.addVector((double) f6 * d3, (double) f5 * d3, (double) f7 * d3);
         return worldIn.rayTraceBlocks(vec3d, vec3d1, useLiquids, !useLiquids, false);
     }
 
-    public int getItemEnchantability()
-    {
+    public int getItemEnchantability() {
         return 0;
     }
 
-    public void getSubItems(CreativeTabs tab, NonNullList<ItemStack> items)
-    {
-        if (this.isInCreativeTab(tab))
-        {
+    public void getSubItems(CreativeTabs tab, NonNullList<ItemStack> items) {
+        if (this.isInCreativeTab(tab)) {
             items.add(new ItemStack(this));
         }
     }
 
-    protected boolean isInCreativeTab(CreativeTabs targetTab)
-    {
+    protected boolean isInCreativeTab(CreativeTabs targetTab) {
         for (CreativeTabs tab : this.getCreativeTabs())
             if (tab == targetTab)
                 return true;
@@ -421,39 +337,34 @@
     }
 
     @Nullable
-    public CreativeTabs getCreativeTab()
-    {
+    public CreativeTabs getCreativeTab() {
         return this.tabToDisplayOn;
     }
 
-    public Item setCreativeTab(CreativeTabs tab)
-    {
+    public Item setCreativeTab(CreativeTabs tab) {
         this.tabToDisplayOn = tab;
         return this;
     }
 
-    public boolean canItemEditBlocks()
-    {
+    public boolean canItemEditBlocks() {
         return false;
     }
 
-    public boolean getIsRepairable(ItemStack toRepair, ItemStack repair)
-    {
+    public boolean getIsRepairable(ItemStack toRepair, ItemStack repair) {
         return false;
     }
 
     @Deprecated // Use ItemStack sensitive version below.
-    public Multimap<String, AttributeModifier> getItemAttributeModifiers(EntityEquipmentSlot equipmentSlot)
-    {
+    public Multimap<String, AttributeModifier> getItemAttributeModifiers(EntityEquipmentSlot equipmentSlot) {
         return HashMultimap.<String, AttributeModifier>create();
     }
 
     /* ======================================== FORGE START =====================================*/
+
     /**
      * ItemStack sensitive version of getItemAttributeModifiers
      */
-    public Multimap<String, AttributeModifier> getAttributeModifiers(EntityEquipmentSlot slot, ItemStack stack)
-    {
+    public Multimap<String, AttributeModifier> getAttributeModifiers(EntityEquipmentSlot slot, ItemStack stack) {
         return this.getItemAttributeModifiers(slot);
     }
 
@@ -464,10 +375,9 @@
      * in the world
      *
      * @param player The player that dropped the item
-     * @param item The item stack, before the item is removed.
+     * @param item   The item stack, before the item is removed.
      */
-    public boolean onDroppedByPlayer(ItemStack item, EntityPlayer player)
-    {
+    public boolean onDroppedByPlayer(ItemStack item, EntityPlayer player) {
         return true;
     }
 
@@ -476,45 +386,45 @@
      * tool highlight useful for adding something extra that can't be removed
      * by a user in the displayed name, such as a mode of operation.
      *
-     * @param item the ItemStack for the item.
+     * @param item        the ItemStack for the item.
      * @param displayName the name that will be displayed unless it is changed in this method.
      */
-    public String getHighlightTip( ItemStack item, String displayName )
-    {
+    public String getHighlightTip(ItemStack item, String displayName) {
         return displayName;
     }
 
     /**
      * This is called when the item is used, before the block is activated.
-     * @param stack The Item Stack
+     *
+     * @param stack  The Item Stack
      * @param player The Player that used the item
-     * @param world The Current World
-     * @param pos Target position
-     * @param side The side of the target hit
-     * @param hand Which hand the item is being held in.
+     * @param world  The Current World
+     * @param pos    Target position
+     * @param side   The side of the target hit
+     * @param hand   Which hand the item is being held in.
      * @return Return PASS to allow vanilla handling, any other to skip normal code.
      */
-    public EnumActionResult onItemUseFirst(EntityPlayer player, World world, BlockPos pos, EnumFacing side, float hitX, float hitY, float hitZ, EnumHand hand)
-    {
+    public EnumActionResult onItemUseFirst(EntityPlayer player, World world, BlockPos pos, EnumFacing side, float hitX, float hitY, float hitZ, EnumHand hand) {
         return EnumActionResult.PASS;
     }
 
     protected boolean canRepair = true;
+
     /**
      * Called by CraftingManager to determine if an item is reparable.
+     *
      * @return True if reparable
      */
-    public boolean isRepairable()
-    {
+    public boolean isRepairable() {
         return canRepair && isDamageable();
     }
 
     /**
      * Call to disable repair recipes.
+     *
      * @return The current Item instance
      */
-    public Item setNoRepair()
-    {
+    public Item setNoRepair() {
         canRepair = false;
         return this;
     }
@@ -523,15 +433,14 @@
      * Determines the amount of durability the mending enchantment
      * will repair, on average, per point of experience.
      */
-    public float getXpRepairRatio(ItemStack stack)
-    {
+    public float getXpRepairRatio(ItemStack stack) {
         return 2f;
     }
 
     /**
      * Override this method to change the NBT data being sent to the client.
      * You should ONLY override this when you have no other choice, as this might change behavior client side!
-     *
+     * <p>
      * Note that this will sometimes be applied multiple times, the following MUST be supported:
      * Item item = stack.getItem();
      * NBTTagCompound nbtShare1 = item.getNBTShareTag(stack);
@@ -543,45 +452,42 @@
      * @return The NBT tag
      */
     @Nullable
-    public NBTTagCompound getNBTShareTag(ItemStack stack)
-    {
+    public NBTTagCompound getNBTShareTag(ItemStack stack) {
         return stack.getTagCompound();
     }
 
     /**
      * Override this method to decide what to do with the NBT data received from getNBTShareTag().
-     * 
+     *
      * @param stack The stack that received NBT
-     * @param nbt Received NBT, can be null
+     * @param nbt   Received NBT, can be null
      */
-    public void readNBTShareTag(ItemStack stack, @Nullable NBTTagCompound nbt)
-    {
+    public void readNBTShareTag(ItemStack stack, @Nullable NBTTagCompound nbt) {
         stack.setTagCompound(nbt);
     }
 
     /**
      * Called before a block is broken.  Return true to prevent default block harvesting.
-     *
+     * <p>
      * Note: In SMP, this is called on both client and server sides!
      *
      * @param itemstack The current ItemStack
-     * @param pos Block's position in world
-     * @param player The Player that is wielding the item
+     * @param pos       Block's position in world
+     * @param player    The Player that is wielding the item
      * @return True to prevent harvesting, false to continue as normal
      */
-    public boolean onBlockStartBreak(ItemStack itemstack, BlockPos pos, EntityPlayer player)
-    {
+    public boolean onBlockStartBreak(ItemStack itemstack, BlockPos pos, EntityPlayer player) {
         return false;
     }
 
     /**
      * Called each tick while using an item.
-     * @param stack The Item being used
+     *
+     * @param stack  The Item being used
      * @param player The Player using the item
-     * @param count The amount of time in tick the item has been used for continuously
+     * @param count  The amount of time in tick the item has been used for continuously
      */
-    public void onUsingTick(ItemStack stack, EntityLivingBase player, int count)
-    {
+    public void onUsingTick(ItemStack stack, EntityLivingBase player, int count) {
     }
 
     /**
@@ -589,13 +495,12 @@
      * Processed before damage is done, if return value is true further processing is canceled
      * and the entity is not attacked.
      *
-     * @param stack The Item being used
+     * @param stack  The Item being used
      * @param player The player that is attacking
      * @param entity The entity being attacked
      * @return True to cancel the rest of the interaction.
      */
-    public boolean onLeftClickEntity(ItemStack stack, EntityPlayer player, Entity entity)
-    {
+    public boolean onLeftClickEntity(ItemStack stack, EntityPlayer player, Entity entity) {
         return false;
     }
 
@@ -606,10 +511,8 @@
      * @param itemStack The current ItemStack
      * @return The resulting ItemStack
      */
-    public ItemStack getContainerItem(ItemStack itemStack)
-    {
-        if (!hasContainerItem(itemStack))
-        {
+    public ItemStack getContainerItem(ItemStack itemStack) {
+        if (!hasContainerItem(itemStack)) {
             return ItemStack.EMPTY;
         }
         return new ItemStack(getContainerItem());
@@ -617,11 +520,11 @@
 
     /**
      * ItemStack sensitive version of hasContainerItem
+     *
      * @param stack The current item stack
      * @return True if this item has a 'container'
      */
-    public boolean hasContainerItem(ItemStack stack)
-    {
+    public boolean hasContainerItem(ItemStack stack) {
         return hasContainerItem();
     }
 
@@ -630,12 +533,11 @@
      * This is in ticks, standard result is 6000, or 5 mins.
      *
      * @param itemStack The current ItemStack
-     * @param world The world the entity is in
+     * @param world     The world the entity is in
      * @return The normal lifespan in ticks.
      */
-    public int getEntityLifespan(ItemStack itemStack, World world)
-    {
-        return 6000;
+    public int getEntityLifespan(ItemStack itemStack, World world) {
+        return world.spigotConfig.itemDespawnRate;
     }
 
     /**
@@ -646,8 +548,7 @@
      * @param stack The current item stack
      * @return True of the item has a custom entity, If true, Item#createCustomEntity will be called
      */
-    public boolean hasCustomEntity(ItemStack stack)
-    {
+    public boolean hasCustomEntity(ItemStack stack) {
         return false;
     }
 
@@ -656,14 +557,13 @@
      * Returning null here will not kill the EntityItem and will leave it to function normally.
      * Called when the item it placed in a world.
      *
-     * @param world The world object
-     * @param location The EntityItem object, useful for getting the position of the entity
+     * @param world     The world object
+     * @param location  The EntityItem object, useful for getting the position of the entity
      * @param itemstack The current item stack
      * @return A new Entity object to spawn or null
      */
     @Nullable
-    public Entity createEntity(World world, Entity location, ItemStack itemstack)
-    {
+    public Entity createEntity(World world, Entity location, ItemStack itemstack) {
         return null;
     }
 
@@ -674,8 +574,7 @@
      * @param entityItem The entity Item
      * @return Return true to skip any further update code.
      */
-    public boolean onEntityItemUpdate(net.minecraft.entity.item.EntityItem entityItem)
-    {
+    public boolean onEntityItemUpdate(net.minecraft.entity.item.EntityItem entityItem) {
         return false;
     }
 
@@ -686,9 +585,8 @@
      *
      * @return A list of all tabs that this item could possibly be one.
      */
-    public CreativeTabs[] getCreativeTabs()
-    {
-        return new CreativeTabs[]{ getCreativeTab() };
+    public CreativeTabs[] getCreativeTabs() {
+        return new CreativeTabs[]{getCreativeTab()};
     }
 
     /**
@@ -699,42 +597,39 @@
      * @param item The item stack the player is picking up.
      * @return The amount to award for each item.
      */
-    public float getSmeltingExperience(ItemStack item)
-    {
+    public float getSmeltingExperience(ItemStack item) {
         return -1; //-1 will default to the old lookups.
     }
 
     /**
-     *
      * Should this item, when held, allow sneak-clicks to pass through to the underlying block?
      *
-     * @param world The world
-     * @param pos Block position in world
+     * @param world  The world
+     * @param pos    Block position in world
      * @param player The Player that is wielding the item
      * @return
      */
-    public boolean doesSneakBypassUse(ItemStack stack, net.minecraft.world.IBlockAccess world, BlockPos pos, EntityPlayer player)
-    {
+    public boolean doesSneakBypassUse(ItemStack stack, net.minecraft.world.IBlockAccess world, BlockPos pos, EntityPlayer player) {
         return false;
     }
 
     /**
      * Called to tick armor in the armor slot. Override to do something
      */
-    public void onArmorTick(World world, EntityPlayer player, ItemStack itemStack){}
+    public void onArmorTick(World world, EntityPlayer player, ItemStack itemStack) {
+    }
 
     /**
      * Determines if the specific ItemStack can be placed in the specified armor slot, for the entity.
-     *
+     * <p>
      * TODO: Change name to canEquip in 1.13?
      *
-     * @param stack The ItemStack
+     * @param stack     The ItemStack
      * @param armorType Armor slot to be verified.
-     * @param entity The entity trying to equip the armor
+     * @param entity    The entity trying to equip the armor
      * @return True if the given ItemStack can be inserted in the slot
      */
-    public boolean isValidArmor(ItemStack stack, EntityEquipmentSlot armorType, Entity entity)
-    {
+    public boolean isValidArmor(ItemStack stack, EntityEquipmentSlot armorType, Entity entity) {
         return net.minecraft.entity.EntityLiving.getSlotForItemStack(stack) == armorType;
     }
 
@@ -748,8 +643,7 @@
      * vanilla logic as per {@code EntityLiving.getSlotForItemStack(stack)} decide
      */
     @Nullable
-    public EntityEquipmentSlot getEquipmentSlot(ItemStack stack)
-    {
+    public EntityEquipmentSlot getEquipmentSlot(ItemStack stack) {
         return null;
     }
 
@@ -757,11 +651,10 @@
      * Allow or forbid the specific book/item combination as an anvil enchant
      *
      * @param stack The item
-     * @param book The book
+     * @param book  The book
      * @return if the enchantment is allowed
      */
-    public boolean isBookEnchantable(ItemStack stack, ItemStack book)
-    {
+    public boolean isBookEnchantable(ItemStack stack, ItemStack book) {
         return true;
     }
 
@@ -769,18 +662,17 @@
      * Called by RenderBiped and RenderPlayer to determine the armor texture that
      * should be use for the currently equipped item.
      * This will only be called on instances of ItemArmor.
-     *
+     * <p>
      * Returning null from this function will use the default value.
      *
-     * @param stack ItemStack for the equipped armor
+     * @param stack  ItemStack for the equipped armor
      * @param entity The entity wearing the armor
-     * @param slot The slot the armor is in
-     * @param type The subtype, can be null or "overlay"
+     * @param slot   The slot the armor is in
+     * @param type   The subtype, can be null or "overlay"
      * @return Path of texture to bind, or null to use default
      */
     @Nullable
-    public String getArmorTexture(ItemStack stack, Entity entity, EntityEquipmentSlot slot, String type)
-    {
+    public String getArmorTexture(ItemStack stack, Entity entity, EntityEquipmentSlot slot, String type) {
         return null;
     }
 
@@ -793,24 +685,22 @@
      */
     @SideOnly(Side.CLIENT)
     @Nullable
-    public net.minecraft.client.gui.FontRenderer getFontRenderer(ItemStack stack)
-    {
+    public net.minecraft.client.gui.FontRenderer getFontRenderer(ItemStack stack) {
         return null;
     }
 
     /**
      * Override this method to have an item handle its own armor rendering.
      *
-     * @param  entityLiving  The entity wearing the armor
-     * @param  itemStack  The itemStack to render the model of
-     * @param  armorSlot  The slot the armor is in
-     * @param _default Original armor model. Will have attributes set.
-     * @return  A ModelBiped to render instead of the default
+     * @param entityLiving The entity wearing the armor
+     * @param itemStack    The itemStack to render the model of
+     * @param armorSlot    The slot the armor is in
+     * @param _default     Original armor model. Will have attributes set.
+     * @return A ModelBiped to render instead of the default
      */
     @SideOnly(Side.CLIENT)
     @Nullable
-    public net.minecraft.client.model.ModelBiped getArmorModel(EntityLivingBase entityLiving, ItemStack itemStack, EntityEquipmentSlot armorSlot, net.minecraft.client.model.ModelBiped _default)
-    {
+    public net.minecraft.client.model.ModelBiped getArmorModel(EntityLivingBase entityLiving, ItemStack itemStack, EntityEquipmentSlot armorSlot, net.minecraft.client.model.ModelBiped _default) {
         return null;
     }
 
@@ -818,11 +708,10 @@
      * Called when a entity tries to play the 'swing' animation.
      *
      * @param entityLiving The entity swinging the item.
-     * @param stack The Item stack
+     * @param stack        The Item stack
      * @return True to cancel any further processing by EntityLiving
      */
-    public boolean onEntitySwing(EntityLivingBase entityLiving, ItemStack stack)
-    {
+    public boolean onEntitySwing(EntityLivingBase entityLiving, ItemStack stack) {
         return false;
     }
 
@@ -830,13 +719,14 @@
      * Called when the client starts rendering the HUD, for whatever item the player currently has as a helmet.
      * This is where pumpkins would render there overlay.
      *
-     * @param stack The ItemStack that is equipped
-     * @param player Reference to the current client entity
-     * @param resolution Resolution information about the current viewport and configured GUI Scale
+     * @param stack        The ItemStack that is equipped
+     * @param player       Reference to the current client entity
+     * @param resolution   Resolution information about the current viewport and configured GUI Scale
      * @param partialTicks Partial ticks for the renderer, useful for interpolation
      */
     @SideOnly(Side.CLIENT)
-    public void renderHelmetOverlay(ItemStack stack, EntityPlayer player, net.minecraft.client.gui.ScaledResolution resolution, float partialTicks){}
+    public void renderHelmetOverlay(ItemStack stack, EntityPlayer player, net.minecraft.client.gui.ScaledResolution resolution, float partialTicks) {
+    }
 
     /**
      * Return the itemDamage represented by this ItemStack. Defaults to the itemDamage field on ItemStack, but can be overridden here for other sources such as NBT.
@@ -844,18 +734,17 @@
      * @param stack The itemstack that is damaged
      * @return the damage value
      */
-    public int getDamage(ItemStack stack)
-    {
+    public int getDamage(ItemStack stack) {
         return stack.itemDamage;
     }
 
     /**
      * This used to be 'display damage' but its really just 'aux' data in the ItemStack, usually shares the same variable as damage.
+     *
      * @param stack
      * @return
      */
-    public int getMetadata(ItemStack stack)
-    {
+    public int getMetadata(ItemStack stack) {
         return stack.itemDamage;
     }
 
@@ -867,8 +756,7 @@
      * @param stack The current Item Stack
      * @return True if it should render the 'durability' bar.
      */
-    public boolean showDurabilityBar(ItemStack stack)
-    {
+    public boolean showDurabilityBar(ItemStack stack) {
         return stack.isItemDamaged();
     }
 
@@ -878,9 +766,8 @@
      * @param stack The current ItemStack
      * @return 0.0 for 100% (no damage / full bar), 1.0 for 0% (fully damaged / empty bar)
      */
-    public double getDurabilityForDisplay(ItemStack stack)
-    {
-        return (double)stack.getItemDamage() / (double)stack.getMaxDamage();
+    public double getDurabilityForDisplay(ItemStack stack) {
+        return (double) stack.getItemDamage() / (double) stack.getMaxDamage();
     }
 
     /**
@@ -890,10 +777,10 @@
      * @param stack Stack to get durability from
      * @return A packed RGB value for the durability colour (0x00RRGGBB)
      */
-    public int getRGBDurabilityForDisplay(ItemStack stack)
-    {
+    public int getRGBDurabilityForDisplay(ItemStack stack) {
         return MathHelper.hsvToRGB(Math.max(0.0F, (float) (1.0F - getDurabilityForDisplay(stack))) / 3.0F, 1.0F, 1.0F);
     }
+
     /**
      * Return the maxDamage for this ItemStack. Defaults to the maxDamage field in this item,
      * but can be overridden here for other sources such as NBT.
@@ -901,32 +788,30 @@
      * @param stack The itemstack that is damaged
      * @return the damage value
      */
-    public int getMaxDamage(ItemStack stack)
-    {
+    public int getMaxDamage(ItemStack stack) {
         return getMaxDamage();
     }
 
     /**
      * Return if this itemstack is damaged. Note only called if {@link #isDamageable()} is true.
+     *
      * @param stack the stack
      * @return if the stack is damaged
      */
-    public boolean isDamaged(ItemStack stack)
-    {
+    public boolean isDamaged(ItemStack stack) {
         return stack.itemDamage > 0;
     }
 
     /**
      * Set the damage for this itemstack. Note, this method is responsible for zero checking.
-     * @param stack the stack
+     *
+     * @param stack  the stack
      * @param damage the new damage value
      */
-    public void setDamage(ItemStack stack, int damage)
-    {
+    public void setDamage(ItemStack stack, int damage) {
         stack.itemDamage = damage;
 
-        if (stack.itemDamage < 0)
-        {
+        if (stack.itemDamage < 0) {
             stack.itemDamage = 0;
         }
     }
@@ -936,21 +821,21 @@
      * when a creative player left-clicks a block with this item.
      * Also checked from {@link net.minecraftforge.common.ForgeHooks#onBlockBreakEvent(World, GameType, EntityPlayerMP, BlockPos)  ForgeHooks.onBlockBreakEvent()}
      * to prevent sending an event.
+     *
      * @return true if the given player can destroy specified block in creative mode with this item
      */
-    public boolean canDestroyBlockInCreative(World world, BlockPos pos, ItemStack stack, EntityPlayer player)
-    {
+    public boolean canDestroyBlockInCreative(World world, BlockPos pos, ItemStack stack, EntityPlayer player) {
         return !(this instanceof ItemSword);
     }
 
     /**
      * ItemStack sensitive version of {@link #canHarvestBlock(IBlockState)}
+     *
      * @param state The block trying to harvest
      * @param stack The itemstack used to harvest the block
      * @return true if can harvest the block
      */
-    public boolean canHarvestBlock(IBlockState state, ItemStack stack)
-    {
+    public boolean canHarvestBlock(IBlockState state, ItemStack stack) {
         return canHarvestBlock(state);
     }
 
@@ -961,33 +846,31 @@
      * @param stack The ItemStack
      * @return The maximum number this item can be stacked to
      */
-    public int getItemStackLimit(ItemStack stack)
-    {
+    public int getItemStackLimit(ItemStack stack) {
         return this.getItemStackLimit();
     }
 
     private java.util.Map<String, Integer> toolClasses = new java.util.HashMap<String, Integer>();
+
     /**
      * Sets or removes the harvest level for the specified tool class.
      *
      * @param toolClass Class
-     * @param level Harvest level:
-     *     Wood:    0
-     *     Stone:   1
-     *     Iron:    2
-     *     Diamond: 3
-     *     Gold:    0
+     * @param level     Harvest level:
+     *                  Wood:    0
+     *                  Stone:   1
+     *                  Iron:    2
+     *                  Diamond: 3
+     *                  Gold:    0
      */
-    public void setHarvestLevel(String toolClass, int level)
-    {
+    public void setHarvestLevel(String toolClass, int level) {
         if (level < 0)
             toolClasses.remove(toolClass);
         else
             toolClasses.put(toolClass, level);
     }
 
-    public java.util.Set<String> getToolClasses(ItemStack stack)
-    {
+    public java.util.Set<String> getToolClasses(ItemStack stack) {
         return toolClasses.keySet();
     }
 
@@ -995,14 +878,13 @@
      * Queries the harvest level of this item stack for the specified tool class,
      * Returns -1 if this tool is not of the specified type
      *
-     * @param stack This item stack instance
-     * @param toolClass Tool Class
-     * @param player The player trying to harvest the given blockstate
+     * @param stack      This item stack instance
+     * @param toolClass  Tool Class
+     * @param player     The player trying to harvest the given blockstate
      * @param blockState The block to harvest
      * @return Harvest level, or -1 if not the specified tool type.
      */
-    public int getHarvestLevel(ItemStack stack, String toolClass, @Nullable EntityPlayer player, @Nullable IBlockState blockState)
-    {
+    public int getHarvestLevel(ItemStack stack, String toolClass, @Nullable EntityPlayer player, @Nullable IBlockState blockState) {
         Integer ret = toolClasses.get(toolClass);
         return ret == null ? -1 : ret;
     }
@@ -1013,8 +895,7 @@
      * @param stack The ItemStack
      * @return the item echantability value
      */
-    public int getItemEnchantability(ItemStack stack)
-    {
+    public int getItemEnchantability(ItemStack stack) {
         return getItemEnchantability();
     }
 
@@ -1022,48 +903,48 @@
      * Checks whether an item can be enchanted with a certain enchantment. This applies specifically to enchanting an item in the enchanting table and is called when retrieving the list of possible enchantments for an item.
      * Enchantments may additionally (or exclusively) be doing their own checks in {@link net.minecraft.enchantment.Enchantment#canApplyAtEnchantingTable(ItemStack)}; check the individual implementation for reference.
      * By default this will check if the enchantment type is valid for this item type.
-     * @param stack the item stack to be enchanted
+     *
+     * @param stack       the item stack to be enchanted
      * @param enchantment the enchantment to be applied
      * @return true if the enchantment can be applied to this item
      */
-    public boolean canApplyAtEnchantingTable(ItemStack stack, net.minecraft.enchantment.Enchantment enchantment)
-    {
+    public boolean canApplyAtEnchantingTable(ItemStack stack, net.minecraft.enchantment.Enchantment enchantment) {
         return enchantment.type.canEnchantItem(stack.getItem());
     }
 
     /**
      * Whether this Item can be used as a payment to activate the vanilla beacon.
+     *
      * @param stack the ItemStack
      * @return true if this Item can be used
      */
-    public boolean isBeaconPayment(ItemStack stack)
-    {
+    public boolean isBeaconPayment(ItemStack stack) {
         return this == Items.EMERALD || this == Items.DIAMOND || this == Items.GOLD_INGOT || this == Items.IRON_INGOT;
     }
 
     /**
      * Determine if the player switching between these two item stacks
-     * @param oldStack The old stack that was equipped
-     * @param newStack The new stack
+     *
+     * @param oldStack    The old stack that was equipped
+     * @param newStack    The new stack
      * @param slotChanged If the current equipped slot was changed,
      *                    Vanilla does not play the animation if you switch between two
      *                    slots that hold the exact same item.
      * @return True to play the item change animation
      */
-    public boolean shouldCauseReequipAnimation(ItemStack oldStack, ItemStack newStack, boolean slotChanged)
-    {
+    public boolean shouldCauseReequipAnimation(ItemStack oldStack, ItemStack newStack, boolean slotChanged) {
         return !oldStack.equals(newStack); //!ItemStack.areItemStacksEqual(oldStack, newStack);
     }
 
     /**
      * Called when the player is mining a block and the item in his hand changes.
      * Allows to not reset blockbreaking if only NBT or similar changes.
+     *
      * @param oldStack The old stack that was used for mining. Item in players main hand
      * @param newStack The new stack
      * @return True to reset block break progress
      */
-    public boolean shouldCauseBlockBreakReset(ItemStack oldStack, ItemStack newStack)
-    {
+    public boolean shouldCauseBlockBreakReset(ItemStack oldStack, ItemStack newStack) {
         return !(newStack.getItem() == oldStack.getItem() && ItemStack.areItemStackTagsEqual(newStack, oldStack) && (newStack.isItemStackDamageable() || newStack.getMetadata() == oldStack.getMetadata()));
     }
 
@@ -1075,28 +956,26 @@
      * @param newStack the stack currently in the active hand
      * @return true to set the new stack to active and continue using it
      */
-    public boolean canContinueUsing(ItemStack oldStack, ItemStack newStack)
-    {
+    public boolean canContinueUsing(ItemStack oldStack, ItemStack newStack) {
         return oldStack.equals(newStack);
     }
 
     /**
      * Called to get the Mod ID of the mod that *created* the ItemStack,
      * instead of the real Mod ID that *registered* it.
-     *
+     * <p>
      * For example the Forge Universal Bucket creates a subitem for each modded fluid,
      * and it returns the modded fluid's Mod ID here.
-     *
+     * <p>
      * Mods that register subitems for other mods can override this.
      * Informational mods can call it to show the mod that created the item.
      *
      * @param itemStack the ItemStack to check
      * @return the Mod ID for the ItemStack, or
-     *         null when there is no specially associated mod and {@link #getRegistryName()} would return null.
+     * null when there is no specially associated mod and {@link #getRegistryName()} would return null.
      */
     @Nullable
-    public String getCreatorModId(ItemStack itemStack)
-    {
+    public String getCreatorModId(ItemStack itemStack) {
         return net.minecraftforge.common.ForgeHooks.getDefaultCreatorModId(itemStack);
     }
 
@@ -1105,30 +984,25 @@
      * Can be retrieved from stack.getCapabilities()
      * The NBT can be null if this is not called from readNBT or if the item the stack is
      * changing FROM is different then this item, or the previous item had no capabilities.
-     *
+     * <p>
      * This is called BEFORE the stacks item is set so you can use stack.getItem() to see the OLD item.
      * Remember that getItem CAN return null.
      *
      * @param stack The ItemStack
-     * @param nbt NBT of this item serialized, or null.
+     * @param nbt   NBT of this item serialized, or null.
      * @return A holder instance associated with this ItemStack where you can hold capabilities for the life of this item.
      */
     @Nullable
-    public net.minecraftforge.common.capabilities.ICapabilityProvider initCapabilities(ItemStack stack, @Nullable NBTTagCompound nbt)
-    {
+    public net.minecraftforge.common.capabilities.ICapabilityProvider initCapabilities(ItemStack stack, @Nullable NBTTagCompound nbt) {
         return null;
     }
 
-    public com.google.common.collect.ImmutableMap<String, net.minecraftforge.common.animation.ITimeValue> getAnimationParameters(final ItemStack stack, final World world, final EntityLivingBase entity)
-    {
+    public com.google.common.collect.ImmutableMap<String, net.minecraftforge.common.animation.ITimeValue> getAnimationParameters(final ItemStack stack, final World world, final EntityLivingBase entity) {
         com.google.common.collect.ImmutableMap.Builder<String, net.minecraftforge.common.animation.ITimeValue> builder = com.google.common.collect.ImmutableMap.builder();
-        for(ResourceLocation location : properties.getKeys())
-        {
+        for (ResourceLocation location : properties.getKeys()) {
             final IItemPropertyGetter parameter = properties.getObject(location);
-            builder.put(location.toString(), new net.minecraftforge.common.animation.ITimeValue()
-            {
-                public float apply(float input)
-                {
+            builder.put(location.toString(), new net.minecraftforge.common.animation.ITimeValue() {
+                public float apply(float input) {
                     return parameter.apply(stack, world, entity);
                 }
             });
@@ -1138,25 +1012,25 @@
 
     /**
      * Can this Item disable a shield
-     * @param stack The ItemStack
-     * @param shield The shield in question
-     * @param entity The EntityLivingBase holding the shield
+     *
+     * @param stack    The ItemStack
+     * @param shield   The shield in question
+     * @param entity   The EntityLivingBase holding the shield
      * @param attacker The EntityLivingBase holding the ItemStack
      * @retrun True if this ItemStack can disable the shield in question.
      */
-    public boolean canDisableShield(ItemStack stack, ItemStack shield, EntityLivingBase entity, EntityLivingBase attacker)
-    {
+    public boolean canDisableShield(ItemStack stack, ItemStack shield, EntityLivingBase entity, EntityLivingBase attacker) {
         return this instanceof ItemAxe;
     }
 
     /**
      * Is this Item a shield
-     * @param stack The ItemStack
+     *
+     * @param stack  The ItemStack
      * @param entity The Entity holding the ItemStack
      * @return True if the ItemStack is considered a shield
      */
-    public boolean isShield(ItemStack stack, @Nullable EntityLivingBase entity)
-    {
+    public boolean isShield(ItemStack stack, @Nullable EntityLivingBase entity) {
         return stack.getItem() == Items.SHIELD;
     }
 
@@ -1165,99 +1039,85 @@
      * Return 0 to make it not act as a fuel.
      * Return -1 to let the default vanilla logic decide.
      */
-    public int getItemBurnTime(ItemStack itemStack)
-    {
+    public int getItemBurnTime(ItemStack itemStack) {
         return -1;
     }
-    
-    /** 
+
+    /**
      * Returns an enum constant of type {@code HorseArmorType}.
      * The returned enum constant will be used to determine the armor value and texture of this item when equipped.
+     *
      * @param stack the armor stack
      * @return an enum constant of type {@code HorseArmorType}. Return HorseArmorType.NONE if this is not horse armor
      */
-    public net.minecraft.entity.passive.HorseArmorType getHorseArmorType(ItemStack stack)
-    {
+    public net.minecraft.entity.passive.HorseArmorType getHorseArmorType(ItemStack stack) {
         return net.minecraft.entity.passive.HorseArmorType.getByItem(stack.getItem());
     }
-    
-    public String getHorseArmorTexture(net.minecraft.entity.EntityLiving wearer, ItemStack stack)
-    {
+
+    public String getHorseArmorTexture(net.minecraft.entity.EntityLiving wearer, ItemStack stack) {
         return getHorseArmorType(stack).getTextureName();
     }
-    
+
     /**
      * Called every tick from {@link EntityHorse#onUpdate()} on the item in the armor slot.
+     *
      * @param world the world the horse is in
      * @param horse the horse wearing this armor
      * @param armor the armor itemstack
      */
-    public void onHorseArmorTick(World world, net.minecraft.entity.EntityLiving horse, ItemStack armor) {}
-    
+    public void onHorseArmorTick(World world, net.minecraft.entity.EntityLiving horse, ItemStack armor) {
+    }
+
     @SideOnly(Side.CLIENT)
     @Nullable
     private net.minecraft.client.renderer.tileentity.TileEntityItemStackRenderer teisr;
-    
+
     /**
      * @return This Item's renderer, or the default instance if it does not have one.
      */
     @SideOnly(Side.CLIENT)
-    public final net.minecraft.client.renderer.tileentity.TileEntityItemStackRenderer getTileEntityItemStackRenderer()
-    {
-    	return teisr != null ? teisr : net.minecraft.client.renderer.tileentity.TileEntityItemStackRenderer.instance;
+    public final net.minecraft.client.renderer.tileentity.TileEntityItemStackRenderer getTileEntityItemStackRenderer() {
+        return teisr != null ? teisr : net.minecraft.client.renderer.tileentity.TileEntityItemStackRenderer.instance;
     }
-    
+
     @SideOnly(Side.CLIENT)
-    public void setTileEntityItemStackRenderer(@Nullable net.minecraft.client.renderer.tileentity.TileEntityItemStackRenderer teisr)
-    {
-    	this.teisr = teisr;
+    public void setTileEntityItemStackRenderer(@Nullable net.minecraft.client.renderer.tileentity.TileEntityItemStackRenderer teisr) {
+        this.teisr = teisr;
     }
 
-    public net.minecraftforge.common.IRarity getForgeRarity(ItemStack stack)
-    {
+    public net.minecraftforge.common.IRarity getForgeRarity(ItemStack stack) {
         return this.getRarity(stack);
     }
 
     /* ======================================== FORGE END   =====================================*/
 
-    public static void registerItems()
-    {
+    public static void registerItems() {
         registerItemBlock(Blocks.AIR, new ItemAir(Blocks.AIR));
-        registerItemBlock(Blocks.STONE, (new ItemMultiTexture(Blocks.STONE, Blocks.STONE, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.STONE, (new ItemMultiTexture(Blocks.STONE, Blocks.STONE, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockStone.EnumType.byMetadata(p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("stone"));
         registerItemBlock(Blocks.GRASS, new ItemColored(Blocks.GRASS, false));
-        registerItemBlock(Blocks.DIRT, (new ItemMultiTexture(Blocks.DIRT, Blocks.DIRT, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.DIRT, (new ItemMultiTexture(Blocks.DIRT, Blocks.DIRT, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockDirt.DirtType.byMetadata(p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("dirt"));
         registerItemBlock(Blocks.COBBLESTONE);
-        registerItemBlock(Blocks.PLANKS, (new ItemMultiTexture(Blocks.PLANKS, Blocks.PLANKS, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.PLANKS, (new ItemMultiTexture(Blocks.PLANKS, Blocks.PLANKS, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockPlanks.EnumType.byMetadata(p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("wood"));
-        registerItemBlock(Blocks.SAPLING, (new ItemMultiTexture(Blocks.SAPLING, Blocks.SAPLING, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.SAPLING, (new ItemMultiTexture(Blocks.SAPLING, Blocks.SAPLING, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockPlanks.EnumType.byMetadata(p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("sapling"));
         registerItemBlock(Blocks.BEDROCK);
-        registerItemBlock(Blocks.SAND, (new ItemMultiTexture(Blocks.SAND, Blocks.SAND, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.SAND, (new ItemMultiTexture(Blocks.SAND, Blocks.SAND, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockSand.EnumType.byMetadata(p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("sand"));
@@ -1265,26 +1125,20 @@
         registerItemBlock(Blocks.GOLD_ORE);
         registerItemBlock(Blocks.IRON_ORE);
         registerItemBlock(Blocks.COAL_ORE);
-        registerItemBlock(Blocks.LOG, (new ItemMultiTexture(Blocks.LOG, Blocks.LOG, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.LOG, (new ItemMultiTexture(Blocks.LOG, Blocks.LOG, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockPlanks.EnumType.byMetadata(p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("log"));
-        registerItemBlock(Blocks.LOG2, (new ItemMultiTexture(Blocks.LOG2, Blocks.LOG2, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.LOG2, (new ItemMultiTexture(Blocks.LOG2, Blocks.LOG2, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockPlanks.EnumType.byMetadata(p_apply_1_.getMetadata() + 4).getUnlocalizedName();
             }
         })).setUnlocalizedName("log"));
         registerItemBlock(Blocks.LEAVES, (new ItemLeaves(Blocks.LEAVES)).setUnlocalizedName("leaves"));
         registerItemBlock(Blocks.LEAVES2, (new ItemLeaves(Blocks.LEAVES2)).setUnlocalizedName("leaves"));
-        registerItemBlock(Blocks.SPONGE, (new ItemMultiTexture(Blocks.SPONGE, Blocks.SPONGE, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.SPONGE, (new ItemMultiTexture(Blocks.SPONGE, Blocks.SPONGE, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return (p_apply_1_.getMetadata() & 1) == 1 ? "wet" : "dry";
             }
         })).setUnlocalizedName("sponge"));
@@ -1292,10 +1146,8 @@
         registerItemBlock(Blocks.LAPIS_ORE);
         registerItemBlock(Blocks.LAPIS_BLOCK);
         registerItemBlock(Blocks.DISPENSER);
-        registerItemBlock(Blocks.SANDSTONE, (new ItemMultiTexture(Blocks.SANDSTONE, Blocks.SANDSTONE, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.SANDSTONE, (new ItemMultiTexture(Blocks.SANDSTONE, Blocks.SANDSTONE, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockSandStone.EnumType.byMetadata(p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("sandStone"));
@@ -1304,21 +1156,17 @@
         registerItemBlock(Blocks.DETECTOR_RAIL);
         registerItemBlock(Blocks.STICKY_PISTON, new ItemPiston(Blocks.STICKY_PISTON));
         registerItemBlock(Blocks.WEB);
-        registerItemBlock(Blocks.TALLGRASS, (new ItemColored(Blocks.TALLGRASS, true)).setSubtypeNames(new String[] {"shrub", "grass", "fern"}));
+        registerItemBlock(Blocks.TALLGRASS, (new ItemColored(Blocks.TALLGRASS, true)).setSubtypeNames(new String[]{"shrub", "grass", "fern"}));
         registerItemBlock(Blocks.DEADBUSH);
         registerItemBlock(Blocks.PISTON, new ItemPiston(Blocks.PISTON));
         registerItemBlock(Blocks.WOOL, (new ItemCloth(Blocks.WOOL)).setUnlocalizedName("cloth"));
-        registerItemBlock(Blocks.YELLOW_FLOWER, (new ItemMultiTexture(Blocks.YELLOW_FLOWER, Blocks.YELLOW_FLOWER, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.YELLOW_FLOWER, (new ItemMultiTexture(Blocks.YELLOW_FLOWER, Blocks.YELLOW_FLOWER, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockFlower.EnumFlowerType.getType(BlockFlower.EnumFlowerColor.YELLOW, p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("flower"));
-        registerItemBlock(Blocks.RED_FLOWER, (new ItemMultiTexture(Blocks.RED_FLOWER, Blocks.RED_FLOWER, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.RED_FLOWER, (new ItemMultiTexture(Blocks.RED_FLOWER, Blocks.RED_FLOWER, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockFlower.EnumFlowerType.getType(BlockFlower.EnumFlowerColor.RED, p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("rose"));
@@ -1375,17 +1223,13 @@
         registerItemBlock(Blocks.GLOWSTONE);
         registerItemBlock(Blocks.LIT_PUMPKIN);
         registerItemBlock(Blocks.TRAPDOOR);
-        registerItemBlock(Blocks.MONSTER_EGG, (new ItemMultiTexture(Blocks.MONSTER_EGG, Blocks.MONSTER_EGG, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.MONSTER_EGG, (new ItemMultiTexture(Blocks.MONSTER_EGG, Blocks.MONSTER_EGG, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockSilverfish.EnumType.byMetadata(p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("monsterStoneEgg"));
-        registerItemBlock(Blocks.STONEBRICK, (new ItemMultiTexture(Blocks.STONEBRICK, Blocks.STONEBRICK, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.STONEBRICK, (new ItemMultiTexture(Blocks.STONEBRICK, Blocks.STONEBRICK, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockStoneBrick.EnumType.byMetadata(p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("stonebricksmooth"));
@@ -1425,10 +1269,8 @@
         registerItemBlock(Blocks.JUNGLE_STAIRS);
         registerItemBlock(Blocks.COMMAND_BLOCK);
         registerItemBlock(Blocks.BEACON);
-        registerItemBlock(Blocks.COBBLESTONE_WALL, (new ItemMultiTexture(Blocks.COBBLESTONE_WALL, Blocks.COBBLESTONE_WALL, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.COBBLESTONE_WALL, (new ItemMultiTexture(Blocks.COBBLESTONE_WALL, Blocks.COBBLESTONE_WALL, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockWall.EnumType.byMetadata(p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("cobbleWall"));
@@ -1441,7 +1283,7 @@
         registerItemBlock(Blocks.REDSTONE_BLOCK);
         registerItemBlock(Blocks.QUARTZ_ORE);
         registerItemBlock(Blocks.HOPPER);
-        registerItemBlock(Blocks.QUARTZ_BLOCK, (new ItemMultiTexture(Blocks.QUARTZ_BLOCK, Blocks.QUARTZ_BLOCK, new String[] {"default", "chiseled", "lines"})).setUnlocalizedName("quartzBlock"));
+        registerItemBlock(Blocks.QUARTZ_BLOCK, (new ItemMultiTexture(Blocks.QUARTZ_BLOCK, Blocks.QUARTZ_BLOCK, new String[]{"default", "chiseled", "lines"})).setUnlocalizedName("quartzBlock"));
         registerItemBlock(Blocks.QUARTZ_STAIRS);
         registerItemBlock(Blocks.ACTIVATOR_RAIL);
         registerItemBlock(Blocks.DROPPER);
@@ -1457,27 +1299,21 @@
         registerItemBlock(Blocks.DARK_OAK_STAIRS);
         registerItemBlock(Blocks.SLIME_BLOCK);
         registerItemBlock(Blocks.GRASS_PATH);
-        registerItemBlock(Blocks.DOUBLE_PLANT, (new ItemMultiTexture(Blocks.DOUBLE_PLANT, Blocks.DOUBLE_PLANT, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.DOUBLE_PLANT, (new ItemMultiTexture(Blocks.DOUBLE_PLANT, Blocks.DOUBLE_PLANT, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockDoublePlant.EnumPlantType.byMetadata(p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("doublePlant"));
         registerItemBlock(Blocks.STAINED_GLASS, (new ItemCloth(Blocks.STAINED_GLASS)).setUnlocalizedName("stainedGlass"));
         registerItemBlock(Blocks.STAINED_GLASS_PANE, (new ItemCloth(Blocks.STAINED_GLASS_PANE)).setUnlocalizedName("stainedGlassPane"));
-        registerItemBlock(Blocks.PRISMARINE, (new ItemMultiTexture(Blocks.PRISMARINE, Blocks.PRISMARINE, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.PRISMARINE, (new ItemMultiTexture(Blocks.PRISMARINE, Blocks.PRISMARINE, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockPrismarine.EnumType.byMetadata(p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("prismarine"));
         registerItemBlock(Blocks.SEA_LANTERN);
-        registerItemBlock(Blocks.RED_SANDSTONE, (new ItemMultiTexture(Blocks.RED_SANDSTONE, Blocks.RED_SANDSTONE, new ItemMultiTexture.Mapper()
-        {
-            public String apply(ItemStack p_apply_1_)
-            {
+        registerItemBlock(Blocks.RED_SANDSTONE, (new ItemMultiTexture(Blocks.RED_SANDSTONE, Blocks.RED_SANDSTONE, new ItemMultiTexture.Mapper() {
+            public String apply(ItemStack p_apply_1_) {
                 return BlockRedSandstone.EnumType.byMetadata(p_apply_1_.getMetadata()).getUnlocalizedName();
             }
         })).setUnlocalizedName("redSandStone"));
@@ -1694,7 +1530,7 @@
         registerItem(419, "diamond_horse_armor", (new Item()).setUnlocalizedName("horsearmordiamond").setMaxStackSize(1).setCreativeTab(CreativeTabs.MISC));
         registerItem(420, "lead", (new ItemLead()).setUnlocalizedName("leash"));
         registerItem(421, "name_tag", (new ItemNameTag()).setUnlocalizedName("nameTag"));
-        registerItem(422, "command_block_minecart", (new ItemMinecart(EntityMinecart.Type.COMMAND_BLOCK)).setUnlocalizedName("minecartCommandBlock").setCreativeTab((CreativeTabs)null));
+        registerItem(422, "command_block_minecart", (new ItemMinecart(EntityMinecart.Type.COMMAND_BLOCK)).setUnlocalizedName("minecartCommandBlock").setCreativeTab((CreativeTabs) null));
         registerItem(423, "mutton", (new ItemFood(2, 0.3F, true)).setUnlocalizedName("muttonRaw"));
         registerItem(424, "cooked_mutton", (new ItemFood(6, 0.8F, true)).setUnlocalizedName("muttonCooked"));
         registerItem(425, "banner", (new ItemBanner()).setUnlocalizedName("banner"));
@@ -1739,35 +1575,29 @@
         registerItem(2267, "record_wait", (new ItemRecord("wait", SoundEvents.RECORD_WAIT)).setUnlocalizedName("record"));
     }
 
-    private static void registerItemBlock(Block blockIn)
-    {
+    private static void registerItemBlock(Block blockIn) {
         registerItemBlock(blockIn, new ItemBlock(blockIn));
     }
 
-    protected static void registerItemBlock(Block blockIn, Item itemIn)
-    {
+    protected static void registerItemBlock(Block blockIn, Item itemIn) {
         registerItem(Block.getIdFromBlock(blockIn), Block.REGISTRY.getNameForObject(blockIn), itemIn);
         BLOCK_TO_ITEM.put(blockIn, itemIn);
     }
 
-    private static void registerItem(int id, String textualID, Item itemIn)
-    {
+    private static void registerItem(int id, String textualID, Item itemIn) {
         registerItem(id, new ResourceLocation(textualID), itemIn);
     }
 
-    private static void registerItem(int id, ResourceLocation textualID, Item itemIn)
-    {
+    private static void registerItem(int id, ResourceLocation textualID, Item itemIn) {
         REGISTRY.register(id, textualID, itemIn);
     }
 
     @SideOnly(Side.CLIENT)
-    public ItemStack getDefaultInstance()
-    {
+    public ItemStack getDefaultInstance() {
         return new ItemStack(this);
     }
 
-    public static enum ToolMaterial
-    {
+    public static enum ToolMaterial {
         WOOD(0, 59, 2.0F, 0.0F, 15),
         STONE(1, 131, 4.0F, 1.0F, 5),
         IRON(2, 250, 6.0F, 2.0F, 14),
@@ -1782,8 +1612,7 @@
         //Added by forge for custom Tool materials.
         private ItemStack repairMaterial = ItemStack.EMPTY;
 
-        private ToolMaterial(int harvestLevel, int maxUses, float efficiency, float damageVsEntity, int enchantability)
-        {
+        private ToolMaterial(int harvestLevel, int maxUses, float efficiency, float damageVsEntity, int enchantability) {
             this.harvestLevel = harvestLevel;
             this.maxUses = maxUses;
             this.efficiency = efficiency;
@@ -1791,69 +1620,54 @@
             this.enchantability = enchantability;
         }
 
-        public int getMaxUses()
-        {
+        public int getMaxUses() {
             return this.maxUses;
         }
 
-        public float getEfficiency()
-        {
+        public float getEfficiency() {
             return this.efficiency;
         }
 
-        public float getAttackDamage()
-        {
+        public float getAttackDamage() {
             return this.attackDamage;
         }
 
-        public int getHarvestLevel()
-        {
+        public int getHarvestLevel() {
             return this.harvestLevel;
         }
 
-        public int getEnchantability()
-        {
+        public int getEnchantability() {
             return this.enchantability;
         }
 
         @Deprecated // Use getRepairItemStack below
-        public Item getRepairItem()
-        {
-            if (this == WOOD)
-            {
+        public Item getRepairItem() {
+            if (this == WOOD) {
                 return Item.getItemFromBlock(Blocks.PLANKS);
-            }
-            else if (this == STONE)
-            {
+            } else if (this == STONE) {
                 return Item.getItemFromBlock(Blocks.COBBLESTONE);
-            }
-            else if (this == GOLD)
-            {
+            } else if (this == GOLD) {
                 return Items.GOLD_INGOT;
-            }
-            else if (this == IRON)
-            {
+            } else if (this == IRON) {
                 return Items.IRON_INGOT;
-            }
-            else
-            {
+            } else {
                 return this == DIAMOND ? Items.DIAMOND : null;
             }
         }
 
-        public ToolMaterial setRepairItem(ItemStack stack)
-        {
+        public ToolMaterial setRepairItem(ItemStack stack) {
             if (!this.repairMaterial.isEmpty()) throw new RuntimeException("Repair material has already been set");
-            if (this == WOOD || this == STONE || this == GOLD || this == IRON || this == DIAMOND) throw new RuntimeException("Can not change vanilla tool repair materials");
+            if (this == WOOD || this == STONE || this == GOLD || this == IRON || this == DIAMOND)
+                throw new RuntimeException("Can not change vanilla tool repair materials");
             this.repairMaterial = stack;
             return this;
         }
 
-        public ItemStack getRepairItemStack()
-        {
+        public ItemStack getRepairItemStack() {
             if (!repairMaterial.isEmpty()) return repairMaterial;
             Item ret = this.getRepairItem();
-            if (ret != null) repairMaterial = new ItemStack(ret, 1, net.minecraftforge.oredict.OreDictionary.WILDCARD_VALUE);
+            if (ret != null)
+                repairMaterial = new ItemStack(ret, 1, net.minecraftforge.oredict.OreDictionary.WILDCARD_VALUE);
             return repairMaterial;
         }
     }
